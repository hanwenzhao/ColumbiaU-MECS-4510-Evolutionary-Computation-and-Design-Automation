# 1 "CMakeCUDACompilerId.cu"
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
# 1
#pragma GCC diagnostic push
# 1
#pragma GCC diagnostic ignored "-Wunused-variable"
# 1
#pragma GCC diagnostic ignored "-Wunused-function"
# 1
static char __nv_inited_managed_rt = 0; static void **__nv_fatbinhandle_for_managed_rt; static void __nv_save_fatbinhandle_for_managed_rt(void **in){__nv_fatbinhandle_for_managed_rt = in;} static char __nv_init_managed_rt_with_module(void **); static inline void __nv_init_managed_rt(void) { __nv_inited_managed_rt = (__nv_inited_managed_rt ? __nv_inited_managed_rt                 : __nv_init_managed_rt_with_module(__nv_fatbinhandle_for_managed_rt));}
# 1
#pragma GCC diagnostic pop
# 1
#pragma GCC diagnostic ignored "-Wunused-variable"

# 1
# 1
# 56 "/usr/include/cuda_runtime.h" 3
#pragma GCC diagnostic push
# 59
#pragma GCC diagnostic ignored "-Wunused-function"
# 61 "/usr/include/device_types.h" 3
#if 0
# 61
enum cudaRoundMode { 
# 63
cudaRoundNearest, 
# 64
cudaRoundZero, 
# 65
cudaRoundPosInf, 
# 66
cudaRoundMinInf
# 67
}; 
#endif
# 149 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3
typedef long ptrdiff_t; 
# 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3
typedef unsigned long size_t; 
#include "crt/host_runtime.h"
# 151 "/usr/include/driver_types.h" 3
#if 0
# 151
enum cudaError { 
# 158
cudaSuccess, 
# 164
cudaErrorMissingConfiguration, 
# 170
cudaErrorMemoryAllocation, 
# 176
cudaErrorInitializationError, 
# 186 "/usr/include/driver_types.h" 3
cudaErrorLaunchFailure, 
# 195 "/usr/include/driver_types.h" 3
cudaErrorPriorLaunchFailure, 
# 205 "/usr/include/driver_types.h" 3
cudaErrorLaunchTimeout, 
# 214 "/usr/include/driver_types.h" 3
cudaErrorLaunchOutOfResources, 
# 220
cudaErrorInvalidDeviceFunction, 
# 229 "/usr/include/driver_types.h" 3
cudaErrorInvalidConfiguration, 
# 235
cudaErrorInvalidDevice, 
# 241
cudaErrorInvalidValue, 
# 247
cudaErrorInvalidPitchValue, 
# 253
cudaErrorInvalidSymbol, 
# 258
cudaErrorMapBufferObjectFailed, 
# 263
cudaErrorUnmapBufferObjectFailed, 
# 269
cudaErrorInvalidHostPointer, 
# 275
cudaErrorInvalidDevicePointer, 
# 281
cudaErrorInvalidTexture, 
# 287
cudaErrorInvalidTextureBinding, 
# 294
cudaErrorInvalidChannelDescriptor, 
# 300
cudaErrorInvalidMemcpyDirection, 
# 310 "/usr/include/driver_types.h" 3
cudaErrorAddressOfConstant, 
# 319 "/usr/include/driver_types.h" 3
cudaErrorTextureFetchFailed, 
# 328 "/usr/include/driver_types.h" 3
cudaErrorTextureNotBound, 
# 337 "/usr/include/driver_types.h" 3
cudaErrorSynchronizationError, 
# 343
cudaErrorInvalidFilterSetting, 
# 349
cudaErrorInvalidNormSetting, 
# 357
cudaErrorMixedDeviceExecution, 
# 364
cudaErrorCudartUnloading, 
# 369
cudaErrorUnknown, 
# 377
cudaErrorNotYetImplemented, 
# 386 "/usr/include/driver_types.h" 3
cudaErrorMemoryValueTooLarge, 
# 393
cudaErrorInvalidResourceHandle, 
# 401
cudaErrorNotReady, 
# 408
cudaErrorInsufficientDriver, 
# 421 "/usr/include/driver_types.h" 3
cudaErrorSetOnActiveProcess, 
# 427
cudaErrorInvalidSurface, 
# 433
cudaErrorNoDevice, 
# 439
cudaErrorECCUncorrectable, 
# 444
cudaErrorSharedObjectSymbolNotFound, 
# 449
cudaErrorSharedObjectInitFailed, 
# 455
cudaErrorUnsupportedLimit, 
# 461
cudaErrorDuplicateVariableName, 
# 467
cudaErrorDuplicateTextureName, 
# 473
cudaErrorDuplicateSurfaceName, 
# 483 "/usr/include/driver_types.h" 3
cudaErrorDevicesUnavailable, 
# 488
cudaErrorInvalidKernelImage, 
# 496
cudaErrorNoKernelImageForDevice, 
# 509 "/usr/include/driver_types.h" 3
cudaErrorIncompatibleDriverContext, 
# 516
cudaErrorPeerAccessAlreadyEnabled, 
# 523
cudaErrorPeerAccessNotEnabled, 
# 529
cudaErrorDeviceAlreadyInUse = 54, 
# 536
cudaErrorProfilerDisabled, 
# 544
cudaErrorProfilerNotInitialized, 
# 551
cudaErrorProfilerAlreadyStarted, 
# 558
cudaErrorProfilerAlreadyStopped, 
# 566
cudaErrorAssert, 
# 573
cudaErrorTooManyPeers, 
# 579
cudaErrorHostMemoryAlreadyRegistered, 
# 585
cudaErrorHostMemoryNotRegistered, 
# 590
cudaErrorOperatingSystem, 
# 596
cudaErrorPeerAccessUnsupported, 
# 603
cudaErrorLaunchMaxDepthExceeded, 
# 611
cudaErrorLaunchFileScopedTex, 
# 619
cudaErrorLaunchFileScopedSurf, 
# 634 "/usr/include/driver_types.h" 3
cudaErrorSyncDepthExceeded, 
# 646 "/usr/include/driver_types.h" 3
cudaErrorLaunchPendingCountExceeded, 
# 651
cudaErrorNotPermitted, 
# 657
cudaErrorNotSupported, 
# 666 "/usr/include/driver_types.h" 3
cudaErrorHardwareStackError, 
# 674
cudaErrorIllegalInstruction, 
# 683 "/usr/include/driver_types.h" 3
cudaErrorMisalignedAddress, 
# 694 "/usr/include/driver_types.h" 3
cudaErrorInvalidAddressSpace, 
# 702
cudaErrorInvalidPc, 
# 710
cudaErrorIllegalAddress, 
# 716
cudaErrorInvalidPtx, 
# 721
cudaErrorInvalidGraphicsContext, 
# 727
cudaErrorStartupFailure = 127, 
# 735
cudaErrorApiFailureBase = 10000
# 736
}; 
#endif
# 741 "/usr/include/driver_types.h" 3
#if 0
# 741
enum cudaChannelFormatKind { 
# 743
cudaChannelFormatKindSigned, 
# 744
cudaChannelFormatKindUnsigned, 
# 745
cudaChannelFormatKindFloat, 
# 746
cudaChannelFormatKindNone
# 747
}; 
#endif
# 752 "/usr/include/driver_types.h" 3
#if 0
# 752
struct cudaChannelFormatDesc { 
# 754
int x; 
# 755
int y; 
# 756
int z; 
# 757
int w; 
# 758
cudaChannelFormatKind f; 
# 759
}; 
#endif
# 764 "/usr/include/driver_types.h" 3
typedef struct cudaArray *cudaArray_t; 
# 769
typedef const cudaArray *cudaArray_const_t; 
# 771
struct cudaArray; 
# 776
typedef struct cudaMipmappedArray *cudaMipmappedArray_t; 
# 781
typedef const cudaMipmappedArray *cudaMipmappedArray_const_t; 
# 783
struct cudaMipmappedArray; 
# 788
#if 0
# 788
enum cudaMemoryType { 
# 790
cudaMemoryTypeHost = 1, 
# 791
cudaMemoryTypeDevice
# 792
}; 
#endif
# 797 "/usr/include/driver_types.h" 3
#if 0
# 797
enum cudaMemcpyKind { 
# 799
cudaMemcpyHostToHost, 
# 800
cudaMemcpyHostToDevice, 
# 801
cudaMemcpyDeviceToHost, 
# 802
cudaMemcpyDeviceToDevice, 
# 803
cudaMemcpyDefault
# 804
}; 
#endif
# 811 "/usr/include/driver_types.h" 3
#if 0
# 811
struct cudaPitchedPtr { 
# 813
void *ptr; 
# 814
size_t pitch; 
# 815
size_t xsize; 
# 816
size_t ysize; 
# 817
}; 
#endif
# 824 "/usr/include/driver_types.h" 3
#if 0
# 824
struct cudaExtent { 
# 826
size_t width; 
# 827
size_t height; 
# 828
size_t depth; 
# 829
}; 
#endif
# 836 "/usr/include/driver_types.h" 3
#if 0
# 836
struct cudaPos { 
# 838
size_t x; 
# 839
size_t y; 
# 840
size_t z; 
# 841
}; 
#endif
# 846 "/usr/include/driver_types.h" 3
#if 0
# 846
struct cudaMemcpy3DParms { 
# 848
cudaArray_t srcArray; 
# 849
cudaPos srcPos; 
# 850
cudaPitchedPtr srcPtr; 
# 852
cudaArray_t dstArray; 
# 853
cudaPos dstPos; 
# 854
cudaPitchedPtr dstPtr; 
# 856
cudaExtent extent; 
# 857
cudaMemcpyKind kind; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
# 858
}; 
#endif
# 863 "/usr/include/driver_types.h" 3
#if 0
# 863
struct cudaMemcpy3DPeerParms { 
# 865
cudaArray_t srcArray; 
# 866
cudaPos srcPos; 
# 867
cudaPitchedPtr srcPtr; 
# 868
int srcDevice; 
# 870
cudaArray_t dstArray; 
# 871
cudaPos dstPos; 
# 872
cudaPitchedPtr dstPtr; 
# 873
int dstDevice; 
# 875
cudaExtent extent; 
# 876
}; 
#endif
# 881 "/usr/include/driver_types.h" 3
struct cudaGraphicsResource; 
# 886
#if 0
# 886
enum cudaGraphicsRegisterFlags { 
# 888
cudaGraphicsRegisterFlagsNone, 
# 889
cudaGraphicsRegisterFlagsReadOnly, 
# 890
cudaGraphicsRegisterFlagsWriteDiscard, 
# 891
cudaGraphicsRegisterFlagsSurfaceLoadStore = 4, 
# 892
cudaGraphicsRegisterFlagsTextureGather = 8
# 893
}; 
#endif
# 898 "/usr/include/driver_types.h" 3
#if 0
# 898
enum cudaGraphicsMapFlags { 
# 900
cudaGraphicsMapFlagsNone, 
# 901
cudaGraphicsMapFlagsReadOnly, 
# 902
cudaGraphicsMapFlagsWriteDiscard
# 903
}; 
#endif
# 908 "/usr/include/driver_types.h" 3
#if 0
# 908
enum cudaGraphicsCubeFace { 
# 910
cudaGraphicsCubeFacePositiveX, 
# 911
cudaGraphicsCubeFaceNegativeX, 
# 912
cudaGraphicsCubeFacePositiveY, 
# 913
cudaGraphicsCubeFaceNegativeY, 
# 914
cudaGraphicsCubeFacePositiveZ, 
# 915
cudaGraphicsCubeFaceNegativeZ
# 916
}; 
#endif
# 921 "/usr/include/driver_types.h" 3
#if 0
# 921
enum cudaResourceType { 
# 923
cudaResourceTypeArray, 
# 924
cudaResourceTypeMipmappedArray, 
# 925
cudaResourceTypeLinear, 
# 926
cudaResourceTypePitch2D
# 927
}; 
#endif
# 932 "/usr/include/driver_types.h" 3
#if 0
# 932
enum cudaResourceViewFormat { 
# 934
cudaResViewFormatNone, 
# 935
cudaResViewFormatUnsignedChar1, 
# 936
cudaResViewFormatUnsignedChar2, 
# 937
cudaResViewFormatUnsignedChar4, 
# 938
cudaResViewFormatSignedChar1, 
# 939
cudaResViewFormatSignedChar2, 
# 940
cudaResViewFormatSignedChar4, 
# 941
cudaResViewFormatUnsignedShort1, 
# 942
cudaResViewFormatUnsignedShort2, 
# 943
cudaResViewFormatUnsignedShort4, 
# 944
cudaResViewFormatSignedShort1, 
# 945
cudaResViewFormatSignedShort2, 
# 946
cudaResViewFormatSignedShort4, 
# 947
cudaResViewFormatUnsignedInt1, 
# 948
cudaResViewFormatUnsignedInt2, 
# 949
cudaResViewFormatUnsignedInt4, 
# 950
cudaResViewFormatSignedInt1, 
# 951
cudaResViewFormatSignedInt2, 
# 952
cudaResViewFormatSignedInt4, 
# 953
cudaResViewFormatHalf1, 
# 954
cudaResViewFormatHalf2, 
# 955
cudaResViewFormatHalf4, 
# 956
cudaResViewFormatFloat1, 
# 957
cudaResViewFormatFloat2, 
# 958
cudaResViewFormatFloat4, 
# 959
cudaResViewFormatUnsignedBlockCompressed1, 
# 960
cudaResViewFormatUnsignedBlockCompressed2, 
# 961
cudaResViewFormatUnsignedBlockCompressed3, 
# 962
cudaResViewFormatUnsignedBlockCompressed4, 
# 963
cudaResViewFormatSignedBlockCompressed4, 
# 964
cudaResViewFormatUnsignedBlockCompressed5, 
# 965
cudaResViewFormatSignedBlockCompressed5, 
# 966
cudaResViewFormatUnsignedBlockCompressed6H, 
# 967
cudaResViewFormatSignedBlockCompressed6H, 
# 968
cudaResViewFormatUnsignedBlockCompressed7
# 969
}; 
#endif
# 974 "/usr/include/driver_types.h" 3
#if 0
# 974
struct cudaResourceDesc { 
# 975
cudaResourceType resType; 
# 977
union { 
# 978
struct { 
# 979
cudaArray_t array; 
# 980
} array; 
# 981
struct { 
# 982
cudaMipmappedArray_t mipmap; 
# 983
} mipmap; 
# 984
struct { 
# 985
void *devPtr; 
# 986
cudaChannelFormatDesc desc; 
# 987
size_t sizeInBytes; 
# 988
} linear; 
# 989
struct { 
# 990
void *devPtr; 
# 991
cudaChannelFormatDesc desc; 
# 992
size_t width; 
# 993
size_t height; 
# 994
size_t pitchInBytes; 
# 995
} pitch2D; 
# 996
} res; 
# 997
}; 
#endif
# 1002 "/usr/include/driver_types.h" 3
#if 0
# 1002
struct cudaResourceViewDesc { 
# 1004
cudaResourceViewFormat format; 
# 1005
size_t width; 
# 1006
size_t height; 
# 1007
size_t depth; 
# 1008
unsigned firstMipmapLevel; 
# 1009
unsigned lastMipmapLevel; 
# 1010
unsigned firstLayer; 
# 1011
unsigned lastLayer; 
# 1012
}; 
#endif
# 1017 "/usr/include/driver_types.h" 3
#if 0
# 1017
struct cudaPointerAttributes { 
# 1023
cudaMemoryType memoryType; 
# 1034 "/usr/include/driver_types.h" 3
int device; 
# 1040
void *devicePointer; 
# 1046
void *hostPointer; 
# 1051
int isManaged; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
# 1052
}; 
#endif
# 1057 "/usr/include/driver_types.h" 3
#if 0
# 1057
struct cudaFuncAttributes { 
# 1064
size_t sharedSizeBytes; 
# 1070
size_t constSizeBytes; 
# 1075
size_t localSizeBytes; 
# 1082
int maxThreadsPerBlock; 
# 1087
int numRegs; 
# 1094
int ptxVersion; 
# 1101
int binaryVersion; 
# 1107
int cacheModeCA; 
# 1108
}; 
#endif
# 1113 "/usr/include/driver_types.h" 3
#if 0
# 1113
enum cudaFuncCache { 
# 1115
cudaFuncCachePreferNone, 
# 1116
cudaFuncCachePreferShared, 
# 1117
cudaFuncCachePreferL1, 
# 1118
cudaFuncCachePreferEqual
# 1119
}; 
#endif
# 1125 "/usr/include/driver_types.h" 3
#if 0
# 1125
enum cudaSharedMemConfig { 
# 1127
cudaSharedMemBankSizeDefault, 
# 1128
cudaSharedMemBankSizeFourByte, 
# 1129
cudaSharedMemBankSizeEightByte
# 1130
}; 
#endif
# 1135 "/usr/include/driver_types.h" 3
#if 0
# 1135
enum cudaComputeMode { 
# 1137
cudaComputeModeDefault, 
# 1138
cudaComputeModeExclusive, 
# 1139
cudaComputeModeProhibited, 
# 1140
cudaComputeModeExclusiveProcess
# 1141
}; 
#endif
# 1146 "/usr/include/driver_types.h" 3
#if 0
# 1146
enum cudaLimit { 
# 1148
cudaLimitStackSize, 
# 1149
cudaLimitPrintfFifoSize, 
# 1150
cudaLimitMallocHeapSize, 
# 1151
cudaLimitDevRuntimeSyncDepth, 
# 1152
cudaLimitDevRuntimePendingLaunchCount
# 1153
}; 
#endif
# 1158 "/usr/include/driver_types.h" 3
#if 0
# 1158
enum cudaOutputMode { 
# 1160
cudaKeyValuePair, 
# 1161
cudaCSV
# 1162
}; 
#endif
# 1167 "/usr/include/driver_types.h" 3
#if 0
# 1167
enum cudaDeviceAttr { 
# 1169
cudaDevAttrMaxThreadsPerBlock = 1, 
# 1170
cudaDevAttrMaxBlockDimX, 
# 1171
cudaDevAttrMaxBlockDimY, 
# 1172
cudaDevAttrMaxBlockDimZ, 
# 1173
cudaDevAttrMaxGridDimX, 
# 1174
cudaDevAttrMaxGridDimY, 
# 1175
cudaDevAttrMaxGridDimZ, 
# 1176
cudaDevAttrMaxSharedMemoryPerBlock, 
# 1177
cudaDevAttrTotalConstantMemory, 
# 1178
cudaDevAttrWarpSize, 
# 1179
cudaDevAttrMaxPitch, 
# 1180
cudaDevAttrMaxRegistersPerBlock, 
# 1181
cudaDevAttrClockRate, 
# 1182
cudaDevAttrTextureAlignment, 
# 1183
cudaDevAttrGpuOverlap, 
# 1184
cudaDevAttrMultiProcessorCount, 
# 1185
cudaDevAttrKernelExecTimeout, 
# 1186
cudaDevAttrIntegrated, 
# 1187
cudaDevAttrCanMapHostMemory, 
# 1188
cudaDevAttrComputeMode, 
# 1189
cudaDevAttrMaxTexture1DWidth, 
# 1190
cudaDevAttrMaxTexture2DWidth, 
# 1191
cudaDevAttrMaxTexture2DHeight, 
# 1192
cudaDevAttrMaxTexture3DWidth, 
# 1193
cudaDevAttrMaxTexture3DHeight, 
# 1194
cudaDevAttrMaxTexture3DDepth, 
# 1195
cudaDevAttrMaxTexture2DLayeredWidth, 
# 1196
cudaDevAttrMaxTexture2DLayeredHeight, 
# 1197
cudaDevAttrMaxTexture2DLayeredLayers, 
# 1198
cudaDevAttrSurfaceAlignment, 
# 1199
cudaDevAttrConcurrentKernels, 
# 1200
cudaDevAttrEccEnabled, 
# 1201
cudaDevAttrPciBusId, 
# 1202
cudaDevAttrPciDeviceId, 
# 1203
cudaDevAttrTccDriver, 
# 1204
cudaDevAttrMemoryClockRate, 
# 1205
cudaDevAttrGlobalMemoryBusWidth, 
# 1206
cudaDevAttrL2CacheSize, 
# 1207
cudaDevAttrMaxThreadsPerMultiProcessor, 
# 1208
cudaDevAttrAsyncEngineCount, 
# 1209
cudaDevAttrUnifiedAddressing, 
# 1210
cudaDevAttrMaxTexture1DLayeredWidth, 
# 1211
cudaDevAttrMaxTexture1DLayeredLayers, 
# 1212
cudaDevAttrMaxTexture2DGatherWidth = 45, 
# 1213
cudaDevAttrMaxTexture2DGatherHeight, 
# 1214
cudaDevAttrMaxTexture3DWidthAlt, 
# 1215
cudaDevAttrMaxTexture3DHeightAlt, 
# 1216
cudaDevAttrMaxTexture3DDepthAlt, 
# 1217
cudaDevAttrPciDomainId, 
# 1218
cudaDevAttrTexturePitchAlignment, 
# 1219
cudaDevAttrMaxTextureCubemapWidth, 
# 1220
cudaDevAttrMaxTextureCubemapLayeredWidth, 
# 1221
cudaDevAttrMaxTextureCubemapLayeredLayers, 
# 1222
cudaDevAttrMaxSurface1DWidth, 
# 1223
cudaDevAttrMaxSurface2DWidth, 
# 1224
cudaDevAttrMaxSurface2DHeight, 
# 1225
cudaDevAttrMaxSurface3DWidth, 
# 1226
cudaDevAttrMaxSurface3DHeight, 
# 1227
cudaDevAttrMaxSurface3DDepth, 
# 1228
cudaDevAttrMaxSurface1DLayeredWidth, 
# 1229
cudaDevAttrMaxSurface1DLayeredLayers, 
# 1230
cudaDevAttrMaxSurface2DLayeredWidth, 
# 1231
cudaDevAttrMaxSurface2DLayeredHeight, 
# 1232
cudaDevAttrMaxSurface2DLayeredLayers, 
# 1233
cudaDevAttrMaxSurfaceCubemapWidth, 
# 1234
cudaDevAttrMaxSurfaceCubemapLayeredWidth, 
# 1235
cudaDevAttrMaxSurfaceCubemapLayeredLayers, 
# 1236
cudaDevAttrMaxTexture1DLinearWidth, 
# 1237
cudaDevAttrMaxTexture2DLinearWidth, 
# 1238
cudaDevAttrMaxTexture2DLinearHeight, 
# 1239
cudaDevAttrMaxTexture2DLinearPitch, 
# 1240
cudaDevAttrMaxTexture2DMipmappedWidth, 
# 1241
cudaDevAttrMaxTexture2DMipmappedHeight, 
# 1242
cudaDevAttrComputeCapabilityMajor, 
# 1243
cudaDevAttrComputeCapabilityMinor, 
# 1244
cudaDevAttrMaxTexture1DMipmappedWidth, 
# 1245
cudaDevAttrStreamPrioritiesSupported, 
# 1246
cudaDevAttrGlobalL1CacheSupported, 
# 1247
cudaDevAttrLocalL1CacheSupported, 
# 1248
cudaDevAttrMaxSharedMemoryPerMultiprocessor, 
# 1249
cudaDevAttrMaxRegistersPerMultiprocessor, 
# 1250
cudaDevAttrManagedMemory, 
# 1251
cudaDevAttrIsMultiGpuBoard, 
# 1252
cudaDevAttrMultiGpuBoardGroupID
# 1253
}; 
#endif
# 1258 "/usr/include/driver_types.h" 3
#if 0
# 1258
struct cudaDeviceProp { 
# 1260
char name[256]; 
# 1261
size_t totalGlobalMem; 
# 1262
size_t sharedMemPerBlock; 
# 1263
int regsPerBlock; 
# 1264
int warpSize; 
# 1265
size_t memPitch; 
# 1266
int maxThreadsPerBlock; 
# 1267
int maxThreadsDim[3]; 
# 1268
int maxGridSize[3]; 
# 1269
int clockRate; 
# 1270
size_t totalConstMem; 
# 1271
int major; 
# 1272
int minor; 
# 1273
size_t textureAlignment; 
# 1274
size_t texturePitchAlignment; 
# 1275
int deviceOverlap; 
# 1276
int multiProcessorCount; 
# 1277
int kernelExecTimeoutEnabled; 
# 1278
int integrated; 
# 1279
int canMapHostMemory; 
# 1280
int computeMode; 
# 1281
int maxTexture1D; 
# 1282
int maxTexture1DMipmap; 
# 1283
int maxTexture1DLinear; 
# 1284
int maxTexture2D[2]; 
# 1285
int maxTexture2DMipmap[2]; 
# 1286
int maxTexture2DLinear[3]; 
# 1287
int maxTexture2DGather[2]; 
# 1288
int maxTexture3D[3]; 
# 1289
int maxTexture3DAlt[3]; 
# 1290
int maxTextureCubemap; 
# 1291
int maxTexture1DLayered[2]; 
# 1292
int maxTexture2DLayered[3]; 
# 1293
int maxTextureCubemapLayered[2]; 
# 1294
int maxSurface1D; 
# 1295
int maxSurface2D[2]; 
# 1296
int maxSurface3D[3]; 
# 1297
int maxSurface1DLayered[2]; 
# 1298
int maxSurface2DLayered[3]; 
# 1299
int maxSurfaceCubemap; 
# 1300
int maxSurfaceCubemapLayered[2]; 
# 1301
size_t surfaceAlignment; 
# 1302
int concurrentKernels; 
# 1303
int ECCEnabled; 
# 1304
int pciBusID; 
# 1305
int pciDeviceID; 
# 1306
int pciDomainID; 
# 1307
int tccDriver; 
# 1308
int asyncEngineCount; 
# 1309
int unifiedAddressing; 
# 1310
int memoryClockRate; 
# 1311
int memoryBusWidth; 
# 1312
int l2CacheSize; 
# 1313
int maxThreadsPerMultiProcessor; 
# 1314
int streamPrioritiesSupported; 
# 1315
int globalL1CacheSupported; 
# 1316
int localL1CacheSupported; 
# 1317
size_t sharedMemPerMultiprocessor; 
# 1318
int regsPerMultiprocessor; 
# 1319
int managedMemory; 
# 1320
int isMultiGpuBoard; 
# 1321
int multiGpuBoardGroupID; 
# 1322
}; 
#endif
# 1401 "/usr/include/driver_types.h" 3
#if 0
typedef 
# 1398
struct cudaIpcEventHandle_st { 
# 1400
char reserved[64]; 
# 1401
} cudaIpcEventHandle_t; 
#endif
# 1409 "/usr/include/driver_types.h" 3
#if 0
typedef 
# 1406
struct cudaIpcMemHandle_st { 
# 1408
char reserved[64]; 
# 1409
} cudaIpcMemHandle_t; 
#endif
# 1420 "/usr/include/driver_types.h" 3
#if 0
typedef cudaError 
# 1420
cudaError_t; 
#endif
# 1425 "/usr/include/driver_types.h" 3
#if 0
typedef struct CUstream_st *
# 1425
cudaStream_t; 
#endif
# 1430 "/usr/include/driver_types.h" 3
#if 0
typedef struct CUevent_st *
# 1430
cudaEvent_t; 
#endif
# 1435 "/usr/include/driver_types.h" 3
#if 0
typedef cudaGraphicsResource *
# 1435
cudaGraphicsResource_t; 
#endif
# 1440 "/usr/include/driver_types.h" 3
#if 0
typedef struct CUuuid_st 
# 1440
cudaUUID_t; 
#endif
# 1445 "/usr/include/driver_types.h" 3
#if 0
typedef cudaOutputMode 
# 1445
cudaOutputMode_t; 
#endif
# 84 "/usr/include/surface_types.h" 3
#if 0
# 84
enum cudaSurfaceBoundaryMode { 
# 86
cudaBoundaryModeZero, 
# 87
cudaBoundaryModeClamp, 
# 88
cudaBoundaryModeTrap
# 89
}; 
#endif
# 94 "/usr/include/surface_types.h" 3
#if 0
# 94
enum cudaSurfaceFormatMode { 
# 96
cudaFormatModeForced, 
# 97
cudaFormatModeAuto
# 98
}; 
#endif
# 103 "/usr/include/surface_types.h" 3
#if 0
# 103
struct surfaceReference { 
# 108
cudaChannelFormatDesc channelDesc; 
# 109
}; 
#endif
# 114 "/usr/include/surface_types.h" 3
#if 0
typedef unsigned long long 
# 114
cudaSurfaceObject_t; 
#endif
# 84 "/usr/include/texture_types.h" 3
#if 0
# 84
enum cudaTextureAddressMode { 
# 86
cudaAddressModeWrap, 
# 87
cudaAddressModeClamp, 
# 88
cudaAddressModeMirror, 
# 89
cudaAddressModeBorder
# 90
}; 
#endif
# 95 "/usr/include/texture_types.h" 3
#if 0
# 95
enum cudaTextureFilterMode { 
# 97
cudaFilterModePoint, 
# 98
cudaFilterModeLinear
# 99
}; 
#endif
# 104 "/usr/include/texture_types.h" 3
#if 0
# 104
enum cudaTextureReadMode { 
# 106
cudaReadModeElementType, 
# 107
cudaReadModeNormalizedFloat
# 108
}; 
#endif
# 113 "/usr/include/texture_types.h" 3
#if 0
# 113
struct textureReference { 
# 118
int normalized; 
# 122
cudaTextureFilterMode filterMode; 
# 126
cudaTextureAddressMode addressMode[3]; 
# 130
cudaChannelFormatDesc channelDesc; 
# 134
int sRGB; 
# 138
unsigned maxAnisotropy; 
# 142
cudaTextureFilterMode mipmapFilterMode; 
# 146
float mipmapLevelBias; 
# 150
float minMipmapLevelClamp; 
# 154
float maxMipmapLevelClamp; 
# 155
int __cudaReserved[15]; 
# 156
}; 
#endif
# 161 "/usr/include/texture_types.h" 3
#if 0
# 161
struct cudaTextureDesc { 
# 166
cudaTextureAddressMode addressMode[3]; 
# 170
cudaTextureFilterMode filterMode; 
# 174
cudaTextureReadMode readMode; 
# 178
int sRGB; 
# 182
int normalizedCoords; 
# 186
unsigned maxAnisotropy; 
# 190
cudaTextureFilterMode mipmapFilterMode; 
# 194
float mipmapLevelBias; 
# 198
float minMipmapLevelClamp; 
# 202
float maxMipmapLevelClamp; 
# 203
}; 
#endif
# 208 "/usr/include/texture_types.h" 3
#if 0
typedef unsigned long long 
# 208
cudaTextureObject_t; 
#endif
# 98 "/usr/include/vector_types.h" 3
#if 0
# 98
struct char1 { 
# 100
signed char x; 
# 101
}; 
#endif
# 103 "/usr/include/vector_types.h" 3
#if 0
# 103
struct uchar1 { 
# 105
unsigned char x; 
# 106
}; 
#endif
# 109 "/usr/include/vector_types.h" 3
#if 0
# 109
struct __attribute((aligned(2))) char2 { 
# 111
signed char x, y; 
# 112
}; 
#endif
# 114 "/usr/include/vector_types.h" 3
#if 0
# 114
struct __attribute((aligned(2))) uchar2 { 
# 116
unsigned char x, y; 
# 117
}; 
#endif
# 119 "/usr/include/vector_types.h" 3
#if 0
# 119
struct char3 { 
# 121
signed char x, y, z; 
# 122
}; 
#endif
# 124 "/usr/include/vector_types.h" 3
#if 0
# 124
struct uchar3 { 
# 126
unsigned char x, y, z; 
# 127
}; 
#endif
# 129 "/usr/include/vector_types.h" 3
#if 0
# 129
struct __attribute((aligned(4))) char4 { 
# 131
signed char x, y, z, w; 
# 132
}; 
#endif
# 134 "/usr/include/vector_types.h" 3
#if 0
# 134
struct __attribute((aligned(4))) uchar4 { 
# 136
unsigned char x, y, z, w; 
# 137
}; 
#endif
# 139 "/usr/include/vector_types.h" 3
#if 0
# 139
struct short1 { 
# 141
short x; 
# 142
}; 
#endif
# 144 "/usr/include/vector_types.h" 3
#if 0
# 144
struct ushort1 { 
# 146
unsigned short x; 
# 147
}; 
#endif
# 149 "/usr/include/vector_types.h" 3
#if 0
# 149
struct __attribute((aligned(4))) short2 { 
# 151
short x, y; 
# 152
}; 
#endif
# 154 "/usr/include/vector_types.h" 3
#if 0
# 154
struct __attribute((aligned(4))) ushort2 { 
# 156
unsigned short x, y; 
# 157
}; 
#endif
# 159 "/usr/include/vector_types.h" 3
#if 0
# 159
struct short3 { 
# 161
short x, y, z; 
# 162
}; 
#endif
# 164 "/usr/include/vector_types.h" 3
#if 0
# 164
struct ushort3 { 
# 166
unsigned short x, y, z; 
# 167
}; 
#endif
# 169 "/usr/include/vector_types.h" 3
#if 0
# 169
struct __attribute((aligned(8))) short4 { short x; short y; short z; short w; }; 
#endif
# 170 "/usr/include/vector_types.h" 3
#if 0
# 170
struct __attribute((aligned(8))) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; }; 
#endif
# 172 "/usr/include/vector_types.h" 3
#if 0
# 172
struct int1 { 
# 174
int x; 
# 175
}; 
#endif
# 177 "/usr/include/vector_types.h" 3
#if 0
# 177
struct uint1 { 
# 179
unsigned x; 
# 180
}; 
#endif
# 182 "/usr/include/vector_types.h" 3
#if 0
# 182
struct __attribute((aligned(8))) int2 { int x; int y; }; 
#endif
# 183 "/usr/include/vector_types.h" 3
#if 0
# 183
struct __attribute((aligned(8))) uint2 { unsigned x; unsigned y; }; 
#endif
# 185 "/usr/include/vector_types.h" 3
#if 0
# 185
struct int3 { 
# 187
int x, y, z; 
# 188
}; 
#endif
# 190 "/usr/include/vector_types.h" 3
#if 0
# 190
struct uint3 { 
# 192
unsigned x, y, z; 
# 193
}; 
#endif
# 195 "/usr/include/vector_types.h" 3
#if 0
# 195
struct __attribute((aligned(16))) int4 { 
# 197
int x, y, z, w; 
# 198
}; 
#endif
# 200 "/usr/include/vector_types.h" 3
#if 0
# 200
struct __attribute((aligned(16))) uint4 { 
# 202
unsigned x, y, z, w; 
# 203
}; 
#endif
# 205 "/usr/include/vector_types.h" 3
#if 0
# 205
struct long1 { 
# 207
long x; 
# 208
}; 
#endif
# 210 "/usr/include/vector_types.h" 3
#if 0
# 210
struct ulong1 { 
# 212
unsigned long x; 
# 213
}; 
#endif
# 220 "/usr/include/vector_types.h" 3
#if 0
# 220
struct __attribute((aligned((2) * sizeof(long)))) long2 { 
# 222
long x, y; 
# 223
}; 
#endif
# 225 "/usr/include/vector_types.h" 3
#if 0
# 225
struct __attribute((aligned((2) * sizeof(unsigned long)))) ulong2 { 
# 227
unsigned long x, y; 
# 228
}; 
#endif
# 232 "/usr/include/vector_types.h" 3
#if 0
# 232
struct long3 { 
# 234
long x, y, z; 
# 235
}; 
#endif
# 237 "/usr/include/vector_types.h" 3
#if 0
# 237
struct ulong3 { 
# 239
unsigned long x, y, z; 
# 240
}; 
#endif
# 242 "/usr/include/vector_types.h" 3
#if 0
# 242
struct __attribute((aligned(16))) long4 { 
# 244
long x, y, z, w; 
# 245
}; 
#endif
# 247 "/usr/include/vector_types.h" 3
#if 0
# 247
struct __attribute((aligned(16))) ulong4 { 
# 249
unsigned long x, y, z, w; 
# 250
}; 
#endif
# 252 "/usr/include/vector_types.h" 3
#if 0
# 252
struct float1 { 
# 254
float x; 
# 255
}; 
#endif
# 274 "/usr/include/vector_types.h" 3
#if 0
# 274
struct __attribute((aligned(8))) float2 { float x; float y; }; 
#endif
# 279 "/usr/include/vector_types.h" 3
#if 0
# 279
struct float3 { 
# 281
float x, y, z; 
# 282
}; 
#endif
# 284 "/usr/include/vector_types.h" 3
#if 0
# 284
struct __attribute((aligned(16))) float4 { 
# 286
float x, y, z, w; 
# 287
}; 
#endif
# 289 "/usr/include/vector_types.h" 3
#if 0
# 289
struct longlong1 { 
# 291
long long x; 
# 292
}; 
#endif
# 294 "/usr/include/vector_types.h" 3
#if 0
# 294
struct ulonglong1 { 
# 296
unsigned long long x; 
# 297
}; 
#endif
# 299 "/usr/include/vector_types.h" 3
#if 0
# 299
struct __attribute((aligned(16))) longlong2 { 
# 301
long long x, y; 
# 302
}; 
#endif
# 304 "/usr/include/vector_types.h" 3
#if 0
# 304
struct __attribute((aligned(16))) ulonglong2 { 
# 306
unsigned long long x, y; 
# 307
}; 
#endif
# 309 "/usr/include/vector_types.h" 3
#if 0
# 309
struct longlong3 { 
# 311
long long x, y, z; 
# 312
}; 
#endif
# 314 "/usr/include/vector_types.h" 3
#if 0
# 314
struct ulonglong3 { 
# 316
unsigned long long x, y, z; 
# 317
}; 
#endif
# 319 "/usr/include/vector_types.h" 3
#if 0
# 319
struct __attribute((aligned(16))) longlong4 { 
# 321
long long x, y, z, w; 
# 322
}; 
#endif
# 324 "/usr/include/vector_types.h" 3
#if 0
# 324
struct __attribute((aligned(16))) ulonglong4 { 
# 326
unsigned long long x, y, z, w; 
# 327
}; 
#endif
# 329 "/usr/include/vector_types.h" 3
#if 0
# 329
struct double1 { 
# 331
double x; 
# 332
}; 
#endif
# 334 "/usr/include/vector_types.h" 3
#if 0
# 334
struct __attribute((aligned(16))) double2 { 
# 336
double x, y; 
# 337
}; 
#endif
# 339 "/usr/include/vector_types.h" 3
#if 0
# 339
struct double3 { 
# 341
double x, y, z; 
# 342
}; 
#endif
# 344 "/usr/include/vector_types.h" 3
#if 0
# 344
struct __attribute((aligned(16))) double4 { 
# 346
double x, y, z, w; 
# 347
}; 
#endif
# 362 "/usr/include/vector_types.h" 3
#if 0
typedef char1 
# 362
char1; 
#endif
# 363 "/usr/include/vector_types.h" 3
#if 0
typedef uchar1 
# 363
uchar1; 
#endif
# 364 "/usr/include/vector_types.h" 3
#if 0
typedef char2 
# 364
char2; 
#endif
# 365 "/usr/include/vector_types.h" 3
#if 0
typedef uchar2 
# 365
uchar2; 
#endif
# 366 "/usr/include/vector_types.h" 3
#if 0
typedef char3 
# 366
char3; 
#endif
# 367 "/usr/include/vector_types.h" 3
#if 0
typedef uchar3 
# 367
uchar3; 
#endif
# 368 "/usr/include/vector_types.h" 3
#if 0
typedef char4 
# 368
char4; 
#endif
# 369 "/usr/include/vector_types.h" 3
#if 0
typedef uchar4 
# 369
uchar4; 
#endif
# 370 "/usr/include/vector_types.h" 3
#if 0
typedef short1 
# 370
short1; 
#endif
# 371 "/usr/include/vector_types.h" 3
#if 0
typedef ushort1 
# 371
ushort1; 
#endif
# 372 "/usr/include/vector_types.h" 3
#if 0
typedef short2 
# 372
short2; 
#endif
# 373 "/usr/include/vector_types.h" 3
#if 0
typedef ushort2 
# 373
ushort2; 
#endif
# 374 "/usr/include/vector_types.h" 3
#if 0
typedef short3 
# 374
short3; 
#endif
# 375 "/usr/include/vector_types.h" 3
#if 0
typedef ushort3 
# 375
ushort3; 
#endif
# 376 "/usr/include/vector_types.h" 3
#if 0
typedef short4 
# 376
short4; 
#endif
# 377 "/usr/include/vector_types.h" 3
#if 0
typedef ushort4 
# 377
ushort4; 
#endif
# 378 "/usr/include/vector_types.h" 3
#if 0
typedef int1 
# 378
int1; 
#endif
# 379 "/usr/include/vector_types.h" 3
#if 0
typedef uint1 
# 379
uint1; 
#endif
# 380 "/usr/include/vector_types.h" 3
#if 0
typedef int2 
# 380
int2; 
#endif
# 381 "/usr/include/vector_types.h" 3
#if 0
typedef uint2 
# 381
uint2; 
#endif
# 382 "/usr/include/vector_types.h" 3
#if 0
typedef int3 
# 382
int3; 
#endif
# 383 "/usr/include/vector_types.h" 3
#if 0
typedef uint3 
# 383
uint3; 
#endif
# 384 "/usr/include/vector_types.h" 3
#if 0
typedef int4 
# 384
int4; 
#endif
# 385 "/usr/include/vector_types.h" 3
#if 0
typedef uint4 
# 385
uint4; 
#endif
# 386 "/usr/include/vector_types.h" 3
#if 0
typedef long1 
# 386
long1; 
#endif
# 387 "/usr/include/vector_types.h" 3
#if 0
typedef ulong1 
# 387
ulong1; 
#endif
# 388 "/usr/include/vector_types.h" 3
#if 0
typedef long2 
# 388
long2; 
#endif
# 389 "/usr/include/vector_types.h" 3
#if 0
typedef ulong2 
# 389
ulong2; 
#endif
# 390 "/usr/include/vector_types.h" 3
#if 0
typedef long3 
# 390
long3; 
#endif
# 391 "/usr/include/vector_types.h" 3
#if 0
typedef ulong3 
# 391
ulong3; 
#endif
# 392 "/usr/include/vector_types.h" 3
#if 0
typedef long4 
# 392
long4; 
#endif
# 393 "/usr/include/vector_types.h" 3
#if 0
typedef ulong4 
# 393
ulong4; 
#endif
# 394 "/usr/include/vector_types.h" 3
#if 0
typedef float1 
# 394
float1; 
#endif
# 395 "/usr/include/vector_types.h" 3
#if 0
typedef float2 
# 395
float2; 
#endif
# 396 "/usr/include/vector_types.h" 3
#if 0
typedef float3 
# 396
float3; 
#endif
# 397 "/usr/include/vector_types.h" 3
#if 0
typedef float4 
# 397
float4; 
#endif
# 398 "/usr/include/vector_types.h" 3
#if 0
typedef longlong1 
# 398
longlong1; 
#endif
# 399 "/usr/include/vector_types.h" 3
#if 0
typedef ulonglong1 
# 399
ulonglong1; 
#endif
# 400 "/usr/include/vector_types.h" 3
#if 0
typedef longlong2 
# 400
longlong2; 
#endif
# 401 "/usr/include/vector_types.h" 3
#if 0
typedef ulonglong2 
# 401
ulonglong2; 
#endif
# 402 "/usr/include/vector_types.h" 3
#if 0
typedef longlong3 
# 402
longlong3; 
#endif
# 403 "/usr/include/vector_types.h" 3
#if 0
typedef ulonglong3 
# 403
ulonglong3; 
#endif
# 404 "/usr/include/vector_types.h" 3
#if 0
typedef longlong4 
# 404
longlong4; 
#endif
# 405 "/usr/include/vector_types.h" 3
#if 0
typedef ulonglong4 
# 405
ulonglong4; 
#endif
# 406 "/usr/include/vector_types.h" 3
#if 0
typedef double1 
# 406
double1; 
#endif
# 407 "/usr/include/vector_types.h" 3
#if 0
typedef double2 
# 407
double2; 
#endif
# 408 "/usr/include/vector_types.h" 3
#if 0
typedef double3 
# 408
double3; 
#endif
# 409 "/usr/include/vector_types.h" 3
#if 0
typedef double4 
# 409
double4; 
#endif
# 417 "/usr/include/vector_types.h" 3
#if 0
# 417
struct dim3 { 
# 419
unsigned x, y, z; 
# 425
}; 
#endif
# 427 "/usr/include/vector_types.h" 3
#if 0
typedef dim3 
# 427
dim3; 
#endif
# 106 "/usr/include/cuda_device_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
# 107
extern "C" cudaError_t cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); 
# 108
extern "C" cudaError_t cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
# 109
extern "C" cudaError_t cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
# 110
extern "C" cudaError_t cudaDeviceSynchronize(); 
# 111
extern "C" cudaError_t cudaGetLastError(); 
# 112
extern "C" cudaError_t cudaPeekAtLastError(); 
# 113
extern "C" const char *cudaGetErrorString(cudaError_t error); 
# 114
extern "C" const char *cudaGetErrorName(cudaError_t error); 
# 115
extern "C" cudaError_t cudaGetDeviceCount(int * count); 
# 116
extern "C" cudaError_t cudaGetDevice(int * device); 
# 117
extern "C" cudaError_t cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
# 118
extern "C" cudaError_t cudaStreamDestroy(cudaStream_t stream); 
# 119
extern "C" cudaError_t cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
# 120
extern "C" { __attribute__((unused)) extern cudaError_t cudaStreamWaitEvent_ptsz(cudaStream_t stream, cudaEvent_t event, unsigned flags); } 
# 121
extern "C" cudaError_t cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
# 122
extern "C" cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream); 
# 123
extern "C" { __attribute__((unused)) extern cudaError_t cudaEventRecord_ptsz(cudaEvent_t event, cudaStream_t stream); } 
# 124
extern "C" cudaError_t cudaEventDestroy(cudaEvent_t event); 
# 125
extern "C" cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
# 126
extern "C" cudaError_t cudaFree(void * devPtr); 
# 127
extern "C" cudaError_t cudaMalloc(void ** devPtr, size_t size); 
# 128
extern "C" cudaError_t cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); 
# 129
extern "C" { __attribute__((unused)) extern cudaError_t cudaMemcpyAsync_ptsz(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); } 
# 130
extern "C" cudaError_t cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); 
# 131
extern "C" { __attribute__((unused)) extern cudaError_t cudaMemcpy2DAsync_ptsz(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); } 
# 132
extern "C" cudaError_t cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream); 
# 133
extern "C" { __attribute__((unused)) extern cudaError_t cudaMemcpy3DAsync_ptsz(const cudaMemcpy3DParms * p, cudaStream_t stream); } 
# 134
extern "C" cudaError_t cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream); 
# 135
extern "C" { __attribute__((unused)) extern cudaError_t cudaMemsetAsync_ptsz(void * devPtr, int value, size_t count, cudaStream_t stream); } 
# 136
extern "C" cudaError_t cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); 
# 137
extern "C" { __attribute__((unused)) extern cudaError_t cudaMemset2DAsync_ptsz(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); } 
# 138
extern "C" cudaError_t cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); 
# 139
extern "C" { __attribute__((unused)) extern cudaError_t cudaMemset3DAsync_ptsz(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); } 
# 140
extern "C" cudaError_t cudaRuntimeGetVersion(int * runtimeVersion); 
# 161 "/usr/include/cuda_device_runtime_api.h" 3
extern "C" { __attribute__((unused)) extern void *cudaGetParameterBuffer(size_t alignment, size_t size); } 
# 189 "/usr/include/cuda_device_runtime_api.h" 3
extern "C" { __attribute__((unused)) extern void *cudaGetParameterBufferV2(void * func, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize); } 
# 190
extern "C" { __attribute__((unused)) extern cudaError_t cudaLaunchDevice_ptsz(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); } 
# 191
extern "C" { __attribute__((unused)) extern cudaError_t cudaLaunchDeviceV2_ptsz(void * parameterBuffer, cudaStream_t stream); } 
# 209 "/usr/include/cuda_device_runtime_api.h" 3
extern "C" { __attribute__((unused)) extern cudaError_t cudaLaunchDevice(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); } 
# 210
extern "C" { __attribute__((unused)) extern cudaError_t cudaLaunchDeviceV2(void * parameterBuffer, cudaStream_t stream); } 
# 213
extern "C" cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize); 
# 214
extern "C" cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
# 218
template< class T> static inline cudaError_t cudaMalloc(T ** devPtr, size_t size); 
# 219
template< class T> static inline cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, T * entry); 
# 220
template< class T> static inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize); 
# 221
template< class T> static inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
# 251 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceReset(); 
# 268 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceSynchronize(); 
# 343 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceSetLimit(cudaLimit limit, size_t value); 
# 372 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); 
# 403 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
# 438 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceGetStreamPriorityRange(int * leastPriority, int * greatestPriority); 
# 480 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceSetCacheConfig(cudaFuncCache cacheConfig); 
# 509 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
# 551 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceSetSharedMemConfig(cudaSharedMemConfig config); 
# 574 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceGetByPCIBusId(int * device, const char * pciBusId); 
# 601 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceGetPCIBusId(char * pciBusId, int len, int device); 
# 643 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaIpcGetEventHandle(cudaIpcEventHandle_t * handle, cudaEvent_t event); 
# 678 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaIpcOpenEventHandle(cudaEvent_t * event, cudaIpcEventHandle_t handle); 
# 716 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaIpcGetMemHandle(cudaIpcMemHandle_t * handle, void * devPtr); 
# 766 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaIpcOpenMemHandle(void ** devPtr, cudaIpcMemHandle_t handle, unsigned flags); 
# 796 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaIpcCloseMemHandle(void * devPtr); 
# 836 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaThreadExit(); 
# 860 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaThreadSynchronize(); 
# 907 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaThreadSetLimit(cudaLimit limit, size_t value); 
# 938 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaThreadGetLimit(size_t * pValue, cudaLimit limit); 
# 973 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaThreadGetCacheConfig(cudaFuncCache * pCacheConfig); 
# 1019 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaThreadSetCacheConfig(cudaFuncCache cacheConfig); 
# 1073 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetLastError(); 
# 1114 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaPeekAtLastError(); 
# 1129 "/usr/include/cuda_runtime_api.h" 3
extern "C" const char *cudaGetErrorName(cudaError_t error); 
# 1144 "/usr/include/cuda_runtime_api.h" 3
extern "C" const char *cudaGetErrorString(cudaError_t error); 
# 1174 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetDeviceCount(int * count); 
# 1410 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetDeviceProperties(cudaDeviceProp * prop, int device); 
# 1570 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
# 1589 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaChooseDevice(int * device, const cudaDeviceProp * prop); 
# 1623 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaSetDevice(int device); 
# 1640 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetDevice(int * device); 
# 1669 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaSetValidDevices(int * device_arr, int len); 
# 1731 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaSetDeviceFlags(unsigned flags); 
# 1772 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetDeviceFlags(unsigned * flags); 
# 1809 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaStreamCreate(cudaStream_t * pStream); 
# 1838 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
# 1881 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaStreamCreateWithPriority(cudaStream_t * pStream, unsigned flags, int priority); 
# 1905 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaStreamGetPriority(cudaStream_t hStream, int * priority); 
# 1926 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaStreamGetFlags(cudaStream_t hStream, unsigned * flags); 
# 1947 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaStreamDestroy(cudaStream_t stream); 
# 1979 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
# 1993 "/usr/include/cuda_runtime_api.h" 3
extern "C" { typedef void (*cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status, void * userData); }
# 2050 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaStreamAddCallback(cudaStream_t stream, cudaStreamCallback_t callback, void * userData, unsigned flags); 
# 2070 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaStreamSynchronize(cudaStream_t stream); 
# 2091 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaStreamQuery(cudaStream_t stream); 
# 2157 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaStreamAttachMemAsync(cudaStream_t stream, void * devPtr, size_t length, unsigned flags); 
# 2193 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaEventCreate(cudaEvent_t * event); 
# 2227 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
# 2258 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0); 
# 2290 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaEventQuery(cudaEvent_t event); 
# 2322 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaEventSynchronize(cudaEvent_t event); 
# 2347 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaEventDestroy(cudaEvent_t event); 
# 2388 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaEventElapsedTime(float * ms, cudaEvent_t start, cudaEvent_t end); 
# 2447 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaLaunchKernel(const void * func, dim3 gridDim, dim3 blockDim, void ** args, size_t sharedMem, cudaStream_t stream); 
# 2497 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaFuncSetCacheConfig(const void * func, cudaFuncCache cacheConfig); 
# 2551 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaFuncSetSharedMemConfig(const void * func, cudaSharedMemConfig config); 
# 2585 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
# 2608 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaSetDoubleForDevice(double * d); 
# 2631 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaSetDoubleForHost(double * d); 
# 2687 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize); 
# 2731 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize, unsigned flags); 
# 2782 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaConfigureCall(dim3 gridDim, dim3 blockDim, size_t sharedMem = 0, cudaStream_t stream = 0); 
# 2811 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaSetupArgument(const void * arg, size_t size, size_t offset); 
# 2849 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaLaunch(const void * func); 
# 2938 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMallocManaged(void ** devPtr, size_t size, unsigned flags); 
# 2964 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMalloc(void ** devPtr, size_t size); 
# 2993 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMallocHost(void ** ptr, size_t size); 
# 3032 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMallocPitch(void ** devPtr, size_t * pitch, size_t width, size_t height); 
# 3074 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMallocArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, size_t width, size_t height = 0, unsigned flags = 0); 
# 3101 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaFree(void * devPtr); 
# 3121 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaFreeHost(void * ptr); 
# 3143 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaFreeArray(cudaArray_t array); 
# 3165 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray); 
# 3224 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaHostAlloc(void ** pHost, size_t size, unsigned flags); 
# 3286 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaHostRegister(void * ptr, size_t size, unsigned flags); 
# 3305 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaHostUnregister(void * ptr); 
# 3332 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaHostGetDevicePointer(void ** pDevice, void * pHost, unsigned flags); 
# 3351 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaHostGetFlags(unsigned * pFlags, void * pHost); 
# 3386 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMalloc3D(cudaPitchedPtr * pitchedDevPtr, cudaExtent extent); 
# 3521 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMalloc3DArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned flags = 0); 
# 3642 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMallocMipmappedArray(cudaMipmappedArray_t * mipmappedArray, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned numLevels, unsigned flags = 0); 
# 3668 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetMipmappedArrayLevel(cudaArray_t * levelArray, cudaMipmappedArray_const_t mipmappedArray, unsigned level); 
# 3765 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpy3D(const cudaMemcpy3DParms * p); 
# 3793 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpy3DPeer(const cudaMemcpy3DPeerParms * p); 
# 3901 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream = 0); 
# 3924 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpy3DPeerAsync(const cudaMemcpy3DPeerParms * p, cudaStream_t stream = 0); 
# 3943 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemGetInfo(size_t * free, size_t * total); 
# 3964 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaArrayGetInfo(cudaChannelFormatDesc * desc, cudaExtent * extent, unsigned * flags, cudaArray_t array); 
# 3999 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpy(void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
# 4031 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpyPeer(void * dst, int dstDevice, const void * src, int srcDevice, size_t count); 
# 4065 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind); 
# 4099 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpyFromArray(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind); 
# 4134 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpyArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
# 4176 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpy2D(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
# 4218 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpy2DToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
# 4260 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpy2DFromArray(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind); 
# 4300 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpy2DArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
# 4335 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpyToSymbol(const void * symbol, const void * src, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyHostToDevice); 
# 4370 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpyFromSymbol(void * dst, const void * symbol, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyDeviceToHost); 
# 4416 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4448 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpyPeerAsync(void * dst, int dstDevice, const void * src, int srcDevice, size_t count, cudaStream_t stream = 0); 
# 4490 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpyToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4532 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpyFromArrayAsync(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4587 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4638 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpy2DToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4688 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpy2DFromArrayAsync(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4731 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpyToSymbolAsync(const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4774 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemcpyFromSymbolAsync(void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4800 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemset(void * devPtr, int value, size_t count); 
# 4830 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemset2D(void * devPtr, size_t pitch, int value, size_t width, size_t height); 
# 4873 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemset3D(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent); 
# 4905 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream = 0); 
# 4942 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream = 0); 
# 4992 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream = 0); 
# 5015 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetSymbolAddress(void ** devPtr, const void * symbol); 
# 5037 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetSymbolSize(size_t * size, const void * symbol); 
# 5190 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaPointerGetAttributes(cudaPointerAttributes * attributes, const void * ptr); 
# 5228 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceCanAccessPeer(int * canAccessPeer, int device, int peerDevice); 
# 5267 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceEnablePeerAccess(int peerDevice, unsigned flags); 
# 5286 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDeviceDisablePeerAccess(int peerDevice); 
# 5344 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource); 
# 5376 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource, unsigned flags); 
# 5412 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGraphicsMapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
# 5444 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGraphicsUnmapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
# 5473 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGraphicsResourceGetMappedPointer(void ** devPtr, size_t * size, cudaGraphicsResource_t resource); 
# 5507 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGraphicsSubResourceGetMappedArray(cudaArray_t * array, cudaGraphicsResource_t resource, unsigned arrayIndex, unsigned mipLevel); 
# 5532 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t * mipmappedArray, cudaGraphicsResource_t resource); 
# 5572 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetChannelDesc(cudaChannelFormatDesc * desc, cudaArray_const_t array); 
# 5607 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaChannelFormatDesc cudaCreateChannelDesc(int x, int y, int z, int w, cudaChannelFormatKind f); 
# 5654 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaBindTexture(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t size = ((2147483647) * 2U) + 1U); 
# 5705 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaBindTexture2D(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t width, size_t height, size_t pitch); 
# 5733 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaBindTextureToArray(const textureReference * texref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); 
# 5761 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaBindTextureToMipmappedArray(const textureReference * texref, cudaMipmappedArray_const_t mipmappedArray, const cudaChannelFormatDesc * desc); 
# 5782 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaUnbindTexture(const textureReference * texref); 
# 5807 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetTextureAlignmentOffset(size_t * offset, const textureReference * texref); 
# 5832 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetTextureReference(const textureReference ** texref, const void * symbol); 
# 5872 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaBindSurfaceToArray(const surfaceReference * surfref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); 
# 5891 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetSurfaceReference(const surfaceReference ** surfref, const void * symbol); 
# 6108 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaCreateTextureObject(cudaTextureObject_t * pTexObject, const cudaResourceDesc * pResDesc, const cudaTextureDesc * pTexDesc, const cudaResourceViewDesc * pResViewDesc); 
# 6123 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDestroyTextureObject(cudaTextureObject_t texObject); 
# 6139 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetTextureObjectResourceDesc(cudaResourceDesc * pResDesc, cudaTextureObject_t texObject); 
# 6155 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetTextureObjectTextureDesc(cudaTextureDesc * pTexDesc, cudaTextureObject_t texObject); 
# 6172 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetTextureObjectResourceViewDesc(cudaResourceViewDesc * pResViewDesc, cudaTextureObject_t texObject); 
# 6211 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaCreateSurfaceObject(cudaSurfaceObject_t * pSurfObject, const cudaResourceDesc * pResDesc); 
# 6226 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject); 
# 6241 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaGetSurfaceObjectResourceDesc(cudaResourceDesc * pResDesc, cudaSurfaceObject_t surfObject); 
# 6268 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaDriverGetVersion(int * driverVersion); 
# 6285 "/usr/include/cuda_runtime_api.h" 3
extern "C" cudaError_t cudaRuntimeGetVersion(int * runtimeVersion); 
# 6290
extern "C" cudaError_t cudaGetExportTable(const void ** ppExportTable, const cudaUUID_t * pExportTableId); 
# 107 "/usr/include/channel_descriptor.h" 3
template< class T> inline cudaChannelFormatDesc cudaCreateChannelDesc() 
# 108
{ 
# 109
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
# 110
} 
# 112
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf() 
# 113
{ 
# 114
int e = (((int)sizeof(unsigned short)) * 8); 
# 116
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 117
} 
# 119
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf1() 
# 120
{ 
# 121
int e = (((int)sizeof(unsigned short)) * 8); 
# 123
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 124
} 
# 126
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf2() 
# 127
{ 
# 128
int e = (((int)sizeof(unsigned short)) * 8); 
# 130
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
# 131
} 
# 133
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf4() 
# 134
{ 
# 135
int e = (((int)sizeof(unsigned short)) * 8); 
# 137
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
# 138
} 
# 140
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char> () 
# 141
{ 
# 142
int e = (((int)sizeof(char)) * 8); 
# 147
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 149
} 
# 151
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< signed char> () 
# 152
{ 
# 153
int e = (((int)sizeof(signed char)) * 8); 
# 155
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 156
} 
# 158
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned char> () 
# 159
{ 
# 160
int e = (((int)sizeof(unsigned char)) * 8); 
# 162
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 163
} 
# 165
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char1> () 
# 166
{ 
# 167
int e = (((int)sizeof(signed char)) * 8); 
# 169
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 170
} 
# 172
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar1> () 
# 173
{ 
# 174
int e = (((int)sizeof(unsigned char)) * 8); 
# 176
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 177
} 
# 179
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char2> () 
# 180
{ 
# 181
int e = (((int)sizeof(signed char)) * 8); 
# 183
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
# 184
} 
# 186
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar2> () 
# 187
{ 
# 188
int e = (((int)sizeof(unsigned char)) * 8); 
# 190
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
# 191
} 
# 193
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char4> () 
# 194
{ 
# 195
int e = (((int)sizeof(signed char)) * 8); 
# 197
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
# 198
} 
# 200
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar4> () 
# 201
{ 
# 202
int e = (((int)sizeof(unsigned char)) * 8); 
# 204
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
# 205
} 
# 207
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short> () 
# 208
{ 
# 209
int e = (((int)sizeof(short)) * 8); 
# 211
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 212
} 
# 214
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned short> () 
# 215
{ 
# 216
int e = (((int)sizeof(unsigned short)) * 8); 
# 218
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 219
} 
# 221
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short1> () 
# 222
{ 
# 223
int e = (((int)sizeof(short)) * 8); 
# 225
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 226
} 
# 228
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort1> () 
# 229
{ 
# 230
int e = (((int)sizeof(unsigned short)) * 8); 
# 232
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 233
} 
# 235
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short2> () 
# 236
{ 
# 237
int e = (((int)sizeof(short)) * 8); 
# 239
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
# 240
} 
# 242
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort2> () 
# 243
{ 
# 244
int e = (((int)sizeof(unsigned short)) * 8); 
# 246
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
# 247
} 
# 249
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short4> () 
# 250
{ 
# 251
int e = (((int)sizeof(short)) * 8); 
# 253
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
# 254
} 
# 256
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort4> () 
# 257
{ 
# 258
int e = (((int)sizeof(unsigned short)) * 8); 
# 260
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
# 261
} 
# 263
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int> () 
# 264
{ 
# 265
int e = (((int)sizeof(int)) * 8); 
# 267
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 268
} 
# 270
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned> () 
# 271
{ 
# 272
int e = (((int)sizeof(unsigned)) * 8); 
# 274
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 275
} 
# 277
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int1> () 
# 278
{ 
# 279
int e = (((int)sizeof(int)) * 8); 
# 281
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 282
} 
# 284
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uint1> () 
# 285
{ 
# 286
int e = (((int)sizeof(unsigned)) * 8); 
# 288
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 289
} 
# 291
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int2> () 
# 292
{ 
# 293
int e = (((int)sizeof(int)) * 8); 
# 295
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
# 296
} 
# 298
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uint2> () 
# 299
{ 
# 300
int e = (((int)sizeof(unsigned)) * 8); 
# 302
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
# 303
} 
# 305
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int4> () 
# 306
{ 
# 307
int e = (((int)sizeof(int)) * 8); 
# 309
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
# 310
} 
# 312
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uint4> () 
# 313
{ 
# 314
int e = (((int)sizeof(unsigned)) * 8); 
# 316
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
# 317
} 
# 379 "/usr/include/channel_descriptor.h" 3
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float> () 
# 380
{ 
# 381
int e = (((int)sizeof(float)) * 8); 
# 383
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 384
} 
# 386
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float1> () 
# 387
{ 
# 388
int e = (((int)sizeof(float)) * 8); 
# 390
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 391
} 
# 393
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float2> () 
# 394
{ 
# 395
int e = (((int)sizeof(float)) * 8); 
# 397
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
# 398
} 
# 400
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float4> () 
# 401
{ 
# 402
int e = (((int)sizeof(float)) * 8); 
# 404
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
# 405
} 
# 79 "/usr/include/driver_functions.h" 3
static inline cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
# 80
{ 
# 81
cudaPitchedPtr s; 
# 83
(s.ptr) = d; 
# 84
(s.pitch) = p; 
# 85
(s.xsize) = xsz; 
# 86
(s.ysize) = ysz; 
# 88
return s; 
# 89
} 
# 106 "/usr/include/driver_functions.h" 3
static inline cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
# 107
{ 
# 108
cudaPos p; 
# 110
(p.x) = x; 
# 111
(p.y) = y; 
# 112
(p.z) = z; 
# 114
return p; 
# 115
} 
# 132 "/usr/include/driver_functions.h" 3
static inline cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
# 133
{ 
# 134
cudaExtent e; 
# 136
(e.width) = w; 
# 137
(e.height) = h; 
# 138
(e.depth) = d; 
# 140
return e; 
# 141
} 
# 75 "/usr/include/vector_functions.h" 3
static inline char1 make_char1(signed char x); 
# 77
static inline uchar1 make_uchar1(unsigned char x); 
# 79
static inline char2 make_char2(signed char x, signed char y); 
# 81
static inline uchar2 make_uchar2(unsigned char x, unsigned char y); 
# 83
static inline char3 make_char3(signed char x, signed char y, signed char z); 
# 85
static inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z); 
# 87
static inline char4 make_char4(signed char x, signed char y, signed char z, signed char w); 
# 89
static inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w); 
# 91
static inline short1 make_short1(short x); 
# 93
static inline ushort1 make_ushort1(unsigned short x); 
# 95
static inline short2 make_short2(short x, short y); 
# 97
static inline ushort2 make_ushort2(unsigned short x, unsigned short y); 
# 99
static inline short3 make_short3(short x, short y, short z); 
# 101
static inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z); 
# 103
static inline short4 make_short4(short x, short y, short z, short w); 
# 105
static inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w); 
# 107
static inline int1 make_int1(int x); 
# 109
static inline uint1 make_uint1(unsigned x); 
# 111
static inline int2 make_int2(int x, int y); 
# 113
static inline uint2 make_uint2(unsigned x, unsigned y); 
# 115
static inline int3 make_int3(int x, int y, int z); 
# 117
static inline uint3 make_uint3(unsigned x, unsigned y, unsigned z); 
# 119
static inline int4 make_int4(int x, int y, int z, int w); 
# 121
static inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w); 
# 123
static inline long1 make_long1(long x); 
# 125
static inline ulong1 make_ulong1(unsigned long x); 
# 127
static inline long2 make_long2(long x, long y); 
# 129
static inline ulong2 make_ulong2(unsigned long x, unsigned long y); 
# 131
static inline long3 make_long3(long x, long y, long z); 
# 133
static inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z); 
# 135
static inline long4 make_long4(long x, long y, long z, long w); 
# 137
static inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w); 
# 139
static inline float1 make_float1(float x); 
# 141
static inline float2 make_float2(float x, float y); 
# 143
static inline float3 make_float3(float x, float y, float z); 
# 145
static inline float4 make_float4(float x, float y, float z, float w); 
# 147
static inline longlong1 make_longlong1(long long x); 
# 149
static inline ulonglong1 make_ulonglong1(unsigned long long x); 
# 151
static inline longlong2 make_longlong2(long long x, long long y); 
# 153
static inline ulonglong2 make_ulonglong2(unsigned long long x, unsigned long long y); 
# 155
static inline longlong3 make_longlong3(long long x, long long y, long long z); 
# 157
static inline ulonglong3 make_ulonglong3(unsigned long long x, unsigned long long y, unsigned long long z); 
# 159
static inline longlong4 make_longlong4(long long x, long long y, long long z, long long w); 
# 161
static inline ulonglong4 make_ulonglong4(unsigned long long x, unsigned long long y, unsigned long long z, unsigned long long w); 
# 163
static inline double1 make_double1(double x); 
# 165
static inline double2 make_double2(double x, double y); 
# 167
static inline double3 make_double3(double x, double y, double z); 
# 169
static inline double4 make_double4(double x, double y, double z, double w); 
# 75 "/usr/include/vector_functions.hpp" 3
static inline char1 make_char1(signed char x) 
# 76
{ 
# 77
char1 t; (t.x) = x; return t; 
# 78
} 
# 80
static inline uchar1 make_uchar1(unsigned char x) 
# 81
{ 
# 82
uchar1 t; (t.x) = x; return t; 
# 83
} 
# 85
static inline char2 make_char2(signed char x, signed char y) 
# 86
{ 
# 87
char2 t; (t.x) = x; (t.y) = y; return t; 
# 88
} 
# 90
static inline uchar2 make_uchar2(unsigned char x, unsigned char y) 
# 91
{ 
# 92
uchar2 t; (t.x) = x; (t.y) = y; return t; 
# 93
} 
# 95
static inline char3 make_char3(signed char x, signed char y, signed char z) 
# 96
{ 
# 97
char3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 98
} 
# 100
static inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z) 
# 101
{ 
# 102
uchar3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 103
} 
# 105
static inline char4 make_char4(signed char x, signed char y, signed char z, signed char w) 
# 106
{ 
# 107
char4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 108
} 
# 110
static inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w) 
# 111
{ 
# 112
uchar4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 113
} 
# 115
static inline short1 make_short1(short x) 
# 116
{ 
# 117
short1 t; (t.x) = x; return t; 
# 118
} 
# 120
static inline ushort1 make_ushort1(unsigned short x) 
# 121
{ 
# 122
ushort1 t; (t.x) = x; return t; 
# 123
} 
# 125
static inline short2 make_short2(short x, short y) 
# 126
{ 
# 127
short2 t; (t.x) = x; (t.y) = y; return t; 
# 128
} 
# 130
static inline ushort2 make_ushort2(unsigned short x, unsigned short y) 
# 131
{ 
# 132
ushort2 t; (t.x) = x; (t.y) = y; return t; 
# 133
} 
# 135
static inline short3 make_short3(short x, short y, short z) 
# 136
{ 
# 137
short3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 138
} 
# 140
static inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z) 
# 141
{ 
# 142
ushort3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 143
} 
# 145
static inline short4 make_short4(short x, short y, short z, short w) 
# 146
{ 
# 147
short4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 148
} 
# 150
static inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w) 
# 151
{ 
# 152
ushort4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 153
} 
# 155
static inline int1 make_int1(int x) 
# 156
{ 
# 157
int1 t; (t.x) = x; return t; 
# 158
} 
# 160
static inline uint1 make_uint1(unsigned x) 
# 161
{ 
# 162
uint1 t; (t.x) = x; return t; 
# 163
} 
# 165
static inline int2 make_int2(int x, int y) 
# 166
{ 
# 167
int2 t; (t.x) = x; (t.y) = y; return t; 
# 168
} 
# 170
static inline uint2 make_uint2(unsigned x, unsigned y) 
# 171
{ 
# 172
uint2 t; (t.x) = x; (t.y) = y; return t; 
# 173
} 
# 175
static inline int3 make_int3(int x, int y, int z) 
# 176
{ 
# 177
int3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 178
} 
# 180
static inline uint3 make_uint3(unsigned x, unsigned y, unsigned z) 
# 181
{ 
# 182
uint3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 183
} 
# 185
static inline int4 make_int4(int x, int y, int z, int w) 
# 186
{ 
# 187
int4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 188
} 
# 190
static inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w) 
# 191
{ 
# 192
uint4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 193
} 
# 195
static inline long1 make_long1(long x) 
# 196
{ 
# 197
long1 t; (t.x) = x; return t; 
# 198
} 
# 200
static inline ulong1 make_ulong1(unsigned long x) 
# 201
{ 
# 202
ulong1 t; (t.x) = x; return t; 
# 203
} 
# 205
static inline long2 make_long2(long x, long y) 
# 206
{ 
# 207
long2 t; (t.x) = x; (t.y) = y; return t; 
# 208
} 
# 210
static inline ulong2 make_ulong2(unsigned long x, unsigned long y) 
# 211
{ 
# 212
ulong2 t; (t.x) = x; (t.y) = y; return t; 
# 213
} 
# 215
static inline long3 make_long3(long x, long y, long z) 
# 216
{ 
# 217
long3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 218
} 
# 220
static inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z) 
# 221
{ 
# 222
ulong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 223
} 
# 225
static inline long4 make_long4(long x, long y, long z, long w) 
# 226
{ 
# 227
long4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 228
} 
# 230
static inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w) 
# 231
{ 
# 232
ulong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 233
} 
# 235
static inline float1 make_float1(float x) 
# 236
{ 
# 237
float1 t; (t.x) = x; return t; 
# 238
} 
# 240
static inline float2 make_float2(float x, float y) 
# 241
{ 
# 242
float2 t; (t.x) = x; (t.y) = y; return t; 
# 243
} 
# 245
static inline float3 make_float3(float x, float y, float z) 
# 246
{ 
# 247
float3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 248
} 
# 250
static inline float4 make_float4(float x, float y, float z, float w) 
# 251
{ 
# 252
float4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 253
} 
# 255
static inline longlong1 make_longlong1(long long x) 
# 256
{ 
# 257
longlong1 t; (t.x) = x; return t; 
# 258
} 
# 260
static inline ulonglong1 make_ulonglong1(unsigned long long x) 
# 261
{ 
# 262
ulonglong1 t; (t.x) = x; return t; 
# 263
} 
# 265
static inline longlong2 make_longlong2(long long x, long long y) 
# 266
{ 
# 267
longlong2 t; (t.x) = x; (t.y) = y; return t; 
# 268
} 
# 270
static inline ulonglong2 make_ulonglong2(unsigned long long x, unsigned long long y) 
# 271
{ 
# 272
ulonglong2 t; (t.x) = x; (t.y) = y; return t; 
# 273
} 
# 275
static inline longlong3 make_longlong3(long long x, long long y, long long z) 
# 276
{ 
# 277
longlong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 278
} 
# 280
static inline ulonglong3 make_ulonglong3(unsigned long long x, unsigned long long y, unsigned long long z) 
# 281
{ 
# 282
ulonglong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 283
} 
# 285
static inline longlong4 make_longlong4(long long x, long long y, long long z, long long w) 
# 286
{ 
# 287
longlong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 288
} 
# 290
static inline ulonglong4 make_ulonglong4(unsigned long long x, unsigned long long y, unsigned long long z, unsigned long long w) 
# 291
{ 
# 292
ulonglong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 293
} 
# 295
static inline double1 make_double1(double x) 
# 296
{ 
# 297
double1 t; (t.x) = x; return t; 
# 298
} 
# 300
static inline double2 make_double2(double x, double y) 
# 301
{ 
# 302
double2 t; (t.x) = x; (t.y) = y; return t; 
# 303
} 
# 305
static inline double3 make_double3(double x, double y, double z) 
# 306
{ 
# 307
double3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 308
} 
# 310
static inline double4 make_double4(double x, double y, double z, double w) 
# 311
{ 
# 312
double4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 313
} 
# 42 "/usr/include/string.h" 3
extern "C" void *memcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t __n) throw()
# 43
 __attribute((__nonnull__(1, 2))); 
# 46
extern "C" void *memmove(void * __dest, const void * __src, size_t __n) throw()
# 47
 __attribute((__nonnull__(1, 2))); 
# 54
extern "C" void *memccpy(void *__restrict__ __dest, const void *__restrict__ __src, int __c, size_t __n) throw()
# 56
 __attribute((__nonnull__(1, 2))); 
# 62
extern "C" void *memset(void * __s, int __c, size_t __n) throw() __attribute((__nonnull__(1))); 
# 65
extern "C" int memcmp(const void * __s1, const void * __s2, size_t __n) throw()
# 66
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 72
extern void *memchr(void * __s, int __c, size_t __n) throw() __asm__("memchr")
# 73
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 74
extern const void *memchr(const void * __s, int __c, size_t __n) throw() __asm__("memchr")
# 75
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 101 "/usr/include/string.h" 3
void *rawmemchr(void * __s, int __c) throw() __asm__("rawmemchr")
# 102
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 103
const void *rawmemchr(const void * __s, int __c) throw() __asm__("rawmemchr")
# 104
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 112
void *memrchr(void * __s, int __c, size_t __n) throw() __asm__("memrchr")
# 113
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 114
const void *memrchr(const void * __s, int __c, size_t __n) throw() __asm__("memrchr")
# 115
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 125
extern "C" char *strcpy(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 126
 __attribute((__nonnull__(1, 2))); 
# 128
extern "C" char *strncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 130
 __attribute((__nonnull__(1, 2))); 
# 133
extern "C" char *strcat(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 134
 __attribute((__nonnull__(1, 2))); 
# 136
extern "C" char *strncat(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 137
 __attribute((__nonnull__(1, 2))); 
# 140
extern "C" int strcmp(const char * __s1, const char * __s2) throw()
# 141
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 143
extern "C" int strncmp(const char * __s1, const char * __s2, size_t __n) throw()
# 144
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 147
extern "C" int strcoll(const char * __s1, const char * __s2) throw()
# 148
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 150
extern "C" size_t strxfrm(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 152
 __attribute((__nonnull__(2))); 
# 39 "/usr/include/xlocale.h" 3
extern "C" { typedef 
# 27
struct __locale_struct { 
# 30
struct __locale_data *__locales[13]; 
# 33
const unsigned short *__ctype_b; 
# 34
const int *__ctype_tolower; 
# 35
const int *__ctype_toupper; 
# 38
const char *__names[13]; 
# 39
} *__locale_t; }
# 42
extern "C" { typedef __locale_t locale_t; }
# 162 "/usr/include/string.h" 3
extern "C" int strcoll_l(const char * __s1, const char * __s2, __locale_t __l) throw()
# 163
 __attribute((__pure__)) __attribute((__nonnull__(1, 2, 3))); 
# 165
extern "C" size_t strxfrm_l(char * __dest, const char * __src, size_t __n, __locale_t __l) throw()
# 166
 __attribute((__nonnull__(2, 4))); 
# 171
extern "C" char *strdup(const char * __s) throw()
# 172
 __attribute((__malloc__)) __attribute((__nonnull__(1))); 
# 179
extern "C" char *strndup(const char * __string, size_t __n) throw()
# 180
 __attribute((__malloc__)) __attribute((__nonnull__(1))); 
# 211 "/usr/include/string.h" 3
extern char *strchr(char * __s, int __c) throw() __asm__("strchr")
# 212
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 213
extern const char *strchr(const char * __s, int __c) throw() __asm__("strchr")
# 214
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 238 "/usr/include/string.h" 3
extern char *strrchr(char * __s, int __c) throw() __asm__("strrchr")
# 239
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 240
extern const char *strrchr(const char * __s, int __c) throw() __asm__("strrchr")
# 241
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 267 "/usr/include/string.h" 3
char *strchrnul(char * __s, int __c) throw() __asm__("strchrnul")
# 268
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 269
const char *strchrnul(const char * __s, int __c) throw() __asm__("strchrnul")
# 270
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 280
extern "C" size_t strcspn(const char * __s, const char * __reject) throw()
# 281
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 284
extern "C" size_t strspn(const char * __s, const char * __accept) throw()
# 285
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 290
extern char *strpbrk(char * __s, const char * __accept) throw() __asm__("strpbrk")
# 291
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 292
extern const char *strpbrk(const char * __s, const char * __accept) throw() __asm__("strpbrk")
# 293
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 317 "/usr/include/string.h" 3
extern char *strstr(char * __haystack, const char * __needle) throw() __asm__("strstr")
# 318
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 319
extern const char *strstr(const char * __haystack, const char * __needle) throw() __asm__("strstr")
# 320
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 343 "/usr/include/string.h" 3
extern "C" char *strtok(char *__restrict__ __s, const char *__restrict__ __delim) throw()
# 344
 __attribute((__nonnull__(2))); 
# 349
extern "C" char *__strtok_r(char *__restrict__ __s, const char *__restrict__ __delim, char **__restrict__ __save_ptr) throw()
# 352
 __attribute((__nonnull__(2, 3))); 
# 354
extern "C" char *strtok_r(char *__restrict__ __s, const char *__restrict__ __delim, char **__restrict__ __save_ptr) throw()
# 356
 __attribute((__nonnull__(2, 3))); 
# 362
char *strcasestr(char * __haystack, const char * __needle) throw() __asm__("strcasestr")
# 363
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 364
const char *strcasestr(const char * __haystack, const char * __needle) throw() __asm__("strcasestr")
# 366
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 377 "/usr/include/string.h" 3
extern "C" void *memmem(const void * __haystack, size_t __haystacklen, const void * __needle, size_t __needlelen) throw()
# 379
 __attribute((__pure__)) __attribute((__nonnull__(1, 3))); 
# 383
extern "C" void *__mempcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t __n) throw()
# 385
 __attribute((__nonnull__(1, 2))); 
# 386
extern "C" void *mempcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t __n) throw()
# 388
 __attribute((__nonnull__(1, 2))); 
# 394
extern "C" size_t strlen(const char * __s) throw()
# 395
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 401
extern "C" size_t strnlen(const char * __string, size_t __maxlen) throw()
# 402
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 408
extern "C" char *strerror(int __errnum) throw(); 
# 433 "/usr/include/string.h" 3
extern "C" char *strerror_r(int __errnum, char * __buf, size_t __buflen) throw()
# 434
 __attribute((__nonnull__(2))); 
# 440
extern "C" char *strerror_l(int __errnum, __locale_t __l) throw(); 
# 446
extern "C" void __bzero(void * __s, size_t __n) throw() __attribute((__nonnull__(1))); 
# 450
extern "C" void bcopy(const void * __src, void * __dest, size_t __n) throw()
# 451
 __attribute((__nonnull__(1, 2))); 
# 454
extern "C" void bzero(void * __s, size_t __n) throw() __attribute((__nonnull__(1))); 
# 457
extern "C" int bcmp(const void * __s1, const void * __s2, size_t __n) throw()
# 458
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 464
extern char *index(char * __s, int __c) throw() __asm__("index")
# 465
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 466
extern const char *index(const char * __s, int __c) throw() __asm__("index")
# 467
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 492 "/usr/include/string.h" 3
extern char *rindex(char * __s, int __c) throw() __asm__("rindex")
# 493
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 494
extern const char *rindex(const char * __s, int __c) throw() __asm__("rindex")
# 495
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 518 "/usr/include/string.h" 3
extern "C" int ffs(int __i) throw() __attribute((const)); 
# 523
extern "C" int ffsl(long __l) throw() __attribute((const)); 
# 524
__extension__ extern "C" int ffsll(long long __ll) throw()
# 525
 __attribute((const)); 
# 529
extern "C" int strcasecmp(const char * __s1, const char * __s2) throw()
# 530
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 533
extern "C" int strncasecmp(const char * __s1, const char * __s2, size_t __n) throw()
# 534
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 540
extern "C" int strcasecmp_l(const char * __s1, const char * __s2, __locale_t __loc) throw()
# 542
 __attribute((__pure__)) __attribute((__nonnull__(1, 2, 3))); 
# 544
extern "C" int strncasecmp_l(const char * __s1, const char * __s2, size_t __n, __locale_t __loc) throw()
# 546
 __attribute((__pure__)) __attribute((__nonnull__(1, 2, 4))); 
# 552
extern "C" char *strsep(char **__restrict__ __stringp, const char *__restrict__ __delim) throw()
# 554
 __attribute((__nonnull__(1, 2))); 
# 559
extern "C" char *strsignal(int __sig) throw(); 
# 562
extern "C" char *__stpcpy(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 563
 __attribute((__nonnull__(1, 2))); 
# 564
extern "C" char *stpcpy(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 565
 __attribute((__nonnull__(1, 2))); 
# 569
extern "C" char *__stpncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 571
 __attribute((__nonnull__(1, 2))); 
# 572
extern "C" char *stpncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 574
 __attribute((__nonnull__(1, 2))); 
# 579
extern "C" int strverscmp(const char * __s1, const char * __s2) throw()
# 580
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 583
extern "C" char *strfry(char * __string) throw() __attribute((__nonnull__(1))); 
# 586
extern "C" void *memfrob(void * __s, size_t __n) throw() __attribute((__nonnull__(1))); 
# 594
char *basename(char * __filename) throw() __asm__("basename")
# 595
 __attribute((__nonnull__(1))); 
# 596
const char *basename(const char * __filename) throw() __asm__("basename")
# 597
 __attribute((__nonnull__(1))); 
# 30 "/usr/include/x86_64-linux-gnu/bits/types.h" 3
extern "C" { typedef unsigned char __u_char; }
# 31
extern "C" { typedef unsigned short __u_short; }
# 32
extern "C" { typedef unsigned __u_int; }
# 33
extern "C" { typedef unsigned long __u_long; }
# 36
extern "C" { typedef signed char __int8_t; }
# 37
extern "C" { typedef unsigned char __uint8_t; }
# 38
extern "C" { typedef signed short __int16_t; }
# 39
extern "C" { typedef unsigned short __uint16_t; }
# 40
extern "C" { typedef signed int __int32_t; }
# 41
extern "C" { typedef unsigned __uint32_t; }
# 43
extern "C" { typedef signed long __int64_t; }
# 44
extern "C" { typedef unsigned long __uint64_t; }
# 52
extern "C" { typedef long __quad_t; }
# 53
extern "C" { typedef unsigned long __u_quad_t; }
# 124 "/usr/include/x86_64-linux-gnu/bits/types.h" 3
extern "C" { typedef unsigned long __dev_t; }
# 125
extern "C" { typedef unsigned __uid_t; }
# 126
extern "C" { typedef unsigned __gid_t; }
# 127
extern "C" { typedef unsigned long __ino_t; }
# 128
extern "C" { typedef unsigned long __ino64_t; }
# 129
extern "C" { typedef unsigned __mode_t; }
# 130
extern "C" { typedef unsigned long __nlink_t; }
# 131
extern "C" { typedef long __off_t; }
# 132
extern "C" { typedef long __off64_t; }
# 133
extern "C" { typedef int __pid_t; }
# 134
extern "C" { typedef struct { int __val[2]; } __fsid_t; }
# 135
extern "C" { typedef long __clock_t; }
# 136
extern "C" { typedef unsigned long __rlim_t; }
# 137
extern "C" { typedef unsigned long __rlim64_t; }
# 138
extern "C" { typedef unsigned __id_t; }
# 139
extern "C" { typedef long __time_t; }
# 140
extern "C" { typedef unsigned __useconds_t; }
# 141
extern "C" { typedef long __suseconds_t; }
# 143
extern "C" { typedef int __daddr_t; }
# 144
extern "C" { typedef int __key_t; }
# 147
extern "C" { typedef int __clockid_t; }
# 150
extern "C" { typedef void *__timer_t; }
# 153
extern "C" { typedef long __blksize_t; }
# 158
extern "C" { typedef long __blkcnt_t; }
# 159
extern "C" { typedef long __blkcnt64_t; }
# 162
extern "C" { typedef unsigned long __fsblkcnt_t; }
# 163
extern "C" { typedef unsigned long __fsblkcnt64_t; }
# 166
extern "C" { typedef unsigned long __fsfilcnt_t; }
# 167
extern "C" { typedef unsigned long __fsfilcnt64_t; }
# 170
extern "C" { typedef long __fsword_t; }
# 172
extern "C" { typedef long __ssize_t; }
# 175
extern "C" { typedef long __syscall_slong_t; }
# 177
extern "C" { typedef unsigned long __syscall_ulong_t; }
# 181
extern "C" { typedef __off64_t __loff_t; }
# 182
extern "C" { typedef __quad_t *__qaddr_t; }
# 183
extern "C" { typedef char *__caddr_t; }
# 186
extern "C" { typedef long __intptr_t; }
# 189
extern "C" { typedef unsigned __socklen_t; }
# 30 "/usr/include/x86_64-linux-gnu/bits/time.h" 3
extern "C" { struct timeval { 
# 32
__time_t tv_sec; 
# 33
__suseconds_t tv_usec; 
# 34
}; }
# 25 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3
extern "C" { struct timex { 
# 27
unsigned modes; 
# 28
__syscall_slong_t offset; 
# 29
__syscall_slong_t freq; 
# 30
__syscall_slong_t maxerror; 
# 31
__syscall_slong_t esterror; 
# 32
int status; 
# 33
__syscall_slong_t constant; 
# 34
__syscall_slong_t precision; 
# 35
__syscall_slong_t tolerance; 
# 36
timeval time; 
# 37
__syscall_slong_t tick; 
# 38
__syscall_slong_t ppsfreq; 
# 39
__syscall_slong_t jitter; 
# 40
int shift; 
# 41
__syscall_slong_t stabil; 
# 42
__syscall_slong_t jitcnt; 
# 43
__syscall_slong_t calcnt; 
# 44
__syscall_slong_t errcnt; 
# 45
__syscall_slong_t stbcnt; 
# 47
int tai; 
# 50
int:32; int:32; int:32; int:32; 
# 51
int:32; int:32; int:32; int:32; 
# 52
int:32; int:32; int:32; 
# 53
}; }
# 93 "/usr/include/x86_64-linux-gnu/bits/time.h" 3
extern "C" int clock_adjtime(__clockid_t __clock_id, timex * __utx) throw(); 
# 59 "/usr/include/time.h" 3
extern "C" { typedef __clock_t clock_t; }
# 75 "/usr/include/time.h" 3
extern "C" { typedef __time_t time_t; }
# 91 "/usr/include/time.h" 3
extern "C" { typedef __clockid_t clockid_t; }
# 103 "/usr/include/time.h" 3
extern "C" { typedef __timer_t timer_t; }
# 120 "/usr/include/time.h" 3
extern "C" { struct timespec { 
# 122
__time_t tv_sec; 
# 123
__syscall_slong_t tv_nsec; 
# 124
}; }
# 133
extern "C" { struct tm { 
# 135
int tm_sec; 
# 136
int tm_min; 
# 137
int tm_hour; 
# 138
int tm_mday; 
# 139
int tm_mon; 
# 140
int tm_year; 
# 141
int tm_wday; 
# 142
int tm_yday; 
# 143
int tm_isdst; 
# 146
long tm_gmtoff; 
# 147
const char *tm_zone; 
# 152
}; }
# 161
extern "C" { struct itimerspec { 
# 163
timespec it_interval; 
# 164
timespec it_value; 
# 165
}; }
# 168
struct sigevent; 
# 174
extern "C" { typedef __pid_t pid_t; }
# 189 "/usr/include/time.h" 3
extern "C" clock_t clock() throw(); 
# 192
extern "C" time_t time(time_t * __timer) throw(); 
# 195
extern "C" double difftime(time_t __time1, time_t __time0) throw()
# 196
 __attribute((const)); 
# 199
extern "C" time_t mktime(tm * __tp) throw(); 
# 205
extern "C" size_t strftime(char *__restrict__ __s, size_t __maxsize, const char *__restrict__ __format, const tm *__restrict__ __tp) throw(); 
# 213
extern "C" char *strptime(const char *__restrict__ __s, const char *__restrict__ __fmt, tm * __tp) throw(); 
# 223
extern "C" size_t strftime_l(char *__restrict__ __s, size_t __maxsize, const char *__restrict__ __format, const tm *__restrict__ __tp, __locale_t __loc) throw(); 
# 230
extern "C" char *strptime_l(const char *__restrict__ __s, const char *__restrict__ __fmt, tm * __tp, __locale_t __loc) throw(); 
# 239
extern "C" tm *gmtime(const time_t * __timer) throw(); 
# 243
extern "C" tm *localtime(const time_t * __timer) throw(); 
# 249
extern "C" tm *gmtime_r(const time_t *__restrict__ __timer, tm *__restrict__ __tp) throw(); 
# 254
extern "C" tm *localtime_r(const time_t *__restrict__ __timer, tm *__restrict__ __tp) throw(); 
# 261
extern "C" char *asctime(const tm * __tp) throw(); 
# 264
extern "C" char *ctime(const time_t * __timer) throw(); 
# 272
extern "C" char *asctime_r(const tm *__restrict__ __tp, char *__restrict__ __buf) throw(); 
# 276
extern "C" char *ctime_r(const time_t *__restrict__ __timer, char *__restrict__ __buf) throw(); 
# 282
extern "C" { extern char *__tzname[2]; } 
# 283
extern "C" { extern int __daylight; } 
# 284
extern "C" { extern long __timezone; } 
# 289
extern "C" { extern char *tzname[2]; } 
# 293
extern "C" void tzset() throw(); 
# 297
extern "C" { extern int daylight; } 
# 298
extern "C" { extern long timezone; } 
# 304
extern "C" int stime(const time_t * __when) throw(); 
# 319 "/usr/include/time.h" 3
extern "C" time_t timegm(tm * __tp) throw(); 
# 322
extern "C" time_t timelocal(tm * __tp) throw(); 
# 325
extern "C" int dysize(int __year) throw() __attribute((const)); 
# 334 "/usr/include/time.h" 3
extern "C" int nanosleep(const timespec * __requested_time, timespec * __remaining); 
# 339
extern "C" int clock_getres(clockid_t __clock_id, timespec * __res) throw(); 
# 342
extern "C" int clock_gettime(clockid_t __clock_id, timespec * __tp) throw(); 
# 345
extern "C" int clock_settime(clockid_t __clock_id, const timespec * __tp) throw(); 
# 353
extern "C" int clock_nanosleep(clockid_t __clock_id, int __flags, const timespec * __req, timespec * __rem); 
# 358
extern "C" int clock_getcpuclockid(pid_t __pid, clockid_t * __clock_id) throw(); 
# 363
extern "C" int timer_create(clockid_t __clock_id, sigevent *__restrict__ __evp, timer_t *__restrict__ __timerid) throw(); 
# 368
extern "C" int timer_delete(timer_t __timerid) throw(); 
# 371
extern "C" int timer_settime(timer_t __timerid, int __flags, const itimerspec *__restrict__ __value, itimerspec *__restrict__ __ovalue) throw(); 
# 376
extern "C" int timer_gettime(timer_t __timerid, itimerspec * __value) throw(); 
# 380
extern "C" int timer_getoverrun(timer_t __timerid) throw(); 
# 386
extern "C" int timespec_get(timespec * __ts, int __base) throw()
# 387
 __attribute((__nonnull__(1))); 
# 403 "/usr/include/time.h" 3
extern "C" { extern int getdate_err; } 
# 412 "/usr/include/time.h" 3
extern "C" tm *getdate(const char * __string); 
# 426 "/usr/include/time.h" 3
extern "C" int getdate_r(const char *__restrict__ __string, tm *__restrict__ __resbufp); 
# 71 "/usr/include/common_functions.h" 3
extern "C" clock_t clock() throw(); 
# 72
extern "C" void *memset(void *, int, size_t) throw(); 
# 73
extern "C" void *memcpy(void *, const void *, size_t) throw(); 
# 154 "/usr/include/math_functions.h" 3
extern "C" int abs(int) throw(); 
# 155
extern "C" long labs(long) throw(); 
# 156
extern "C" long long llabs(long long) throw(); 
# 206 "/usr/include/math_functions.h" 3
extern "C" double fabs(double x) throw(); 
# 247 "/usr/include/math_functions.h" 3
extern "C" float fabsf(float x) throw(); 
# 251
extern "C" { extern inline int min(int, int); } 
# 253
extern "C" { extern inline unsigned umin(unsigned, unsigned); } 
# 254
extern "C" { extern inline long long llmin(long long, long long); } 
# 255
extern "C" { extern inline unsigned long long ullmin(unsigned long long, unsigned long long); } 
# 276 "/usr/include/math_functions.h" 3
extern "C" float fminf(float x, float y) throw(); 
# 296 "/usr/include/math_functions.h" 3
extern "C" double fmin(double x, double y) throw(); 
# 303
extern "C" { extern inline int max(int, int); } 
# 305
extern "C" { extern inline unsigned umax(unsigned, unsigned); } 
# 306
extern "C" { extern inline long long llmax(long long, long long); } 
# 307
extern "C" { extern inline unsigned long long ullmax(unsigned long long, unsigned long long); } 
# 328 "/usr/include/math_functions.h" 3
extern "C" float fmaxf(float x, float y) throw(); 
# 348 "/usr/include/math_functions.h" 3
extern "C" double fmax(double, double) throw(); 
# 392 "/usr/include/math_functions.h" 3
extern "C" double sin(double x) throw(); 
# 425 "/usr/include/math_functions.h" 3
extern "C" double cos(double x) throw(); 
# 444 "/usr/include/math_functions.h" 3
extern "C" void sincos(double x, double * sptr, double * cptr) throw(); 
# 460 "/usr/include/math_functions.h" 3
extern "C" void sincosf(float x, float * sptr, float * cptr) throw(); 
# 505 "/usr/include/math_functions.h" 3
extern "C" double tan(double x) throw(); 
# 574 "/usr/include/math_functions.h" 3
extern "C" double sqrt(double x) throw(); 
# 646 "/usr/include/math_functions.h" 3
extern "C" double rsqrt(double x); 
# 716 "/usr/include/math_functions.h" 3
extern "C" float rsqrtf(float x); 
# 772 "/usr/include/math_functions.h" 3
extern "C" double log2(double x) throw(); 
# 797 "/usr/include/math_functions.h" 3
extern "C" double exp2(double x) throw(); 
# 822 "/usr/include/math_functions.h" 3
extern "C" float exp2f(float x) throw(); 
# 849 "/usr/include/math_functions.h" 3
extern "C" double exp10(double x) throw(); 
# 872 "/usr/include/math_functions.h" 3
extern "C" float exp10f(float x) throw(); 
# 918 "/usr/include/math_functions.h" 3
extern "C" double expm1(double x) throw(); 
# 963 "/usr/include/math_functions.h" 3
extern "C" float expm1f(float x) throw(); 
# 1018 "/usr/include/math_functions.h" 3
extern "C" float log2f(float x) throw(); 
# 1072 "/usr/include/math_functions.h" 3
extern "C" double log10(double x) throw(); 
# 1143 "/usr/include/math_functions.h" 3
extern "C" double log(double x) throw(); 
# 1237 "/usr/include/math_functions.h" 3
extern "C" double log1p(double x) throw(); 
# 1334 "/usr/include/math_functions.h" 3
extern "C" float log1pf(float x) throw(); 
# 1409 "/usr/include/math_functions.h" 3
extern "C" double floor(double x) throw(); 
# 1448 "/usr/include/math_functions.h" 3
extern "C" double exp(double x) throw(); 
# 1479 "/usr/include/math_functions.h" 3
extern "C" double cosh(double x) throw(); 
# 1509 "/usr/include/math_functions.h" 3
extern "C" double sinh(double x) throw(); 
# 1539 "/usr/include/math_functions.h" 3
extern "C" double tanh(double x) throw(); 
# 1574 "/usr/include/math_functions.h" 3
extern "C" double acosh(double x) throw(); 
# 1612 "/usr/include/math_functions.h" 3
extern "C" float acoshf(float x) throw(); 
# 1628 "/usr/include/math_functions.h" 3
extern "C" double asinh(double x) throw(); 
# 1644 "/usr/include/math_functions.h" 3
extern "C" float asinhf(float x) throw(); 
# 1698 "/usr/include/math_functions.h" 3
extern "C" double atanh(double x) throw(); 
# 1752 "/usr/include/math_functions.h" 3
extern "C" float atanhf(float x) throw(); 
# 1811 "/usr/include/math_functions.h" 3
extern "C" double ldexp(double x, int exp) throw(); 
# 1867 "/usr/include/math_functions.h" 3
extern "C" float ldexpf(float x, int exp) throw(); 
# 1919 "/usr/include/math_functions.h" 3
extern "C" double logb(double x) throw(); 
# 1974 "/usr/include/math_functions.h" 3
extern "C" float logbf(float x) throw(); 
# 2004 "/usr/include/math_functions.h" 3
extern "C" int ilogb(double x) throw(); 
# 2034 "/usr/include/math_functions.h" 3
extern "C" int ilogbf(float x) throw(); 
# 2110 "/usr/include/math_functions.h" 3
extern "C" double scalbn(double x, int n) throw(); 
# 2186 "/usr/include/math_functions.h" 3
extern "C" float scalbnf(float x, int n) throw(); 
# 2262 "/usr/include/math_functions.h" 3
extern "C" double scalbln(double x, long n) throw(); 
# 2338 "/usr/include/math_functions.h" 3
extern "C" float scalblnf(float x, long n) throw(); 
# 2416 "/usr/include/math_functions.h" 3
extern "C" double frexp(double x, int * nptr) throw(); 
# 2491 "/usr/include/math_functions.h" 3
extern "C" float frexpf(float x, int * nptr) throw(); 
# 2505 "/usr/include/math_functions.h" 3
extern "C" double round(double x) throw(); 
# 2522 "/usr/include/math_functions.h" 3
extern "C" float roundf(float x) throw(); 
# 2540 "/usr/include/math_functions.h" 3
extern "C" long lround(double x) throw(); 
# 2558 "/usr/include/math_functions.h" 3
extern "C" long lroundf(float x) throw(); 
# 2576 "/usr/include/math_functions.h" 3
extern "C" long long llround(double x) throw(); 
# 2594 "/usr/include/math_functions.h" 3
extern "C" long long llroundf(float x) throw(); 
# 2609 "/usr/include/math_functions.h" 3
extern "C" double rint(double x) throw(); 
# 2624 "/usr/include/math_functions.h" 3
extern "C" float rintf(float x) throw(); 
# 2640 "/usr/include/math_functions.h" 3
extern "C" long lrint(double x) throw(); 
# 2656 "/usr/include/math_functions.h" 3
extern "C" long lrintf(float x) throw(); 
# 2672 "/usr/include/math_functions.h" 3
extern "C" long long llrint(double x) throw(); 
# 2688 "/usr/include/math_functions.h" 3
extern "C" long long llrintf(float x) throw(); 
# 2741 "/usr/include/math_functions.h" 3
extern "C" double nearbyint(double x) throw(); 
# 2794 "/usr/include/math_functions.h" 3
extern "C" float nearbyintf(float x) throw(); 
# 2856 "/usr/include/math_functions.h" 3
extern "C" double ceil(double x) throw(); 
# 2868 "/usr/include/math_functions.h" 3
extern "C" double trunc(double x) throw(); 
# 2883 "/usr/include/math_functions.h" 3
extern "C" float truncf(float x) throw(); 
# 2909 "/usr/include/math_functions.h" 3
extern "C" double fdim(double x, double y) throw(); 
# 2935 "/usr/include/math_functions.h" 3
extern "C" float fdimf(float x, float y) throw(); 
# 2971 "/usr/include/math_functions.h" 3
extern "C" double atan2(double y, double x) throw(); 
# 3002 "/usr/include/math_functions.h" 3
extern "C" double atan(double x) throw(); 
# 3025 "/usr/include/math_functions.h" 3
extern "C" double acos(double x) throw(); 
# 3057 "/usr/include/math_functions.h" 3
extern "C" double asin(double x) throw(); 
# 3099 "/usr/include/math_functions.h" 3
extern "C" double hypot(double x, double y) throw(); 
# 3151 "/usr/include/math_functions.h" 3
extern "C" double rhypot(double x, double y) throw(); 
# 3197 "/usr/include/math_functions.h" 3
extern "C" float hypotf(float x, float y) throw(); 
# 3249 "/usr/include/math_functions.h" 3
extern "C" float rhypotf(float x, float y) throw(); 
# 3296 "/usr/include/math_functions.h" 3
extern "C" double norm3d(double a, double b, double c) throw(); 
# 3347 "/usr/include/math_functions.h" 3
extern "C" double rnorm3d(double a, double b, double c) throw(); 
# 3396 "/usr/include/math_functions.h" 3
extern "C" double norm4d(double a, double b, double c, double d) throw(); 
# 3452 "/usr/include/math_functions.h" 3
extern "C" double rnorm4d(double a, double b, double c, double d) throw(); 
# 3497 "/usr/include/math_functions.h" 3
extern "C" double norm(int dim, const double * t) throw(); 
# 3548 "/usr/include/math_functions.h" 3
extern "C" double rnorm(int dim, const double * t) throw(); 
# 3600 "/usr/include/math_functions.h" 3
extern "C" float rnormf(int dim, const float * a) throw(); 
# 3644 "/usr/include/math_functions.h" 3
extern "C" float normf(int dim, const float * a) throw(); 
# 3689 "/usr/include/math_functions.h" 3
extern "C" float norm3df(float a, float b, float c) throw(); 
# 3740 "/usr/include/math_functions.h" 3
extern "C" float rnorm3df(float a, float b, float c) throw(); 
# 3789 "/usr/include/math_functions.h" 3
extern "C" float norm4df(float a, float b, float c, float d) throw(); 
# 3845 "/usr/include/math_functions.h" 3
extern "C" float rnorm4df(float a, float b, float c, float d) throw(); 
# 3929 "/usr/include/math_functions.h" 3
extern "C" double cbrt(double x) throw(); 
# 4015 "/usr/include/math_functions.h" 3
extern "C" float cbrtf(float x) throw(); 
# 4070 "/usr/include/math_functions.h" 3
extern "C" double rcbrt(double x); 
# 4120 "/usr/include/math_functions.h" 3
extern "C" float rcbrtf(float x); 
# 4180 "/usr/include/math_functions.h" 3
extern "C" double sinpi(double x); 
# 4240 "/usr/include/math_functions.h" 3
extern "C" float sinpif(float x); 
# 4292 "/usr/include/math_functions.h" 3
extern "C" double cospi(double x); 
# 4344 "/usr/include/math_functions.h" 3
extern "C" float cospif(float x); 
# 4374 "/usr/include/math_functions.h" 3
extern "C" void sincospi(double x, double * sptr, double * cptr); 
# 4404 "/usr/include/math_functions.h" 3
extern "C" void sincospif(float x, float * sptr, float * cptr); 
# 4716 "/usr/include/math_functions.h" 3
extern "C" double pow(double x, double y) throw(); 
# 4772 "/usr/include/math_functions.h" 3
extern "C" double modf(double x, double * iptr) throw(); 
# 4831 "/usr/include/math_functions.h" 3
extern "C" double fmod(double x, double y) throw(); 
# 4917 "/usr/include/math_functions.h" 3
extern "C" double remainder(double x, double y) throw(); 
# 5007 "/usr/include/math_functions.h" 3
extern "C" float remainderf(float x, float y) throw(); 
# 5061 "/usr/include/math_functions.h" 3
extern "C" double remquo(double x, double y, int * quo) throw(); 
# 5115 "/usr/include/math_functions.h" 3
extern "C" float remquof(float x, float y, int * quo) throw(); 
# 5156 "/usr/include/math_functions.h" 3
extern "C" double j0(double x) throw(); 
# 5198 "/usr/include/math_functions.h" 3
extern "C" float j0f(float x) throw(); 
# 5259 "/usr/include/math_functions.h" 3
extern "C" double j1(double x) throw(); 
# 5320 "/usr/include/math_functions.h" 3
extern "C" float j1f(float x) throw(); 
# 5363 "/usr/include/math_functions.h" 3
extern "C" double jn(int n, double x) throw(); 
# 5406 "/usr/include/math_functions.h" 3
extern "C" float jnf(int n, float x) throw(); 
# 5458 "/usr/include/math_functions.h" 3
extern "C" double y0(double x) throw(); 
# 5510 "/usr/include/math_functions.h" 3
extern "C" float y0f(float x) throw(); 
# 5562 "/usr/include/math_functions.h" 3
extern "C" double y1(double x) throw(); 
# 5614 "/usr/include/math_functions.h" 3
extern "C" float y1f(float x) throw(); 
# 5667 "/usr/include/math_functions.h" 3
extern "C" double yn(int n, double x) throw(); 
# 5720 "/usr/include/math_functions.h" 3
extern "C" float ynf(int n, float x) throw(); 
# 5747 "/usr/include/math_functions.h" 3
extern "C" double cyl_bessel_i0(double x) throw(); 
# 5773 "/usr/include/math_functions.h" 3
extern "C" float cyl_bessel_i0f(float x) throw(); 
# 5800 "/usr/include/math_functions.h" 3
extern "C" double cyl_bessel_i1(double x) throw(); 
# 5826 "/usr/include/math_functions.h" 3
extern "C" float cyl_bessel_i1f(float x) throw(); 
# 5909 "/usr/include/math_functions.h" 3
extern "C" double erf(double x) throw(); 
# 5991 "/usr/include/math_functions.h" 3
extern "C" float erff(float x) throw(); 
# 6055 "/usr/include/math_functions.h" 3
extern "C" double erfinv(double y); 
# 6112 "/usr/include/math_functions.h" 3
extern "C" float erfinvf(float y); 
# 6151 "/usr/include/math_functions.h" 3
extern "C" double erfc(double x) throw(); 
# 6189 "/usr/include/math_functions.h" 3
extern "C" float erfcf(float x) throw(); 
# 6317 "/usr/include/math_functions.h" 3
extern "C" double lgamma(double x) throw(); 
# 6380 "/usr/include/math_functions.h" 3
extern "C" double erfcinv(double y); 
# 6436 "/usr/include/math_functions.h" 3
extern "C" float erfcinvf(float y); 
# 6494 "/usr/include/math_functions.h" 3
extern "C" double normcdfinv(double y); 
# 6552 "/usr/include/math_functions.h" 3
extern "C" float normcdfinvf(float y); 
# 6595 "/usr/include/math_functions.h" 3
extern "C" double normcdf(double y); 
# 6638 "/usr/include/math_functions.h" 3
extern "C" float normcdff(float y); 
# 6713 "/usr/include/math_functions.h" 3
extern "C" double erfcx(double x); 
# 6788 "/usr/include/math_functions.h" 3
extern "C" float erfcxf(float x); 
# 6922 "/usr/include/math_functions.h" 3
extern "C" float lgammaf(float x) throw(); 
# 7031 "/usr/include/math_functions.h" 3
extern "C" double tgamma(double x) throw(); 
# 7140 "/usr/include/math_functions.h" 3
extern "C" float tgammaf(float x) throw(); 
# 7153 "/usr/include/math_functions.h" 3
extern "C" double copysign(double x, double y) throw(); 
# 7166 "/usr/include/math_functions.h" 3
extern "C" float copysignf(float x, float y) throw(); 
# 7203 "/usr/include/math_functions.h" 3
extern "C" double nextafter(double x, double y) throw(); 
# 7240 "/usr/include/math_functions.h" 3
extern "C" float nextafterf(float x, float y) throw(); 
# 7256 "/usr/include/math_functions.h" 3
extern "C" double nan(const char * tagp) throw(); 
# 7272 "/usr/include/math_functions.h" 3
extern "C" float nanf(const char * tagp) throw(); 
# 7279
extern "C" int __isinff(float) throw(); 
# 7280
extern "C" int __isnanf(float) throw(); 
# 7290 "/usr/include/math_functions.h" 3
extern "C" int __finite(double) throw(); 
# 7291
extern "C" int __finitef(float) throw(); 
# 7292
extern "C" int __signbit(double) throw(); 
# 7293
extern "C" int __isnan(double) throw(); 
# 7294
extern "C" int __isinf(double) throw(); 
# 7297
extern "C" int __signbitf(float) throw(); 
# 7456 "/usr/include/math_functions.h" 3
extern "C" double fma(double x, double y, double z) throw(); 
# 7614 "/usr/include/math_functions.h" 3
extern "C" float fmaf(float x, float y, float z) throw(); 
# 7625 "/usr/include/math_functions.h" 3
extern "C" int __signbitl(long double) throw(); 
# 7631
extern "C" int __finitel(long double) throw(); 
# 7632
extern "C" int __isinfl(long double) throw(); 
# 7633
extern "C" int __isnanl(long double) throw(); 
# 7683 "/usr/include/math_functions.h" 3
extern "C" float acosf(float x) throw(); 
# 7723 "/usr/include/math_functions.h" 3
extern "C" float asinf(float x) throw(); 
# 7763 "/usr/include/math_functions.h" 3
extern "C" float atanf(float x) throw(); 
# 7796 "/usr/include/math_functions.h" 3
extern "C" float atan2f(float y, float x) throw(); 
# 7820 "/usr/include/math_functions.h" 3
extern "C" float cosf(float x) throw(); 
# 7862 "/usr/include/math_functions.h" 3
extern "C" float sinf(float x) throw(); 
# 7904 "/usr/include/math_functions.h" 3
extern "C" float tanf(float x) throw(); 
# 7928 "/usr/include/math_functions.h" 3
extern "C" float coshf(float x) throw(); 
# 7969 "/usr/include/math_functions.h" 3
extern "C" float sinhf(float x) throw(); 
# 7999 "/usr/include/math_functions.h" 3
extern "C" float tanhf(float x) throw(); 
# 8050 "/usr/include/math_functions.h" 3
extern "C" float logf(float x) throw(); 
# 8100 "/usr/include/math_functions.h" 3
extern "C" float expf(float x) throw(); 
# 8151 "/usr/include/math_functions.h" 3
extern "C" float log10f(float x) throw(); 
# 8206 "/usr/include/math_functions.h" 3
extern "C" float modff(float x, float * iptr) throw(); 
# 8514 "/usr/include/math_functions.h" 3
extern "C" float powf(float x, float y) throw(); 
# 8583 "/usr/include/math_functions.h" 3
extern "C" float sqrtf(float x) throw(); 
# 8642 "/usr/include/math_functions.h" 3
extern "C" float ceilf(float x) throw(); 
# 8714 "/usr/include/math_functions.h" 3
extern "C" float floorf(float x) throw(); 
# 8773 "/usr/include/math_functions.h" 3
extern "C" float fmodf(float x, float y) throw(); 
# 28 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 3
extern "C" { typedef float float_t; }
# 29
extern "C" { typedef double double_t; }
# 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern "C" double acos(double __x) throw(); extern "C" double __acos(double __x) throw(); 
# 56
extern "C" double asin(double __x) throw(); extern "C" double __asin(double __x) throw(); 
# 58
extern "C" double atan(double __x) throw(); extern "C" double __atan(double __x) throw(); 
# 60
extern "C" double atan2(double __y, double __x) throw(); extern "C" double __atan2(double __y, double __x) throw(); 
# 63
extern "C" double cos(double __x) throw(); extern "C" double __cos(double __x) throw(); 
# 65
extern "C" double sin(double __x) throw(); extern "C" double __sin(double __x) throw(); 
# 67
extern "C" double tan(double __x) throw(); extern "C" double __tan(double __x) throw(); 
# 72
extern "C" double cosh(double __x) throw(); extern "C" double __cosh(double __x) throw(); 
# 74
extern "C" double sinh(double __x) throw(); extern "C" double __sinh(double __x) throw(); 
# 76
extern "C" double tanh(double __x) throw(); extern "C" double __tanh(double __x) throw(); 
# 81
extern "C" void sincos(double __x, double * __sinx, double * __cosx) throw(); extern "C" void __sincos(double __x, double * __sinx, double * __cosx) throw(); 
# 88
extern "C" double acosh(double __x) throw(); extern "C" double __acosh(double __x) throw(); 
# 90
extern "C" double asinh(double __x) throw(); extern "C" double __asinh(double __x) throw(); 
# 92
extern "C" double atanh(double __x) throw(); extern "C" double __atanh(double __x) throw(); 
# 100
extern "C" double exp(double __x) throw(); extern "C" double __exp(double __x) throw(); 
# 103
extern "C" double frexp(double __x, int * __exponent) throw(); extern "C" double __frexp(double __x, int * __exponent) throw(); 
# 106
extern "C" double ldexp(double __x, int __exponent) throw(); extern "C" double __ldexp(double __x, int __exponent) throw(); 
# 109
extern "C" double log(double __x) throw(); extern "C" double __log(double __x) throw(); 
# 112
extern "C" double log10(double __x) throw(); extern "C" double __log10(double __x) throw(); 
# 115
extern "C" double modf(double __x, double * __iptr) throw(); extern "C" double __modf(double __x, double * __iptr) throw() __attribute((__nonnull__(2))); 
# 120
extern "C" double exp10(double __x) throw(); extern "C" double __exp10(double __x) throw(); 
# 122
extern "C" double pow10(double __x) throw(); extern "C" double __pow10(double __x) throw(); 
# 128
extern "C" double expm1(double __x) throw(); extern "C" double __expm1(double __x) throw(); 
# 131
extern "C" double log1p(double __x) throw(); extern "C" double __log1p(double __x) throw(); 
# 134
extern "C" double logb(double __x) throw(); extern "C" double __logb(double __x) throw(); 
# 141
extern "C" double exp2(double __x) throw(); extern "C" double __exp2(double __x) throw(); 
# 144
extern "C" double log2(double __x) throw(); extern "C" double __log2(double __x) throw(); 
# 153
extern "C" double pow(double __x, double __y) throw(); extern "C" double __pow(double __x, double __y) throw(); 
# 156
extern "C" double sqrt(double __x) throw(); extern "C" double __sqrt(double __x) throw(); 
# 162
extern "C" double hypot(double __x, double __y) throw(); extern "C" double __hypot(double __x, double __y) throw(); 
# 169
extern "C" double cbrt(double __x) throw(); extern "C" double __cbrt(double __x) throw(); 
# 178
extern "C" double ceil(double __x) throw() __attribute((const)); extern "C" double __ceil(double __x) throw() __attribute((const)); 
# 181
extern "C" double fabs(double __x) throw() __attribute((const)); extern "C" double __fabs(double __x) throw() __attribute((const)); 
# 184
extern "C" double floor(double __x) throw() __attribute((const)); extern "C" double __floor(double __x) throw() __attribute((const)); 
# 187
extern "C" double fmod(double __x, double __y) throw(); extern "C" double __fmod(double __x, double __y) throw(); 
# 192
extern "C" int __isinf(double __value) throw() __attribute((const)); 
# 195
extern "C" int __finite(double __value) throw() __attribute((const)); 
# 204
extern "C" { extern inline int isinf(double __value) throw() __attribute((const)); } 
# 208
extern "C" int finite(double __value) throw() __attribute((const)); 
# 211
extern "C" double drem(double __x, double __y) throw(); extern "C" double __drem(double __x, double __y) throw(); 
# 215
extern "C" double significand(double __x) throw(); extern "C" double __significand(double __x) throw(); 
# 221
extern "C" double copysign(double __x, double __y) throw() __attribute((const)); extern "C" double __copysign(double __x, double __y) throw() __attribute((const)); 
# 228
extern "C" double nan(const char * __tagb) throw() __attribute((const)); extern "C" double __nan(const char * __tagb) throw() __attribute((const)); 
# 234
extern "C" int __isnan(double __value) throw() __attribute((const)); 
# 241
extern "C" { extern inline int isnan(double __value) throw() __attribute((const)); } 
# 247
extern "C" double j0(double) throw(); extern "C" double __j0(double) throw(); 
# 248
extern "C" double j1(double) throw(); extern "C" double __j1(double) throw(); 
# 249
extern "C" double jn(int, double) throw(); extern "C" double __jn(int, double) throw(); 
# 250
extern "C" double y0(double) throw(); extern "C" double __y0(double) throw(); 
# 251
extern "C" double y1(double) throw(); extern "C" double __y1(double) throw(); 
# 252
extern "C" double yn(int, double) throw(); extern "C" double __yn(int, double) throw(); 
# 259
extern "C" double erf(double) throw(); extern "C" double __erf(double) throw(); 
# 260
extern "C" double erfc(double) throw(); extern "C" double __erfc(double) throw(); 
# 261
extern "C" double lgamma(double) throw(); extern "C" double __lgamma(double) throw(); 
# 268
extern "C" double tgamma(double) throw(); extern "C" double __tgamma(double) throw(); 
# 274
extern "C" double gamma(double) throw(); extern "C" double __gamma(double) throw(); 
# 281
extern "C" double lgamma_r(double, int * __signgamp) throw(); extern "C" double __lgamma_r(double, int * __signgamp) throw(); 
# 289
extern "C" double rint(double __x) throw(); extern "C" double __rint(double __x) throw(); 
# 292
extern "C" double nextafter(double __x, double __y) throw() __attribute((const)); extern "C" double __nextafter(double __x, double __y) throw() __attribute((const)); 
# 294
extern "C" double nexttoward(double __x, long double __y) throw() __attribute((const)); extern "C" double __nexttoward(double __x, long double __y) throw() __attribute((const)); 
# 298
extern "C" double remainder(double __x, double __y) throw(); extern "C" double __remainder(double __x, double __y) throw(); 
# 302
extern "C" double scalbn(double __x, int __n) throw(); extern "C" double __scalbn(double __x, int __n) throw(); 
# 306
extern "C" int ilogb(double __x) throw(); extern "C" int __ilogb(double __x) throw(); 
# 311
extern "C" double scalbln(double __x, long __n) throw(); extern "C" double __scalbln(double __x, long __n) throw(); 
# 315
extern "C" double nearbyint(double __x) throw(); extern "C" double __nearbyint(double __x) throw(); 
# 319
extern "C" double round(double __x) throw() __attribute((const)); extern "C" double __round(double __x) throw() __attribute((const)); 
# 323
extern "C" double trunc(double __x) throw() __attribute((const)); extern "C" double __trunc(double __x) throw() __attribute((const)); 
# 328
extern "C" double remquo(double __x, double __y, int * __quo) throw(); extern "C" double __remquo(double __x, double __y, int * __quo) throw(); 
# 335
extern "C" long lrint(double __x) throw(); extern "C" long __lrint(double __x) throw(); 
# 337
__extension__ extern "C" long long llrint(double __x) throw(); extern "C" long long __llrint(double __x) throw(); 
# 341
extern "C" long lround(double __x) throw(); extern "C" long __lround(double __x) throw(); 
# 343
__extension__ extern "C" long long llround(double __x) throw(); extern "C" long long __llround(double __x) throw(); 
# 347
extern "C" double fdim(double __x, double __y) throw(); extern "C" double __fdim(double __x, double __y) throw(); 
# 350
extern "C" double fmax(double __x, double __y) throw() __attribute((const)); extern "C" double __fmax(double __x, double __y) throw() __attribute((const)); 
# 353
extern "C" double fmin(double __x, double __y) throw() __attribute((const)); extern "C" double __fmin(double __x, double __y) throw() __attribute((const)); 
# 357
extern "C" int __fpclassify(double __value) throw()
# 358
 __attribute((const)); 
# 361
extern "C" int __signbit(double __value) throw()
# 362
 __attribute((const)); 
# 366
extern "C" double fma(double __x, double __y, double __z) throw(); extern "C" double __fma(double __x, double __y, double __z) throw(); 
# 375
extern "C" int __issignaling(double __value) throw()
# 376
 __attribute((const)); 
# 383
extern "C" double scalb(double __x, double __n) throw(); extern "C" double __scalb(double __x, double __n) throw(); 
# 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern "C" float acosf(float __x) throw(); extern "C" float __acosf(float __x) throw(); 
# 56
extern "C" float asinf(float __x) throw(); extern "C" float __asinf(float __x) throw(); 
# 58
extern "C" float atanf(float __x) throw(); extern "C" float __atanf(float __x) throw(); 
# 60
extern "C" float atan2f(float __y, float __x) throw(); extern "C" float __atan2f(float __y, float __x) throw(); 
# 63
extern "C" float cosf(float __x) throw(); 
# 65
extern "C" float sinf(float __x) throw(); 
# 67
extern "C" float tanf(float __x) throw(); 
# 72
extern "C" float coshf(float __x) throw(); extern "C" float __coshf(float __x) throw(); 
# 74
extern "C" float sinhf(float __x) throw(); extern "C" float __sinhf(float __x) throw(); 
# 76
extern "C" float tanhf(float __x) throw(); extern "C" float __tanhf(float __x) throw(); 
# 81
extern "C" void sincosf(float __x, float * __sinx, float * __cosx) throw(); 
# 88
extern "C" float acoshf(float __x) throw(); extern "C" float __acoshf(float __x) throw(); 
# 90
extern "C" float asinhf(float __x) throw(); extern "C" float __asinhf(float __x) throw(); 
# 92
extern "C" float atanhf(float __x) throw(); extern "C" float __atanhf(float __x) throw(); 
# 100
extern "C" float expf(float __x) throw(); 
# 103
extern "C" float frexpf(float __x, int * __exponent) throw(); extern "C" float __frexpf(float __x, int * __exponent) throw(); 
# 106
extern "C" float ldexpf(float __x, int __exponent) throw(); extern "C" float __ldexpf(float __x, int __exponent) throw(); 
# 109
extern "C" float logf(float __x) throw(); 
# 112
extern "C" float log10f(float __x) throw(); 
# 115
extern "C" float modff(float __x, float * __iptr) throw(); extern "C" float __modff(float __x, float * __iptr) throw() __attribute((__nonnull__(2))); 
# 120
extern "C" float exp10f(float __x) throw(); 
# 122
extern "C" float pow10f(float __x) throw(); extern "C" float __pow10f(float __x) throw(); 
# 128
extern "C" float expm1f(float __x) throw(); extern "C" float __expm1f(float __x) throw(); 
# 131
extern "C" float log1pf(float __x) throw(); extern "C" float __log1pf(float __x) throw(); 
# 134
extern "C" float logbf(float __x) throw(); extern "C" float __logbf(float __x) throw(); 
# 141
extern "C" float exp2f(float __x) throw(); extern "C" float __exp2f(float __x) throw(); 
# 144
extern "C" float log2f(float __x) throw(); 
# 153
extern "C" float powf(float __x, float __y) throw(); 
# 156
extern "C" float sqrtf(float __x) throw(); extern "C" float __sqrtf(float __x) throw(); 
# 162
extern "C" float hypotf(float __x, float __y) throw(); extern "C" float __hypotf(float __x, float __y) throw(); 
# 169
extern "C" float cbrtf(float __x) throw(); extern "C" float __cbrtf(float __x) throw(); 
# 178
extern "C" float ceilf(float __x) throw() __attribute((const)); extern "C" float __ceilf(float __x) throw() __attribute((const)); 
# 181
extern "C" float fabsf(float __x) throw() __attribute((const)); extern "C" float __fabsf(float __x) throw() __attribute((const)); 
# 184
extern "C" float floorf(float __x) throw() __attribute((const)); extern "C" float __floorf(float __x) throw() __attribute((const)); 
# 187
extern "C" float fmodf(float __x, float __y) throw(); extern "C" float __fmodf(float __x, float __y) throw(); 
# 192
extern "C" int __isinff(float __value) throw() __attribute((const)); 
# 195
extern "C" int __finitef(float __value) throw() __attribute((const)); 
# 204
extern "C" int isinff(float __value) throw() __attribute((const)); 
# 208
extern "C" int finitef(float __value) throw() __attribute((const)); 
# 211
extern "C" float dremf(float __x, float __y) throw(); extern "C" float __dremf(float __x, float __y) throw(); 
# 215
extern "C" float significandf(float __x) throw(); extern "C" float __significandf(float __x) throw(); 
# 221
extern "C" float copysignf(float __x, float __y) throw() __attribute((const)); extern "C" float __copysignf(float __x, float __y) throw() __attribute((const)); 
# 228
extern "C" float nanf(const char * __tagb) throw() __attribute((const)); extern "C" float __nanf(const char * __tagb) throw() __attribute((const)); 
# 234
extern "C" int __isnanf(float __value) throw() __attribute((const)); 
# 241
extern "C" int isnanf(float __value) throw() __attribute((const)); 
# 247
extern "C" float j0f(float) throw(); extern "C" float __j0f(float) throw(); 
# 248
extern "C" float j1f(float) throw(); extern "C" float __j1f(float) throw(); 
# 249
extern "C" float jnf(int, float) throw(); extern "C" float __jnf(int, float) throw(); 
# 250
extern "C" float y0f(float) throw(); extern "C" float __y0f(float) throw(); 
# 251
extern "C" float y1f(float) throw(); extern "C" float __y1f(float) throw(); 
# 252
extern "C" float ynf(int, float) throw(); extern "C" float __ynf(int, float) throw(); 
# 259
extern "C" float erff(float) throw(); extern "C" float __erff(float) throw(); 
# 260
extern "C" float erfcf(float) throw(); extern "C" float __erfcf(float) throw(); 
# 261
extern "C" float lgammaf(float) throw(); extern "C" float __lgammaf(float) throw(); 
# 268
extern "C" float tgammaf(float) throw(); extern "C" float __tgammaf(float) throw(); 
# 274
extern "C" float gammaf(float) throw(); extern "C" float __gammaf(float) throw(); 
# 281
extern "C" float lgammaf_r(float, int * __signgamp) throw(); extern "C" float __lgammaf_r(float, int * __signgamp) throw(); 
# 289
extern "C" float rintf(float __x) throw(); extern "C" float __rintf(float __x) throw(); 
# 292
extern "C" float nextafterf(float __x, float __y) throw() __attribute((const)); extern "C" float __nextafterf(float __x, float __y) throw() __attribute((const)); 
# 294
extern "C" float nexttowardf(float __x, long double __y) throw() __attribute((const)); extern "C" float __nexttowardf(float __x, long double __y) throw() __attribute((const)); 
# 298
extern "C" float remainderf(float __x, float __y) throw(); extern "C" float __remainderf(float __x, float __y) throw(); 
# 302
extern "C" float scalbnf(float __x, int __n) throw(); extern "C" float __scalbnf(float __x, int __n) throw(); 
# 306
extern "C" int ilogbf(float __x) throw(); extern "C" int __ilogbf(float __x) throw(); 
# 311
extern "C" float scalblnf(float __x, long __n) throw(); extern "C" float __scalblnf(float __x, long __n) throw(); 
# 315
extern "C" float nearbyintf(float __x) throw(); extern "C" float __nearbyintf(float __x) throw(); 
# 319
extern "C" float roundf(float __x) throw() __attribute((const)); extern "C" float __roundf(float __x) throw() __attribute((const)); 
# 323
extern "C" float truncf(float __x) throw() __attribute((const)); extern "C" float __truncf(float __x) throw() __attribute((const)); 
# 328
extern "C" float remquof(float __x, float __y, int * __quo) throw(); extern "C" float __remquof(float __x, float __y, int * __quo) throw(); 
# 335
extern "C" long lrintf(float __x) throw(); extern "C" long __lrintf(float __x) throw(); 
# 337
__extension__ extern "C" long long llrintf(float __x) throw(); extern "C" long long __llrintf(float __x) throw(); 
# 341
extern "C" long lroundf(float __x) throw(); extern "C" long __lroundf(float __x) throw(); 
# 343
__extension__ extern "C" long long llroundf(float __x) throw(); extern "C" long long __llroundf(float __x) throw(); 
# 347
extern "C" float fdimf(float __x, float __y) throw(); extern "C" float __fdimf(float __x, float __y) throw(); 
# 350
extern "C" float fmaxf(float __x, float __y) throw() __attribute((const)); extern "C" float __fmaxf(float __x, float __y) throw() __attribute((const)); 
# 353
extern "C" float fminf(float __x, float __y) throw() __attribute((const)); extern "C" float __fminf(float __x, float __y) throw() __attribute((const)); 
# 357
extern "C" int __fpclassifyf(float __value) throw()
# 358
 __attribute((const)); 
# 361
extern "C" int __signbitf(float __value) throw()
# 362
 __attribute((const)); 
# 366
extern "C" float fmaf(float __x, float __y, float __z) throw(); extern "C" float __fmaf(float __x, float __y, float __z) throw(); 
# 375
extern "C" int __issignalingf(float __value) throw()
# 376
 __attribute((const)); 
# 383
extern "C" float scalbf(float __x, float __n) throw(); extern "C" float __scalbf(float __x, float __n) throw(); 
# 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern "C" long double acosl(long double __x) throw(); extern "C" long double __acosl(long double __x) throw(); 
# 56
extern "C" long double asinl(long double __x) throw(); extern "C" long double __asinl(long double __x) throw(); 
# 58
extern "C" long double atanl(long double __x) throw(); extern "C" long double __atanl(long double __x) throw(); 
# 60
extern "C" long double atan2l(long double __y, long double __x) throw(); extern "C" long double __atan2l(long double __y, long double __x) throw(); 
# 63
extern "C" long double cosl(long double __x) throw(); extern "C" long double __cosl(long double __x) throw(); 
# 65
extern "C" long double sinl(long double __x) throw(); extern "C" long double __sinl(long double __x) throw(); 
# 67
extern "C" long double tanl(long double __x) throw(); extern "C" long double __tanl(long double __x) throw(); 
# 72
extern "C" long double coshl(long double __x) throw(); extern "C" long double __coshl(long double __x) throw(); 
# 74
extern "C" long double sinhl(long double __x) throw(); extern "C" long double __sinhl(long double __x) throw(); 
# 76
extern "C" long double tanhl(long double __x) throw(); extern "C" long double __tanhl(long double __x) throw(); 
# 81
extern "C" void sincosl(long double __x, long double * __sinx, long double * __cosx) throw(); extern "C" void __sincosl(long double __x, long double * __sinx, long double * __cosx) throw(); 
# 88
extern "C" long double acoshl(long double __x) throw(); extern "C" long double __acoshl(long double __x) throw(); 
# 90
extern "C" long double asinhl(long double __x) throw(); extern "C" long double __asinhl(long double __x) throw(); 
# 92
extern "C" long double atanhl(long double __x) throw(); extern "C" long double __atanhl(long double __x) throw(); 
# 100
extern "C" long double expl(long double __x) throw(); extern "C" long double __expl(long double __x) throw(); 
# 103
extern "C" long double frexpl(long double __x, int * __exponent) throw(); extern "C" long double __frexpl(long double __x, int * __exponent) throw(); 
# 106
extern "C" long double ldexpl(long double __x, int __exponent) throw(); extern "C" long double __ldexpl(long double __x, int __exponent) throw(); 
# 109
extern "C" long double logl(long double __x) throw(); extern "C" long double __logl(long double __x) throw(); 
# 112
extern "C" long double log10l(long double __x) throw(); extern "C" long double __log10l(long double __x) throw(); 
# 115
extern "C" long double modfl(long double __x, long double * __iptr) throw(); extern "C" long double __modfl(long double __x, long double * __iptr) throw() __attribute((__nonnull__(2))); 
# 120
extern "C" long double exp10l(long double __x) throw(); extern "C" long double __exp10l(long double __x) throw(); 
# 122
extern "C" long double pow10l(long double __x) throw(); extern "C" long double __pow10l(long double __x) throw(); 
# 128
extern "C" long double expm1l(long double __x) throw(); extern "C" long double __expm1l(long double __x) throw(); 
# 131
extern "C" long double log1pl(long double __x) throw(); extern "C" long double __log1pl(long double __x) throw(); 
# 134
extern "C" long double logbl(long double __x) throw(); extern "C" long double __logbl(long double __x) throw(); 
# 141
extern "C" long double exp2l(long double __x) throw(); extern "C" long double __exp2l(long double __x) throw(); 
# 144
extern "C" long double log2l(long double __x) throw(); extern "C" long double __log2l(long double __x) throw(); 
# 153
extern "C" long double powl(long double __x, long double __y) throw(); extern "C" long double __powl(long double __x, long double __y) throw(); 
# 156
extern "C" long double sqrtl(long double __x) throw(); extern "C" long double __sqrtl(long double __x) throw(); 
# 162
extern "C" long double hypotl(long double __x, long double __y) throw(); extern "C" long double __hypotl(long double __x, long double __y) throw(); 
# 169
extern "C" long double cbrtl(long double __x) throw(); extern "C" long double __cbrtl(long double __x) throw(); 
# 178
extern "C" long double ceill(long double __x) throw() __attribute((const)); extern "C" long double __ceill(long double __x) throw() __attribute((const)); 
# 181
extern "C" long double fabsl(long double __x) throw() __attribute((const)); extern "C" long double __fabsl(long double __x) throw() __attribute((const)); 
# 184
extern "C" long double floorl(long double __x) throw() __attribute((const)); extern "C" long double __floorl(long double __x) throw() __attribute((const)); 
# 187
extern "C" long double fmodl(long double __x, long double __y) throw(); extern "C" long double __fmodl(long double __x, long double __y) throw(); 
# 192
extern "C" int __isinfl(long double __value) throw() __attribute((const)); 
# 195
extern "C" int __finitel(long double __value) throw() __attribute((const)); 
# 204
extern "C" int isinfl(long double __value) throw() __attribute((const)); 
# 208
extern "C" int finitel(long double __value) throw() __attribute((const)); 
# 211
extern "C" long double dreml(long double __x, long double __y) throw(); extern "C" long double __dreml(long double __x, long double __y) throw(); 
# 215
extern "C" long double significandl(long double __x) throw(); extern "C" long double __significandl(long double __x) throw(); 
# 221
extern "C" long double copysignl(long double __x, long double __y) throw() __attribute((const)); extern "C" long double __copysignl(long double __x, long double __y) throw() __attribute((const)); 
# 228
extern "C" long double nanl(const char * __tagb) throw() __attribute((const)); extern "C" long double __nanl(const char * __tagb) throw() __attribute((const)); 
# 234
extern "C" int __isnanl(long double __value) throw() __attribute((const)); 
# 241
extern "C" int isnanl(long double __value) throw() __attribute((const)); 
# 247
extern "C" long double j0l(long double) throw(); extern "C" long double __j0l(long double) throw(); 
# 248
extern "C" long double j1l(long double) throw(); extern "C" long double __j1l(long double) throw(); 
# 249
extern "C" long double jnl(int, long double) throw(); extern "C" long double __jnl(int, long double) throw(); 
# 250
extern "C" long double y0l(long double) throw(); extern "C" long double __y0l(long double) throw(); 
# 251
extern "C" long double y1l(long double) throw(); extern "C" long double __y1l(long double) throw(); 
# 252
extern "C" long double ynl(int, long double) throw(); extern "C" long double __ynl(int, long double) throw(); 
# 259
extern "C" long double erfl(long double) throw(); extern "C" long double __erfl(long double) throw(); 
# 260
extern "C" long double erfcl(long double) throw(); extern "C" long double __erfcl(long double) throw(); 
# 261
extern "C" long double lgammal(long double) throw(); extern "C" long double __lgammal(long double) throw(); 
# 268
extern "C" long double tgammal(long double) throw(); extern "C" long double __tgammal(long double) throw(); 
# 274
extern "C" long double gammal(long double) throw(); extern "C" long double __gammal(long double) throw(); 
# 281
extern "C" long double lgammal_r(long double, int * __signgamp) throw(); extern "C" long double __lgammal_r(long double, int * __signgamp) throw(); 
# 289
extern "C" long double rintl(long double __x) throw(); extern "C" long double __rintl(long double __x) throw(); 
# 292
extern "C" long double nextafterl(long double __x, long double __y) throw() __attribute((const)); extern "C" long double __nextafterl(long double __x, long double __y) throw() __attribute((const)); 
# 294
extern "C" long double nexttowardl(long double __x, long double __y) throw() __attribute((const)); extern "C" long double __nexttowardl(long double __x, long double __y) throw() __attribute((const)); 
# 298
extern "C" long double remainderl(long double __x, long double __y) throw(); extern "C" long double __remainderl(long double __x, long double __y) throw(); 
# 302
extern "C" long double scalbnl(long double __x, int __n) throw(); extern "C" long double __scalbnl(long double __x, int __n) throw(); 
# 306
extern "C" int ilogbl(long double __x) throw(); extern "C" int __ilogbl(long double __x) throw(); 
# 311
extern "C" long double scalblnl(long double __x, long __n) throw(); extern "C" long double __scalblnl(long double __x, long __n) throw(); 
# 315
extern "C" long double nearbyintl(long double __x) throw(); extern "C" long double __nearbyintl(long double __x) throw(); 
# 319
extern "C" long double roundl(long double __x) throw() __attribute((const)); extern "C" long double __roundl(long double __x) throw() __attribute((const)); 
# 323
extern "C" long double truncl(long double __x) throw() __attribute((const)); extern "C" long double __truncl(long double __x) throw() __attribute((const)); 
# 328
extern "C" long double remquol(long double __x, long double __y, int * __quo) throw(); extern "C" long double __remquol(long double __x, long double __y, int * __quo) throw(); 
# 335
extern "C" long lrintl(long double __x) throw(); extern "C" long __lrintl(long double __x) throw(); 
# 337
__extension__ extern "C" long long llrintl(long double __x) throw(); extern "C" long long __llrintl(long double __x) throw(); 
# 341
extern "C" long lroundl(long double __x) throw(); extern "C" long __lroundl(long double __x) throw(); 
# 343
__extension__ extern "C" long long llroundl(long double __x) throw(); extern "C" long long __llroundl(long double __x) throw(); 
# 347
extern "C" long double fdiml(long double __x, long double __y) throw(); extern "C" long double __fdiml(long double __x, long double __y) throw(); 
# 350
extern "C" long double fmaxl(long double __x, long double __y) throw() __attribute((const)); extern "C" long double __fmaxl(long double __x, long double __y) throw() __attribute((const)); 
# 353
extern "C" long double fminl(long double __x, long double __y) throw() __attribute((const)); extern "C" long double __fminl(long double __x, long double __y) throw() __attribute((const)); 
# 357
extern "C" int __fpclassifyl(long double __value) throw()
# 358
 __attribute((const)); 
# 361
extern "C" int __signbitl(long double __value) throw()
# 362
 __attribute((const)); 
# 366
extern "C" long double fmal(long double __x, long double __y, long double __z) throw(); extern "C" long double __fmal(long double __x, long double __y, long double __z) throw(); 
# 375
extern "C" int __issignalingl(long double __value) throw()
# 376
 __attribute((const)); 
# 383
extern "C" long double scalbl(long double __x, long double __n) throw(); extern "C" long double __scalbl(long double __x, long double __n) throw(); 
# 168 "/usr/include/math.h" 3
extern "C" { extern int signgam; } 
# 210 "/usr/include/math.h" 3
enum { 
# 211
FP_NAN, 
# 214
FP_INFINITE, 
# 217
FP_ZERO, 
# 220
FP_SUBNORMAL, 
# 223
FP_NORMAL
# 226
}; 
# 354 "/usr/include/math.h" 3
extern "C" { typedef 
# 348
enum { 
# 349
_IEEE_ = (-1), 
# 350
_SVID_ = 0, 
# 351
_XOPEN_, 
# 352
_POSIX_, 
# 353
_ISOC_
# 354
} _LIB_VERSION_TYPE; }
# 359
extern "C" { extern _LIB_VERSION_TYPE _LIB_VERSION; } 
# 370 "/usr/include/math.h" 3
extern "C" { struct __exception { 
# 375
int type; 
# 376
char *name; 
# 377
double arg1; 
# 378
double arg2; 
# 379
double retval; 
# 380
}; }
# 383
extern "C" int matherr(__exception * __exc) throw(); 
# 55 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3
extern "C" { typedef 
# 51
enum { 
# 52
P_ALL, 
# 53
P_PID, 
# 54
P_PGID
# 55
} idtype_t; }
# 45 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3
extern "C" { static inline unsigned __bswap_32(unsigned __bsx) 
# 46
{ 
# 47
return __builtin_bswap32(__bsx); 
# 48
} } 
# 109 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3
extern "C" { static inline __uint64_t __bswap_64(__uint64_t __bsx) 
# 110
{ 
# 111
return __builtin_bswap64(__bsx); 
# 112
} } 
# 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3
extern "C" { union wait { 
# 68
int w_status; 
# 70
struct { 
# 72
unsigned __w_termsig:7; 
# 73
unsigned __w_coredump:1; 
# 74
unsigned __w_retcode:8; 
# 75
unsigned:16; 
# 83
} __wait_terminated; 
# 85
struct { 
# 87
unsigned __w_stopval:8; 
# 88
unsigned __w_stopsig:8; 
# 89
unsigned:16; 
# 96
} __wait_stopped; 
# 97
}; }
# 101 "/usr/include/stdlib.h" 3
extern "C" { typedef 
# 98
struct { 
# 99
int quot; 
# 100
int rem; 
# 101
} div_t; }
# 109
extern "C" { typedef 
# 106
struct { 
# 107
long quot; 
# 108
long rem; 
# 109
} ldiv_t; }
# 121
__extension__ extern "C" { typedef 
# 118
struct { 
# 119
long long quot; 
# 120
long long rem; 
# 121
} lldiv_t; }
# 139 "/usr/include/stdlib.h" 3
extern "C" size_t __ctype_get_mb_cur_max() throw(); 
# 144
extern "C" double atof(const char * __nptr) throw()
# 145
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 147
extern "C" int atoi(const char * __nptr) throw()
# 148
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 150
extern "C" long atol(const char * __nptr) throw()
# 151
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 157
__extension__ extern "C" long long atoll(const char * __nptr) throw()
# 158
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 164
extern "C" double strtod(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 166
 __attribute((__nonnull__(1))); 
# 172
extern "C" float strtof(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 173
 __attribute((__nonnull__(1))); 
# 175
extern "C" long double strtold(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 177
 __attribute((__nonnull__(1))); 
# 183
extern "C" long strtol(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 185
 __attribute((__nonnull__(1))); 
# 187
extern "C" unsigned long strtoul(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 189
 __attribute((__nonnull__(1))); 
# 195
__extension__ extern "C" long long strtoq(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 197
 __attribute((__nonnull__(1))); 
# 200
__extension__ extern "C" unsigned long long strtouq(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 202
 __attribute((__nonnull__(1))); 
# 209
__extension__ extern "C" long long strtoll(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 211
 __attribute((__nonnull__(1))); 
# 214
__extension__ extern "C" unsigned long long strtoull(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 216
 __attribute((__nonnull__(1))); 
# 239 "/usr/include/stdlib.h" 3
extern "C" long strtol_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, __locale_t __loc) throw()
# 241
 __attribute((__nonnull__(1, 4))); 
# 243
extern "C" unsigned long strtoul_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, __locale_t __loc) throw()
# 246
 __attribute((__nonnull__(1, 4))); 
# 249
__extension__ extern "C" long long strtoll_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, __locale_t __loc) throw()
# 252
 __attribute((__nonnull__(1, 4))); 
# 255
__extension__ extern "C" unsigned long long strtoull_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, __locale_t __loc) throw()
# 258
 __attribute((__nonnull__(1, 4))); 
# 260
extern "C" double strtod_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, __locale_t __loc) throw()
# 262
 __attribute((__nonnull__(1, 3))); 
# 264
extern "C" float strtof_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, __locale_t __loc) throw()
# 266
 __attribute((__nonnull__(1, 3))); 
# 268
extern "C" long double strtold_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, __locale_t __loc) throw()
# 271
 __attribute((__nonnull__(1, 3))); 
# 305 "/usr/include/stdlib.h" 3
extern "C" char *l64a(long __n) throw(); 
# 308
extern "C" long a64l(const char * __s) throw()
# 309
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 33 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
extern "C" { typedef __u_char u_char; }
# 34
extern "C" { typedef __u_short u_short; }
# 35
extern "C" { typedef __u_int u_int; }
# 36
extern "C" { typedef __u_long u_long; }
# 37
extern "C" { typedef __quad_t quad_t; }
# 38
extern "C" { typedef __u_quad_t u_quad_t; }
# 39
extern "C" { typedef __fsid_t fsid_t; }
# 44
extern "C" { typedef __loff_t loff_t; }
# 48
extern "C" { typedef __ino_t ino_t; }
# 55
extern "C" { typedef __ino64_t ino64_t; }
# 60
extern "C" { typedef __dev_t dev_t; }
# 65
extern "C" { typedef __gid_t gid_t; }
# 70
extern "C" { typedef __mode_t mode_t; }
# 75
extern "C" { typedef __nlink_t nlink_t; }
# 80
extern "C" { typedef __uid_t uid_t; }
# 86
extern "C" { typedef __off_t off_t; }
# 93
extern "C" { typedef __off64_t off64_t; }
# 104 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
extern "C" { typedef __id_t id_t; }
# 109
extern "C" { typedef __ssize_t ssize_t; }
# 115
extern "C" { typedef __daddr_t daddr_t; }
# 116
extern "C" { typedef __caddr_t caddr_t; }
# 122
extern "C" { typedef __key_t key_t; }
# 136 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
extern "C" { typedef __useconds_t useconds_t; }
# 140
extern "C" { typedef __suseconds_t suseconds_t; }
# 150 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
extern "C" { typedef unsigned long ulong; }
# 151
extern "C" { typedef unsigned short ushort; }
# 152
extern "C" { typedef unsigned uint; }
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
extern "C" { typedef signed char int8_t __attribute((__mode__(__QI__))); }
# 195
extern "C" { typedef short int16_t __attribute((__mode__(__HI__))); }
# 196
extern "C" { typedef int int32_t __attribute((__mode__(__SI__))); }
# 197
extern "C" { typedef long int64_t __attribute((__mode__(__DI__))); }
# 200
extern "C" { typedef unsigned char u_int8_t __attribute((__mode__(__QI__))); }
# 201
extern "C" { typedef unsigned short u_int16_t __attribute((__mode__(__HI__))); }
# 202
extern "C" { typedef unsigned u_int32_t __attribute((__mode__(__SI__))); }
# 203
extern "C" { typedef unsigned long u_int64_t __attribute((__mode__(__DI__))); }
# 205
extern "C" { typedef long register_t __attribute((__mode__(__word__))); }
# 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3
extern "C" { typedef int __sig_atomic_t; }
# 30
extern "C" { typedef 
# 28
struct { 
# 29
unsigned long __val[(1024) / ((8) * sizeof(unsigned long))]; 
# 30
} __sigset_t; }
# 37 "/usr/include/x86_64-linux-gnu/sys/select.h" 3
extern "C" { typedef __sigset_t sigset_t; }
# 54 "/usr/include/x86_64-linux-gnu/sys/select.h" 3
extern "C" { typedef long __fd_mask; }
# 75 "/usr/include/x86_64-linux-gnu/sys/select.h" 3
extern "C" { typedef 
# 65
struct { 
# 69
__fd_mask fds_bits[1024 / (8 * ((int)sizeof(__fd_mask)))]; 
# 75
} fd_set; }
# 82
extern "C" { typedef __fd_mask fd_mask; }
# 106 "/usr/include/x86_64-linux-gnu/sys/select.h" 3
extern "C" int select(int __nfds, fd_set *__restrict__ __readfds, fd_set *__restrict__ __writefds, fd_set *__restrict__ __exceptfds, timeval *__restrict__ __timeout); 
# 118 "/usr/include/x86_64-linux-gnu/sys/select.h" 3
extern "C" int pselect(int __nfds, fd_set *__restrict__ __readfds, fd_set *__restrict__ __writefds, fd_set *__restrict__ __exceptfds, const timespec *__restrict__ __timeout, const __sigset_t *__restrict__ __sigmask); 
# 27 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3
__extension__ extern "C" unsigned gnu_dev_major(unsigned long long __dev) throw()
# 28
 __attribute((const)); 
# 30
__extension__ extern "C" unsigned gnu_dev_minor(unsigned long long __dev) throw()
# 31
 __attribute((const)); 
# 33
__extension__ extern "C" unsigned long long gnu_dev_makedev(unsigned __major, unsigned __minor) throw()
# 35
 __attribute((const)); 
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
extern "C" { typedef __blksize_t blksize_t; }
# 235
extern "C" { typedef __blkcnt_t blkcnt_t; }
# 239
extern "C" { typedef __fsblkcnt_t fsblkcnt_t; }
# 243
extern "C" { typedef __fsfilcnt_t fsfilcnt_t; }
# 262 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
extern "C" { typedef __blkcnt64_t blkcnt64_t; }
# 263
extern "C" { typedef __fsblkcnt64_t fsblkcnt64_t; }
# 264
extern "C" { typedef __fsfilcnt64_t fsfilcnt64_t; }
# 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3
extern "C" { typedef unsigned long pthread_t; }
# 63
extern "C" { union pthread_attr_t { 
# 65
char __size[56]; 
# 66
long __align; 
# 67
}; }
# 69
extern "C" { typedef pthread_attr_t pthread_attr_t; }
# 79
extern "C" { typedef 
# 75
struct __pthread_internal_list { 
# 77
__pthread_internal_list *__prev; 
# 78
__pthread_internal_list *__next; 
# 79
} __pthread_list_t; }
# 128 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3
extern "C" { typedef 
# 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3
union { 
# 92
struct __pthread_mutex_s { 
# 94
int __lock; 
# 95
unsigned __count; 
# 96
int __owner; 
# 98
unsigned __nusers; 
# 102
int __kind; 
# 104
short __spins; 
# 105
short __elision; 
# 106
__pthread_list_t __list; 
# 125 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3
} __data; 
# 126
char __size[40]; 
# 127
long __align; 
# 128
} pthread_mutex_t; }
# 134
extern "C" { typedef 
# 131
union { 
# 132
char __size[4]; 
# 133
int __align; 
# 134
} pthread_mutexattr_t; }
# 154
extern "C" { typedef 
# 140
union { 
# 142
struct { 
# 143
int __lock; 
# 144
unsigned __futex; 
# 145
__extension__ unsigned long long __total_seq; 
# 146
__extension__ unsigned long long __wakeup_seq; 
# 147
__extension__ unsigned long long __woken_seq; 
# 148
void *__mutex; 
# 149
unsigned __nwaiters; 
# 150
unsigned __broadcast_seq; 
# 151
} __data; 
# 152
char __size[48]; 
# 153
__extension__ long long __align; 
# 154
} pthread_cond_t; }
# 160
extern "C" { typedef 
# 157
union { 
# 158
char __size[4]; 
# 159
int __align; 
# 160
} pthread_condattr_t; }
# 164
extern "C" { typedef unsigned pthread_key_t; }
# 168
extern "C" { typedef int pthread_once_t; }
# 222 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3
extern "C" { typedef 
# 175 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3
union { 
# 178
struct { 
# 179
int __lock; 
# 180
unsigned __nr_readers; 
# 181
unsigned __readers_wakeup; 
# 182
unsigned __writer_wakeup; 
# 183
unsigned __nr_readers_queued; 
# 184
unsigned __nr_writers_queued; 
# 185
int __writer; 
# 186
int __shared; 
# 187
signed char __rwelision; 
# 192
unsigned char __pad1[7]; 
# 195
unsigned long __pad2; 
# 198
unsigned __flags; 
# 200
} __data; 
# 220 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3
char __size[56]; 
# 221
long __align; 
# 222
} pthread_rwlock_t; }
# 228
extern "C" { typedef 
# 225
union { 
# 226
char __size[8]; 
# 227
long __align; 
# 228
} pthread_rwlockattr_t; }
# 234
extern "C" { typedef volatile int pthread_spinlock_t; }
# 243
extern "C" { typedef 
# 240
union { 
# 241
char __size[32]; 
# 242
long __align; 
# 243
} pthread_barrier_t; }
# 249
extern "C" { typedef 
# 246
union { 
# 247
char __size[4]; 
# 248
int __align; 
# 249
} pthread_barrierattr_t; }
# 321 "/usr/include/stdlib.h" 3
extern "C" long random() throw(); 
# 324
extern "C" void srandom(unsigned __seed) throw(); 
# 330
extern "C" char *initstate(unsigned __seed, char * __statebuf, size_t __statelen) throw()
# 331
 __attribute((__nonnull__(2))); 
# 335
extern "C" char *setstate(char * __statebuf) throw() __attribute((__nonnull__(1))); 
# 343
extern "C" { struct random_data { 
# 345
int32_t *fptr; 
# 346
int32_t *rptr; 
# 347
int32_t *state; 
# 348
int rand_type; 
# 349
int rand_deg; 
# 350
int rand_sep; 
# 351
int32_t *end_ptr; 
# 352
}; }
# 354
extern "C" int random_r(random_data *__restrict__ __buf, int32_t *__restrict__ __result) throw()
# 355
 __attribute((__nonnull__(1, 2))); 
# 357
extern "C" int srandom_r(unsigned __seed, random_data * __buf) throw()
# 358
 __attribute((__nonnull__(2))); 
# 360
extern "C" int initstate_r(unsigned __seed, char *__restrict__ __statebuf, size_t __statelen, random_data *__restrict__ __buf) throw()
# 363
 __attribute((__nonnull__(2, 4))); 
# 365
extern "C" int setstate_r(char *__restrict__ __statebuf, random_data *__restrict__ __buf) throw()
# 367
 __attribute((__nonnull__(1, 2))); 
# 374
extern "C" int rand() throw(); 
# 376
extern "C" void srand(unsigned __seed) throw(); 
# 381
extern "C" int rand_r(unsigned * __seed) throw(); 
# 389
extern "C" double drand48() throw(); 
# 390
extern "C" double erand48(unsigned short  __xsubi[3]) throw() __attribute((__nonnull__(1))); 
# 393
extern "C" long lrand48() throw(); 
# 394
extern "C" long nrand48(unsigned short  __xsubi[3]) throw()
# 395
 __attribute((__nonnull__(1))); 
# 398
extern "C" long mrand48() throw(); 
# 399
extern "C" long jrand48(unsigned short  __xsubi[3]) throw()
# 400
 __attribute((__nonnull__(1))); 
# 403
extern "C" void srand48(long __seedval) throw(); 
# 404
extern "C" unsigned short *seed48(unsigned short  __seed16v[3]) throw()
# 405
 __attribute((__nonnull__(1))); 
# 406
extern "C" void lcong48(unsigned short  __param[7]) throw() __attribute((__nonnull__(1))); 
# 412
extern "C" { struct drand48_data { 
# 414
unsigned short __x[3]; 
# 415
unsigned short __old_x[3]; 
# 416
unsigned short __c; 
# 417
unsigned short __init; 
# 418
__extension__ unsigned long long __a; 
# 420
}; }
# 423
extern "C" int drand48_r(drand48_data *__restrict__ __buffer, double *__restrict__ __result) throw()
# 424
 __attribute((__nonnull__(1, 2))); 
# 425
extern "C" int erand48_r(unsigned short  __xsubi[3], drand48_data *__restrict__ __buffer, double *__restrict__ __result) throw()
# 427
 __attribute((__nonnull__(1, 2))); 
# 430
extern "C" int lrand48_r(drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 432
 __attribute((__nonnull__(1, 2))); 
# 433
extern "C" int nrand48_r(unsigned short  __xsubi[3], drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 436
 __attribute((__nonnull__(1, 2))); 
# 439
extern "C" int mrand48_r(drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 441
 __attribute((__nonnull__(1, 2))); 
# 442
extern "C" int jrand48_r(unsigned short  __xsubi[3], drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 445
 __attribute((__nonnull__(1, 2))); 
# 448
extern "C" int srand48_r(long __seedval, drand48_data * __buffer) throw()
# 449
 __attribute((__nonnull__(2))); 
# 451
extern "C" int seed48_r(unsigned short  __seed16v[3], drand48_data * __buffer) throw()
# 452
 __attribute((__nonnull__(1, 2))); 
# 454
extern "C" int lcong48_r(unsigned short  __param[7], drand48_data * __buffer) throw()
# 456
 __attribute((__nonnull__(1, 2))); 
# 466
extern "C" void *malloc(size_t __size) throw() __attribute((__malloc__)); 
# 468
extern "C" void *calloc(size_t __nmemb, size_t __size) throw()
# 469
 __attribute((__malloc__)); 
# 480
extern "C" void *realloc(void * __ptr, size_t __size) throw()
# 481
 __attribute((__warn_unused_result__)); 
# 483
extern "C" void free(void * __ptr) throw(); 
# 488
extern "C" void cfree(void * __ptr) throw(); 
# 32 "/usr/include/alloca.h" 3
extern "C" void *alloca(size_t __size) throw(); 
# 498 "/usr/include/stdlib.h" 3
extern "C" void *valloc(size_t __size) throw() __attribute((__malloc__)); 
# 503
extern "C" int posix_memalign(void ** __memptr, size_t __alignment, size_t __size) throw()
# 504
 __attribute((__nonnull__(1))); 
# 509
extern "C" void *aligned_alloc(size_t __alignment, size_t __size) throw()
# 510
 __attribute((__malloc__)) __attribute((__alloc_size__(2))); 
# 515
extern "C" void abort() throw() __attribute((__noreturn__)); 
# 519
extern "C" int atexit(void (* __func)(void)) throw() __attribute((__nonnull__(1))); 
# 524
int at_quick_exit(void (* __func)(void)) throw() __asm__("at_quick_exit")
# 525
 __attribute((__nonnull__(1))); 
# 535
extern "C" int on_exit(void (* __func)(int __status, void * __arg), void * __arg) throw()
# 536
 __attribute((__nonnull__(1))); 
# 543
extern "C" void exit(int __status) throw() __attribute((__noreturn__)); 
# 549
extern "C" void quick_exit(int __status) throw() __attribute((__noreturn__)); 
# 557
extern "C" void _Exit(int __status) throw() __attribute((__noreturn__)); 
# 564
extern "C" char *getenv(const char * __name) throw() __attribute((__nonnull__(1))); 
# 570
extern "C" char *secure_getenv(const char * __name) throw()
# 571
 __attribute((__nonnull__(1))); 
# 578
extern "C" int putenv(char * __string) throw() __attribute((__nonnull__(1))); 
# 584
extern "C" int setenv(const char * __name, const char * __value, int __replace) throw()
# 585
 __attribute((__nonnull__(2))); 
# 588
extern "C" int unsetenv(const char * __name) throw() __attribute((__nonnull__(1))); 
# 595
extern "C" int clearenv() throw(); 
# 606 "/usr/include/stdlib.h" 3
extern "C" char *mktemp(char * __template) throw() __attribute((__nonnull__(1))); 
# 619 "/usr/include/stdlib.h" 3
extern "C" int mkstemp(char * __template) __attribute((__nonnull__(1))); 
# 629 "/usr/include/stdlib.h" 3
extern "C" int mkstemp64(char * __template) __attribute((__nonnull__(1))); 
# 641 "/usr/include/stdlib.h" 3
extern "C" int mkstemps(char * __template, int __suffixlen) __attribute((__nonnull__(1))); 
# 651 "/usr/include/stdlib.h" 3
extern "C" int mkstemps64(char * __template, int __suffixlen)
# 652
 __attribute((__nonnull__(1))); 
# 662 "/usr/include/stdlib.h" 3
extern "C" char *mkdtemp(char * __template) throw() __attribute((__nonnull__(1))); 
# 673 "/usr/include/stdlib.h" 3
extern "C" int mkostemp(char * __template, int __flags) __attribute((__nonnull__(1))); 
# 683 "/usr/include/stdlib.h" 3
extern "C" int mkostemp64(char * __template, int __flags) __attribute((__nonnull__(1))); 
# 693 "/usr/include/stdlib.h" 3
extern "C" int mkostemps(char * __template, int __suffixlen, int __flags)
# 694
 __attribute((__nonnull__(1))); 
# 705 "/usr/include/stdlib.h" 3
extern "C" int mkostemps64(char * __template, int __suffixlen, int __flags)
# 706
 __attribute((__nonnull__(1))); 
# 716
extern "C" int system(const char * __command); 
# 723
extern "C" char *canonicalize_file_name(const char * __name) throw()
# 724
 __attribute((__nonnull__(1))); 
# 733 "/usr/include/stdlib.h" 3
extern "C" char *realpath(const char *__restrict__ __name, char *__restrict__ __resolved) throw(); 
# 741
extern "C" { typedef int (*__compar_fn_t)(const void *, const void *); }
# 744
extern "C" { typedef __compar_fn_t comparison_fn_t; }
# 748
extern "C" { typedef int (*__compar_d_fn_t)(const void *, const void *, void *); }
# 754
extern "C" void *bsearch(const void * __key, const void * __base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
# 756
 __attribute((__nonnull__(1, 2, 5))); 
# 764
extern "C" void qsort(void * __base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
# 765
 __attribute((__nonnull__(1, 4))); 
# 767
extern "C" void qsort_r(void * __base, size_t __nmemb, size_t __size, __compar_d_fn_t __compar, void * __arg)
# 769
 __attribute((__nonnull__(1, 4))); 
# 774
extern "C" int abs(int __x) throw() __attribute((const)); 
# 775
extern "C" long labs(long __x) throw() __attribute((const)); 
# 779
__extension__ extern "C" long long llabs(long long __x) throw()
# 780
 __attribute((const)); 
# 788
extern "C" div_t div(int __numer, int __denom) throw()
# 789
 __attribute((const)); 
# 790
extern "C" ldiv_t ldiv(long __numer, long __denom) throw()
# 791
 __attribute((const)); 
# 796
__extension__ extern "C" lldiv_t lldiv(long long __numer, long long __denom) throw()
# 798
 __attribute((const)); 
# 811 "/usr/include/stdlib.h" 3
extern "C" char *ecvt(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 812
 __attribute((__nonnull__(3, 4))); 
# 817
extern "C" char *fcvt(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 818
 __attribute((__nonnull__(3, 4))); 
# 823
extern "C" char *gcvt(double __value, int __ndigit, char * __buf) throw()
# 824
 __attribute((__nonnull__(3))); 
# 829
extern "C" char *qecvt(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 831
 __attribute((__nonnull__(3, 4))); 
# 832
extern "C" char *qfcvt(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 834
 __attribute((__nonnull__(3, 4))); 
# 835
extern "C" char *qgcvt(long double __value, int __ndigit, char * __buf) throw()
# 836
 __attribute((__nonnull__(3))); 
# 841
extern "C" int ecvt_r(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 843
 __attribute((__nonnull__(3, 4, 5))); 
# 844
extern "C" int fcvt_r(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 846
 __attribute((__nonnull__(3, 4, 5))); 
# 848
extern "C" int qecvt_r(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 851
 __attribute((__nonnull__(3, 4, 5))); 
# 852
extern "C" int qfcvt_r(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 855
 __attribute((__nonnull__(3, 4, 5))); 
# 862
extern "C" int mblen(const char * __s, size_t __n) throw(); 
# 865
extern "C" int mbtowc(wchar_t *__restrict__ __pwc, const char *__restrict__ __s, size_t __n) throw(); 
# 869
extern "C" int wctomb(char * __s, wchar_t __wchar) throw(); 
# 873
extern "C" size_t mbstowcs(wchar_t *__restrict__ __pwcs, const char *__restrict__ __s, size_t __n) throw(); 
# 876
extern "C" size_t wcstombs(char *__restrict__ __s, const wchar_t *__restrict__ __pwcs, size_t __n) throw(); 
# 887
extern "C" int rpmatch(const char * __response) throw() __attribute((__nonnull__(1))); 
# 898 "/usr/include/stdlib.h" 3
extern "C" int getsubopt(char **__restrict__ __optionp, char *const *__restrict__ __tokens, char **__restrict__ __valuep) throw()
# 901
 __attribute((__nonnull__(1, 2, 3))); 
# 907
extern "C" void setkey(const char * __key) throw() __attribute((__nonnull__(1))); 
# 915
extern "C" int posix_openpt(int __oflag); 
# 923
extern "C" int grantpt(int __fd) throw(); 
# 927
extern "C" int unlockpt(int __fd) throw(); 
# 932
extern "C" char *ptsname(int __fd) throw(); 
# 939
extern "C" int ptsname_r(int __fd, char * __buf, size_t __buflen) throw()
# 940
 __attribute((__nonnull__(2))); 
# 943
extern "C" int getpt(); 
# 950
extern "C" int getloadavg(double  __loadavg[], int __nelem) throw()
# 951
 __attribute((__nonnull__(1))); 
# 197 "/usr/include/x86_64-linux-gnu/c++/5/bits/c++config.h" 3
namespace std { 
# 199
typedef unsigned long size_t; 
# 200
typedef long ptrdiff_t; 
# 205
}
# 219 "/usr/include/x86_64-linux-gnu/c++/5/bits/c++config.h" 3
namespace std { 
# 221
inline namespace __cxx11 __attribute((__abi_tag__("cxx11" ))) { }
# 222
}
# 223
namespace __gnu_cxx { 
# 225
inline namespace __cxx11 __attribute((__abi_tag__("cxx11" ))) { }
# 226
}
# 68 "/usr/include/c++/5/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 72
template< class _Iterator, class _Container> class __normal_iterator; 
# 76
}
# 78
namespace std __attribute((__visibility__("default"))) { 
# 82
struct __true_type { }; 
# 83
struct __false_type { }; 
# 85
template< bool > 
# 86
struct __truth_type { 
# 87
typedef __false_type __type; }; 
# 90
template<> struct __truth_type< true>  { 
# 91
typedef __true_type __type; }; 
# 95
template< class _Sp, class _Tp> 
# 96
struct __traitor { 
# 98
enum { __value = ((bool)_Sp::__value) || ((bool)_Tp::__value)}; 
# 99
typedef typename __truth_type< __value> ::__type __type; 
# 100
}; 
# 103
template< class , class > 
# 104
struct __are_same { 
# 106
enum { __value}; 
# 107
typedef __false_type __type; 
# 108
}; 
# 110
template< class _Tp> 
# 111
struct __are_same< _Tp, _Tp>  { 
# 113
enum { __value = 1}; 
# 114
typedef __true_type __type; 
# 115
}; 
# 118
template< class _Tp> 
# 119
struct __is_void { 
# 121
enum { __value}; 
# 122
typedef __false_type __type; 
# 123
}; 
# 126
template<> struct __is_void< void>  { 
# 128
enum { __value = 1}; 
# 129
typedef __true_type __type; 
# 130
}; 
# 135
template< class _Tp> 
# 136
struct __is_integer { 
# 138
enum { __value}; 
# 139
typedef __false_type __type; 
# 140
}; 
# 147
template<> struct __is_integer< bool>  { 
# 149
enum { __value = 1}; 
# 150
typedef __true_type __type; 
# 151
}; 
# 154
template<> struct __is_integer< char>  { 
# 156
enum { __value = 1}; 
# 157
typedef __true_type __type; 
# 158
}; 
# 161
template<> struct __is_integer< signed char>  { 
# 163
enum { __value = 1}; 
# 164
typedef __true_type __type; 
# 165
}; 
# 168
template<> struct __is_integer< unsigned char>  { 
# 170
enum { __value = 1}; 
# 171
typedef __true_type __type; 
# 172
}; 
# 176
template<> struct __is_integer< wchar_t>  { 
# 178
enum { __value = 1}; 
# 179
typedef __true_type __type; 
# 180
}; 
# 200 "/usr/include/c++/5/bits/cpp_type_traits.h" 3
template<> struct __is_integer< short>  { 
# 202
enum { __value = 1}; 
# 203
typedef __true_type __type; 
# 204
}; 
# 207
template<> struct __is_integer< unsigned short>  { 
# 209
enum { __value = 1}; 
# 210
typedef __true_type __type; 
# 211
}; 
# 214
template<> struct __is_integer< int>  { 
# 216
enum { __value = 1}; 
# 217
typedef __true_type __type; 
# 218
}; 
# 221
template<> struct __is_integer< unsigned>  { 
# 223
enum { __value = 1}; 
# 224
typedef __true_type __type; 
# 225
}; 
# 228
template<> struct __is_integer< long>  { 
# 230
enum { __value = 1}; 
# 231
typedef __true_type __type; 
# 232
}; 
# 235
template<> struct __is_integer< unsigned long>  { 
# 237
enum { __value = 1}; 
# 238
typedef __true_type __type; 
# 239
}; 
# 242
template<> struct __is_integer< long long>  { 
# 244
enum { __value = 1}; 
# 245
typedef __true_type __type; 
# 246
}; 
# 249
template<> struct __is_integer< unsigned long long>  { 
# 251
enum { __value = 1}; 
# 252
typedef __true_type __type; 
# 253
}; 
# 270 "/usr/include/c++/5/bits/cpp_type_traits.h" 3
template<> struct __is_integer< __int128_t>  { enum { __value = 1}; typedef __true_type __type; }; template<> struct __is_integer< __uint128_t>  { enum { __value = 1}; typedef __true_type __type; }; 
# 287 "/usr/include/c++/5/bits/cpp_type_traits.h" 3
template< class _Tp> 
# 288
struct __is_floating { 
# 290
enum { __value}; 
# 291
typedef __false_type __type; 
# 292
}; 
# 296
template<> struct __is_floating< float>  { 
# 298
enum { __value = 1}; 
# 299
typedef __true_type __type; 
# 300
}; 
# 303
template<> struct __is_floating< double>  { 
# 305
enum { __value = 1}; 
# 306
typedef __true_type __type; 
# 307
}; 
# 310
template<> struct __is_floating< long double>  { 
# 312
enum { __value = 1}; 
# 313
typedef __true_type __type; 
# 314
}; 
# 319
template< class _Tp> 
# 320
struct __is_pointer { 
# 322
enum { __value}; 
# 323
typedef __false_type __type; 
# 324
}; 
# 326
template< class _Tp> 
# 327
struct __is_pointer< _Tp *>  { 
# 329
enum { __value = 1}; 
# 330
typedef __true_type __type; 
# 331
}; 
# 336
template< class _Tp> 
# 337
struct __is_normal_iterator { 
# 339
enum { __value}; 
# 340
typedef __false_type __type; 
# 341
}; 
# 343
template< class _Iterator, class _Container> 
# 344
struct __is_normal_iterator< __gnu_cxx::__normal_iterator< _Iterator, _Container> >  { 
# 347
enum { __value = 1}; 
# 348
typedef __true_type __type; 
# 349
}; 
# 354
template< class _Tp> 
# 355
struct __is_arithmetic : public __traitor< __is_integer< _Tp> , __is_floating< _Tp> >  { 
# 357
}; 
# 362
template< class _Tp> 
# 363
struct __is_scalar : public __traitor< __is_arithmetic< _Tp> , __is_pointer< _Tp> >  { 
# 365
}; 
# 370
template< class _Tp> 
# 371
struct __is_char { 
# 373
enum { __value}; 
# 374
typedef __false_type __type; 
# 375
}; 
# 378
template<> struct __is_char< char>  { 
# 380
enum { __value = 1}; 
# 381
typedef __true_type __type; 
# 382
}; 
# 386
template<> struct __is_char< wchar_t>  { 
# 388
enum { __value = 1}; 
# 389
typedef __true_type __type; 
# 390
}; 
# 393
template< class _Tp> 
# 394
struct __is_byte { 
# 396
enum { __value}; 
# 397
typedef __false_type __type; 
# 398
}; 
# 401
template<> struct __is_byte< char>  { 
# 403
enum { __value = 1}; 
# 404
typedef __true_type __type; 
# 405
}; 
# 408
template<> struct __is_byte< signed char>  { 
# 410
enum { __value = 1}; 
# 411
typedef __true_type __type; 
# 412
}; 
# 415
template<> struct __is_byte< unsigned char>  { 
# 417
enum { __value = 1}; 
# 418
typedef __true_type __type; 
# 419
}; 
# 424
template< class _Tp> 
# 425
struct __is_move_iterator { 
# 427
enum { __value}; 
# 428
typedef __false_type __type; 
# 429
}; 
# 444 "/usr/include/c++/5/bits/cpp_type_traits.h" 3
}
# 37 "/usr/include/c++/5/ext/type_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 42
template< bool , class > 
# 43
struct __enable_if { 
# 44
}; 
# 46
template< class _Tp> 
# 47
struct __enable_if< true, _Tp>  { 
# 48
typedef _Tp __type; }; 
# 52
template< bool _Cond, class _Iftrue, class _Iffalse> 
# 53
struct __conditional_type { 
# 54
typedef _Iftrue __type; }; 
# 56
template< class _Iftrue, class _Iffalse> 
# 57
struct __conditional_type< false, _Iftrue, _Iffalse>  { 
# 58
typedef _Iffalse __type; }; 
# 62
template< class _Tp> 
# 63
struct __add_unsigned { 
# 66
private: typedef __enable_if< std::__is_integer< _Tp> ::__value, _Tp>  __if_type; 
# 69
public: typedef typename __enable_if< std::__is_integer< _Tp> ::__value, _Tp> ::__type __type; 
# 70
}; 
# 73
template<> struct __add_unsigned< char>  { 
# 74
typedef unsigned char __type; }; 
# 77
template<> struct __add_unsigned< signed char>  { 
# 78
typedef unsigned char __type; }; 
# 81
template<> struct __add_unsigned< short>  { 
# 82
typedef unsigned short __type; }; 
# 85
template<> struct __add_unsigned< int>  { 
# 86
typedef unsigned __type; }; 
# 89
template<> struct __add_unsigned< long>  { 
# 90
typedef unsigned long __type; }; 
# 93
template<> struct __add_unsigned< long long>  { 
# 94
typedef unsigned long long __type; }; 
# 98
template<> struct __add_unsigned< bool> ; 
# 101
template<> struct __add_unsigned< wchar_t> ; 
# 105
template< class _Tp> 
# 106
struct __remove_unsigned { 
# 109
private: typedef __enable_if< std::__is_integer< _Tp> ::__value, _Tp>  __if_type; 
# 112
public: typedef typename __enable_if< std::__is_integer< _Tp> ::__value, _Tp> ::__type __type; 
# 113
}; 
# 116
template<> struct __remove_unsigned< char>  { 
# 117
typedef signed char __type; }; 
# 120
template<> struct __remove_unsigned< unsigned char>  { 
# 121
typedef signed char __type; }; 
# 124
template<> struct __remove_unsigned< unsigned short>  { 
# 125
typedef short __type; }; 
# 128
template<> struct __remove_unsigned< unsigned>  { 
# 129
typedef int __type; }; 
# 132
template<> struct __remove_unsigned< unsigned long>  { 
# 133
typedef long __type; }; 
# 136
template<> struct __remove_unsigned< unsigned long long>  { 
# 137
typedef long long __type; }; 
# 141
template<> struct __remove_unsigned< bool> ; 
# 144
template<> struct __remove_unsigned< wchar_t> ; 
# 148
template< class _Type> inline bool 
# 150
__is_null_pointer(_Type *__ptr) 
# 151
{ return __ptr == 0; } 
# 153
template< class _Type> inline bool 
# 155
__is_null_pointer(_Type) 
# 156
{ return false; } 
# 165 "/usr/include/c++/5/ext/type_traits.h" 3
template< class _Tp, bool  = std::__is_integer< _Tp> ::__value> 
# 166
struct __promote { 
# 167
typedef double __type; }; 
# 172
template< class _Tp> 
# 173
struct __promote< _Tp, false>  { 
# 174
}; 
# 177
template<> struct __promote< long double>  { 
# 178
typedef long double __type; }; 
# 181
template<> struct __promote< double>  { 
# 182
typedef double __type; }; 
# 185
template<> struct __promote< float>  { 
# 186
typedef float __type; }; 
# 188
template< class _Tp, class _Up, class 
# 189
_Tp2 = typename __promote< _Tp> ::__type, class 
# 190
_Up2 = typename __promote< _Up> ::__type> 
# 191
struct __promote_2 { 
# 193
typedef __typeof__(_Tp2() + _Up2()) __type; 
# 194
}; 
# 196
template< class _Tp, class _Up, class _Vp, class 
# 197
_Tp2 = typename __promote< _Tp> ::__type, class 
# 198
_Up2 = typename __promote< _Up> ::__type, class 
# 199
_Vp2 = typename __promote< _Vp> ::__type> 
# 200
struct __promote_3 { 
# 202
typedef __typeof__((_Tp2() + _Up2()) + _Vp2()) __type; 
# 203
}; 
# 205
template< class _Tp, class _Up, class _Vp, class _Wp, class 
# 206
_Tp2 = typename __promote< _Tp> ::__type, class 
# 207
_Up2 = typename __promote< _Up> ::__type, class 
# 208
_Vp2 = typename __promote< _Vp> ::__type, class 
# 209
_Wp2 = typename __promote< _Wp> ::__type> 
# 210
struct __promote_4 { 
# 212
typedef __typeof__(((_Tp2() + _Up2()) + _Vp2()) + _Wp2()) __type; 
# 213
}; 
# 216
}
# 75 "/usr/include/c++/5/cmath" 3
namespace std __attribute((__visibility__("default"))) { 
# 81
inline double abs(double __x) 
# 82
{ return __builtin_fabs(__x); } 
# 87
inline float abs(float __x) 
# 88
{ return __builtin_fabsf(__x); } 
# 91
inline long double abs(long double __x) 
# 92
{ return __builtin_fabsl(__x); } 
# 95
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 99
abs(_Tp __x) 
# 100
{ return __builtin_fabs(__x); } 
# 102
using ::acos;
# 106
inline float acos(float __x) 
# 107
{ return __builtin_acosf(__x); } 
# 110
inline long double acos(long double __x) 
# 111
{ return __builtin_acosl(__x); } 
# 114
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 118
acos(_Tp __x) 
# 119
{ return __builtin_acos(__x); } 
# 121
using ::asin;
# 125
inline float asin(float __x) 
# 126
{ return __builtin_asinf(__x); } 
# 129
inline long double asin(long double __x) 
# 130
{ return __builtin_asinl(__x); } 
# 133
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 137
asin(_Tp __x) 
# 138
{ return __builtin_asin(__x); } 
# 140
using ::atan;
# 144
inline float atan(float __x) 
# 145
{ return __builtin_atanf(__x); } 
# 148
inline long double atan(long double __x) 
# 149
{ return __builtin_atanl(__x); } 
# 152
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 156
atan(_Tp __x) 
# 157
{ return __builtin_atan(__x); } 
# 159
using ::atan2;
# 163
inline float atan2(float __y, float __x) 
# 164
{ return __builtin_atan2f(__y, __x); } 
# 167
inline long double atan2(long double __y, long double __x) 
# 168
{ return __builtin_atan2l(__y, __x); } 
# 171
template< class _Tp, class _Up> inline typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 174
atan2(_Tp __y, _Up __x) 
# 175
{ 
# 176
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 177
return atan2((__type)__y, (__type)__x); 
# 178
} 
# 180
using ::ceil;
# 184
inline float ceil(float __x) 
# 185
{ return __builtin_ceilf(__x); } 
# 188
inline long double ceil(long double __x) 
# 189
{ return __builtin_ceill(__x); } 
# 192
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 196
ceil(_Tp __x) 
# 197
{ return __builtin_ceil(__x); } 
# 199
using ::cos;
# 203
inline float cos(float __x) 
# 204
{ return __builtin_cosf(__x); } 
# 207
inline long double cos(long double __x) 
# 208
{ return __builtin_cosl(__x); } 
# 211
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 215
cos(_Tp __x) 
# 216
{ return __builtin_cos(__x); } 
# 218
using ::cosh;
# 222
inline float cosh(float __x) 
# 223
{ return __builtin_coshf(__x); } 
# 226
inline long double cosh(long double __x) 
# 227
{ return __builtin_coshl(__x); } 
# 230
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 234
cosh(_Tp __x) 
# 235
{ return __builtin_cosh(__x); } 
# 237
using ::exp;
# 241
inline float exp(float __x) 
# 242
{ return __builtin_expf(__x); } 
# 245
inline long double exp(long double __x) 
# 246
{ return __builtin_expl(__x); } 
# 249
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 253
exp(_Tp __x) 
# 254
{ return __builtin_exp(__x); } 
# 256
using ::fabs;
# 260
inline float fabs(float __x) 
# 261
{ return __builtin_fabsf(__x); } 
# 264
inline long double fabs(long double __x) 
# 265
{ return __builtin_fabsl(__x); } 
# 268
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 272
fabs(_Tp __x) 
# 273
{ return __builtin_fabs(__x); } 
# 275
using ::floor;
# 279
inline float floor(float __x) 
# 280
{ return __builtin_floorf(__x); } 
# 283
inline long double floor(long double __x) 
# 284
{ return __builtin_floorl(__x); } 
# 287
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 291
floor(_Tp __x) 
# 292
{ return __builtin_floor(__x); } 
# 294
using ::fmod;
# 298
inline float fmod(float __x, float __y) 
# 299
{ return __builtin_fmodf(__x, __y); } 
# 302
inline long double fmod(long double __x, long double __y) 
# 303
{ return __builtin_fmodl(__x, __y); } 
# 306
template< class _Tp, class _Up> inline typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 309
fmod(_Tp __x, _Up __y) 
# 310
{ 
# 311
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 312
return fmod((__type)__x, (__type)__y); 
# 313
} 
# 315
using ::frexp;
# 319
inline float frexp(float __x, int *__exp) 
# 320
{ return __builtin_frexpf(__x, __exp); } 
# 323
inline long double frexp(long double __x, int *__exp) 
# 324
{ return __builtin_frexpl(__x, __exp); } 
# 327
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 331
frexp(_Tp __x, int *__exp) 
# 332
{ return __builtin_frexp(__x, __exp); } 
# 334
using ::ldexp;
# 338
inline float ldexp(float __x, int __exp) 
# 339
{ return __builtin_ldexpf(__x, __exp); } 
# 342
inline long double ldexp(long double __x, int __exp) 
# 343
{ return __builtin_ldexpl(__x, __exp); } 
# 346
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 350
ldexp(_Tp __x, int __exp) 
# 351
{ return __builtin_ldexp(__x, __exp); } 
# 353
using ::log;
# 357
inline float log(float __x) 
# 358
{ return __builtin_logf(__x); } 
# 361
inline long double log(long double __x) 
# 362
{ return __builtin_logl(__x); } 
# 365
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 369
log(_Tp __x) 
# 370
{ return __builtin_log(__x); } 
# 372
using ::log10;
# 376
inline float log10(float __x) 
# 377
{ return __builtin_log10f(__x); } 
# 380
inline long double log10(long double __x) 
# 381
{ return __builtin_log10l(__x); } 
# 384
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 388
log10(_Tp __x) 
# 389
{ return __builtin_log10(__x); } 
# 391
using ::modf;
# 395
inline float modf(float __x, float *__iptr) 
# 396
{ return __builtin_modff(__x, __iptr); } 
# 399
inline long double modf(long double __x, long double *__iptr) 
# 400
{ return __builtin_modfl(__x, __iptr); } 
# 403
using ::pow;
# 407
inline float pow(float __x, float __y) 
# 408
{ return __builtin_powf(__x, __y); } 
# 411
inline long double pow(long double __x, long double __y) 
# 412
{ return __builtin_powl(__x, __y); } 
# 418
inline double pow(double __x, int __i) 
# 419
{ return __builtin_powi(__x, __i); } 
# 422
inline float pow(float __x, int __n) 
# 423
{ return __builtin_powif(__x, __n); } 
# 426
inline long double pow(long double __x, int __n) 
# 427
{ return __builtin_powil(__x, __n); } 
# 431
template< class _Tp, class _Up> inline typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 434
pow(_Tp __x, _Up __y) 
# 435
{ 
# 436
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 437
return pow((__type)__x, (__type)__y); 
# 438
} 
# 440
using ::sin;
# 444
inline float sin(float __x) 
# 445
{ return __builtin_sinf(__x); } 
# 448
inline long double sin(long double __x) 
# 449
{ return __builtin_sinl(__x); } 
# 452
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 456
sin(_Tp __x) 
# 457
{ return __builtin_sin(__x); } 
# 459
using ::sinh;
# 463
inline float sinh(float __x) 
# 464
{ return __builtin_sinhf(__x); } 
# 467
inline long double sinh(long double __x) 
# 468
{ return __builtin_sinhl(__x); } 
# 471
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 475
sinh(_Tp __x) 
# 476
{ return __builtin_sinh(__x); } 
# 478
using ::sqrt;
# 482
inline float sqrt(float __x) 
# 483
{ return __builtin_sqrtf(__x); } 
# 486
inline long double sqrt(long double __x) 
# 487
{ return __builtin_sqrtl(__x); } 
# 490
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 494
sqrt(_Tp __x) 
# 495
{ return __builtin_sqrt(__x); } 
# 497
using ::tan;
# 501
inline float tan(float __x) 
# 502
{ return __builtin_tanf(__x); } 
# 505
inline long double tan(long double __x) 
# 506
{ return __builtin_tanl(__x); } 
# 509
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 513
tan(_Tp __x) 
# 514
{ return __builtin_tan(__x); } 
# 516
using ::tanh;
# 520
inline float tanh(float __x) 
# 521
{ return __builtin_tanhf(__x); } 
# 524
inline long double tanh(long double __x) 
# 525
{ return __builtin_tanhl(__x); } 
# 528
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 532
tanh(_Tp __x) 
# 533
{ return __builtin_tanh(__x); } 
# 536
}
# 555 "/usr/include/c++/5/cmath" 3
namespace std __attribute((__visibility__("default"))) { 
# 855 "/usr/include/c++/5/cmath" 3
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 858
fpclassify(_Tp __f) 
# 859
{ 
# 860
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 861
return __builtin_fpclassify(0, 1, 4, 3, 2, (__type)__f); 
# 863
} 
# 865
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 868
isfinite(_Tp __f) 
# 869
{ 
# 870
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 871
return __builtin_isfinite((__type)__f); 
# 872
} 
# 874
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 877
isinf(_Tp __f) 
# 878
{ 
# 879
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 880
return __builtin_isinf((__type)__f); 
# 881
} 
# 883
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 886
isnan(_Tp __f) 
# 887
{ 
# 888
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 889
return __builtin_isnan((__type)__f); 
# 890
} 
# 892
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 895
isnormal(_Tp __f) 
# 896
{ 
# 897
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 898
return __builtin_isnormal((__type)__f); 
# 899
} 
# 901
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 904
signbit(_Tp __f) 
# 905
{ 
# 906
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 907
return (sizeof(__type) == sizeof(float)) ? __builtin_signbitf((__type)__f) : ((sizeof(__type) == sizeof(double)) ? __builtin_signbit((__type)__f) : __builtin_signbitl((__type)__f)); 
# 912
} 
# 914
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 917
isgreater(_Tp __f1, _Tp __f2) 
# 918
{ 
# 919
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 920
return __builtin_isgreater((__type)__f1, (__type)__f2); 
# 921
} 
# 923
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 926
isgreaterequal(_Tp __f1, _Tp __f2) 
# 927
{ 
# 928
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 929
return __builtin_isgreaterequal((__type)__f1, (__type)__f2); 
# 930
} 
# 932
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 935
isless(_Tp __f1, _Tp __f2) 
# 936
{ 
# 937
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 938
return __builtin_isless((__type)__f1, (__type)__f2); 
# 939
} 
# 941
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 944
islessequal(_Tp __f1, _Tp __f2) 
# 945
{ 
# 946
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 947
return __builtin_islessequal((__type)__f1, (__type)__f2); 
# 948
} 
# 950
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 953
islessgreater(_Tp __f1, _Tp __f2) 
# 954
{ 
# 955
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 956
return __builtin_islessgreater((__type)__f1, (__type)__f2); 
# 957
} 
# 959
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 962
isunordered(_Tp __f1, _Tp __f2) 
# 963
{ 
# 964
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 965
return __builtin_isunordered((__type)__f1, (__type)__f2); 
# 966
} 
# 971
}
# 114 "/usr/include/c++/5/cstdlib" 3
namespace std __attribute((__visibility__("default"))) { 
# 118
using ::div_t;
# 119
using ::ldiv_t;
# 121
using ::abort;
# 122
using ::abs;
# 123
using ::atexit;
# 129
using ::atof;
# 130
using ::atoi;
# 131
using ::atol;
# 132
using ::bsearch;
# 133
using ::calloc;
# 134
using ::div;
# 135
using ::exit;
# 136
using ::free;
# 137
using ::getenv;
# 138
using ::labs;
# 139
using ::ldiv;
# 140
using ::malloc;
# 142
using ::mblen;
# 143
using ::mbstowcs;
# 144
using ::mbtowc;
# 146
using ::qsort;
# 152
using ::rand;
# 153
using ::realloc;
# 154
using ::srand;
# 155
using ::strtod;
# 156
using ::strtol;
# 157
using ::strtoul;
# 158
using ::system;
# 160
using ::wcstombs;
# 161
using ::wctomb;
# 166
inline long abs(long __i) { return __builtin_labs(__i); } 
# 169
inline ldiv_t div(long __i, long __j) { return ldiv(__i, __j); } 
# 174
inline long long abs(long long __x) { return __builtin_llabs(__x); } 
# 179
inline __int128_t abs(__int128_t __x) { return (__x >= (0)) ? __x : (-__x); } 
# 196 "/usr/include/c++/5/cstdlib" 3
}
# 209 "/usr/include/c++/5/cstdlib" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 214
using ::lldiv_t;
# 220
using ::_Exit;
# 224
using ::llabs;
# 227
inline lldiv_t div(long long __n, long long __d) 
# 228
{ lldiv_t __q; (__q.quot) = (__n / __d); (__q.rem) = (__n % __d); return __q; } 
# 230
using ::lldiv;
# 241 "/usr/include/c++/5/cstdlib" 3
using ::atoll;
# 242
using ::strtoll;
# 243
using ::strtoull;
# 245
using ::strtof;
# 246
using ::strtold;
# 249
}
# 251
namespace std { 
# 254
using __gnu_cxx::lldiv_t;
# 256
using __gnu_cxx::_Exit;
# 258
using __gnu_cxx::llabs;
# 259
using __gnu_cxx::div;
# 260
using __gnu_cxx::lldiv;
# 262
using __gnu_cxx::atoll;
# 263
using __gnu_cxx::strtof;
# 264
using __gnu_cxx::strtoll;
# 265
using __gnu_cxx::strtoull;
# 266
using __gnu_cxx::strtold;
# 267
}
# 8860 "/usr/include/math_functions.h" 3
__attribute((always_inline)) inline int signbit(float x); 
# 8864
__attribute((always_inline)) inline int signbit(double x); 
# 8866
__attribute((always_inline)) inline int signbit(long double x); 
# 8868
__attribute((always_inline)) inline int isfinite(float x); 
# 8872
__attribute((always_inline)) inline int isfinite(double x); 
# 8874
__attribute((always_inline)) inline int isfinite(long double x); 
# 8876
__attribute((always_inline)) inline int isnan(float x); 
# 8880
extern "C" { __attribute((always_inline)) inline int isnan(double x) throw(); } 
# 8882
__attribute((always_inline)) inline int isnan(long double x); 
# 8884
__attribute((always_inline)) inline int isinf(float x); 
# 8888
extern "C" { __attribute((always_inline)) inline int isinf(double x) throw(); } 
# 8890
__attribute((always_inline)) inline int isinf(long double x); 
# 8936 "/usr/include/math_functions.h" 3
namespace std { 
# 8938
template< class T> extern T __pow_helper(T, int); 
# 8939
template< class T> extern T __cmath_power(T, unsigned); 
# 8940
}
# 8942
using std::abs;
# 8943
using std::fabs;
# 8944
using std::ceil;
# 8945
using std::floor;
# 8946
using std::sqrt;
# 8947
using std::pow;
# 8948
using std::log;
# 8949
using std::log10;
# 8950
using std::fmod;
# 8951
using std::modf;
# 8952
using std::exp;
# 8953
using std::frexp;
# 8954
using std::ldexp;
# 8955
using std::asin;
# 8956
using std::sin;
# 8957
using std::sinh;
# 8958
using std::acos;
# 8959
using std::cos;
# 8960
using std::cosh;
# 8961
using std::atan;
# 8962
using std::atan2;
# 8963
using std::tan;
# 8964
using std::tanh;
# 9327 "/usr/include/math_functions.h" 3
namespace std { 
# 9340 "/usr/include/math_functions.h" 3
extern inline long long abs(long long); 
# 9346
extern inline long abs(long); 
# 9347
extern inline float abs(float); 
# 9348
extern inline double abs(double); 
# 9349
extern inline float fabs(float); 
# 9350
extern inline float ceil(float); 
# 9351
extern inline float floor(float); 
# 9352
extern inline float sqrt(float); 
# 9353
extern inline float pow(float, float); 
# 9362 "/usr/include/math_functions.h" 3
extern inline float pow(float, int); 
# 9363
extern inline double pow(double, int); 
# 9368
extern inline float log(float); 
# 9369
extern inline float log10(float); 
# 9370
extern inline float fmod(float, float); 
# 9371
extern inline float modf(float, float *); 
# 9372
extern inline float exp(float); 
# 9373
extern inline float frexp(float, int *); 
# 9374
extern inline float ldexp(float, int); 
# 9375
extern inline float asin(float); 
# 9376
extern inline float sin(float); 
# 9377
extern inline float sinh(float); 
# 9378
extern inline float acos(float); 
# 9379
extern inline float cos(float); 
# 9380
extern inline float cosh(float); 
# 9381
extern inline float atan(float); 
# 9382
extern inline float atan2(float, float); 
# 9383
extern inline float tan(float); 
# 9384
extern inline float tanh(float); 
# 9441 "/usr/include/math_functions.h" 3
}
# 9493 "/usr/include/math_functions.h" 3
static inline float logb(float a); 
# 9495
static inline int ilogb(float a); 
# 9497
static inline float scalbn(float a, int b); 
# 9499
static inline float scalbln(float a, long b); 
# 9501
static inline float exp2(float a); 
# 9503
static inline float expm1(float a); 
# 9505
static inline float log2(float a); 
# 9507
static inline float log1p(float a); 
# 9509
static inline float acosh(float a); 
# 9511
static inline float asinh(float a); 
# 9513
static inline float atanh(float a); 
# 9515
static inline float hypot(float a, float b); 
# 9517
static inline float norm3d(float a, float b, float c); 
# 9519
static inline float norm4d(float a, float b, float c, float d); 
# 9521
static inline float cbrt(float a); 
# 9523
static inline float erf(float a); 
# 9525
static inline float erfc(float a); 
# 9527
static inline float lgamma(float a); 
# 9529
static inline float tgamma(float a); 
# 9531
static inline float copysign(float a, float b); 
# 9533
static inline float nextafter(float a, float b); 
# 9535
static inline float remainder(float a, float b); 
# 9537
static inline float remquo(float a, float b, int * quo); 
# 9539
static inline float round(float a); 
# 9541
static inline long lround(float a); 
# 9543
static inline long long llround(float a); 
# 9545
static inline float trunc(float a); 
# 9547
static inline float rint(float a); 
# 9549
static inline long lrint(float a); 
# 9551
static inline long long llrint(float a); 
# 9553
static inline float nearbyint(float a); 
# 9555
static inline float fdim(float a, float b); 
# 9557
static inline float fma(float a, float b, float c); 
# 9559
static inline float fmax(float a, float b); 
# 9561
static inline float fmin(float a, float b); 
# 9601 "/usr/include/math_functions.h" 3
static inline float exp10(float a); 
# 9603
static inline float rsqrt(float a); 
# 9605
static inline float rcbrt(float a); 
# 9607
static inline float sinpi(float a); 
# 9609
static inline float cospi(float a); 
# 9611
static inline void sincospi(float a, float * sptr, float * cptr); 
# 9613
static inline void sincos(float a, float * sptr, float * cptr); 
# 9615
static inline float j0(float a); 
# 9617
static inline float j1(float a); 
# 9619
static inline float jn(int n, float a); 
# 9621
static inline float y0(float a); 
# 9623
static inline float y1(float a); 
# 9625
static inline float yn(int n, float a); 
# 9627
static inline float cyl_bessel_i0(float a); 
# 9629
static inline float cyl_bessel_i1(float a); 
# 9631
static inline float erfinv(float a); 
# 9633
static inline float erfcinv(float a); 
# 9635
static inline float normcdfinv(float a); 
# 9637
static inline float normcdf(float a); 
# 9639
static inline float erfcx(float a); 
# 9641
static inline double copysign(double a, float b); 
# 9643
static inline float copysign(float a, double b); 
# 9645
static inline unsigned min(unsigned a, unsigned b); 
# 9647
static inline unsigned min(int a, unsigned b); 
# 9649
static inline unsigned min(unsigned a, int b); 
# 9651
static inline long min(long a, long b); 
# 9653
static inline unsigned long min(unsigned long a, unsigned long b); 
# 9655
static inline unsigned long min(long a, unsigned long b); 
# 9657
static inline unsigned long min(unsigned long a, long b); 
# 9659
static inline long long min(long long a, long long b); 
# 9661
static inline unsigned long long min(unsigned long long a, unsigned long long b); 
# 9663
static inline unsigned long long min(long long a, unsigned long long b); 
# 9665
static inline unsigned long long min(unsigned long long a, long long b); 
# 9667
static inline float min(float a, float b); 
# 9669
static inline double min(double a, double b); 
# 9671
static inline double min(float a, double b); 
# 9673
static inline double min(double a, float b); 
# 9675
static inline unsigned max(unsigned a, unsigned b); 
# 9677
static inline unsigned max(int a, unsigned b); 
# 9679
static inline unsigned max(unsigned a, int b); 
# 9681
static inline long max(long a, long b); 
# 9683
static inline unsigned long max(unsigned long a, unsigned long b); 
# 9685
static inline unsigned long max(long a, unsigned long b); 
# 9687
static inline unsigned long max(unsigned long a, long b); 
# 9689
static inline long long max(long long a, long long b); 
# 9691
static inline unsigned long long max(unsigned long long a, unsigned long long b); 
# 9693
static inline unsigned long long max(long long a, unsigned long long b); 
# 9695
static inline unsigned long long max(unsigned long long a, long long b); 
# 9697
static inline float max(float a, float b); 
# 9699
static inline double max(double a, double b); 
# 9701
static inline double max(float a, double b); 
# 9703
static inline double max(double a, float b); 
# 240 "/usr/include/math_functions.hpp" 3
__attribute((always_inline)) inline int signbit(float x) { return __signbitf(x); } 
# 244
__attribute((always_inline)) inline int signbit(double x) { return __signbit(x); } 
# 246
__attribute((always_inline)) inline int signbit(long double x) { return __signbitl(x); } 
# 248
__attribute((always_inline)) inline int isfinite(float x) { return __finitef(x); } 
# 252
__attribute((always_inline)) inline int isfinite(double x) { return __finite(x); } 
# 254
__attribute((always_inline)) inline int isfinite(long double x) { return __finitel(x); } 
# 257
__attribute((always_inline)) inline int isnan(float x) { return __isnanf(x); } 
# 261
__attribute((always_inline)) inline int isnan(double x) throw() { return __isnan(x); } 
# 263
__attribute((always_inline)) inline int isnan(long double x) { return __isnanl(x); } 
# 265
__attribute((always_inline)) inline int isinf(float x) { return __isinff(x); } 
# 269
__attribute((always_inline)) inline int isinf(double x) throw() { return __isinf(x); } 
# 271
__attribute((always_inline)) inline int isinf(long double x) { return __isinfl(x); } 
# 462 "/usr/include/math_functions.hpp" 3
static inline float logb(float a) 
# 463
{ 
# 464
return logbf(a); 
# 465
} 
# 467
static inline int ilogb(float a) 
# 468
{ 
# 469
return ilogbf(a); 
# 470
} 
# 472
static inline float scalbn(float a, int b) 
# 473
{ 
# 474
return scalbnf(a, b); 
# 475
} 
# 477
static inline float scalbln(float a, long b) 
# 478
{ 
# 479
return scalblnf(a, b); 
# 480
} 
# 482
static inline float exp2(float a) 
# 483
{ 
# 484
return exp2f(a); 
# 485
} 
# 487
static inline float expm1(float a) 
# 488
{ 
# 489
return expm1f(a); 
# 490
} 
# 492
static inline float log2(float a) 
# 493
{ 
# 494
return log2f(a); 
# 495
} 
# 497
static inline float log1p(float a) 
# 498
{ 
# 499
return log1pf(a); 
# 500
} 
# 502
static inline float acosh(float a) 
# 503
{ 
# 504
return acoshf(a); 
# 505
} 
# 507
static inline float asinh(float a) 
# 508
{ 
# 509
return asinhf(a); 
# 510
} 
# 512
static inline float atanh(float a) 
# 513
{ 
# 514
return atanhf(a); 
# 515
} 
# 517
static inline float hypot(float a, float b) 
# 518
{ 
# 519
return hypotf(a, b); 
# 520
} 
# 522
static inline float norm3d(float a, float b, float c) 
# 523
{ 
# 524
return norm3df(a, b, c); 
# 525
} 
# 527
static inline float norm4d(float a, float b, float c, float d) 
# 528
{ 
# 529
return norm4df(a, b, c, d); 
# 530
} 
# 532
static inline float cbrt(float a) 
# 533
{ 
# 534
return cbrtf(a); 
# 535
} 
# 537
static inline float erf(float a) 
# 538
{ 
# 539
return erff(a); 
# 540
} 
# 542
static inline float erfc(float a) 
# 543
{ 
# 544
return erfcf(a); 
# 545
} 
# 547
static inline float lgamma(float a) 
# 548
{ 
# 549
return lgammaf(a); 
# 550
} 
# 552
static inline float tgamma(float a) 
# 553
{ 
# 554
return tgammaf(a); 
# 555
} 
# 557
static inline float copysign(float a, float b) 
# 558
{ 
# 559
return copysignf(a, b); 
# 560
} 
# 562
static inline float nextafter(float a, float b) 
# 563
{ 
# 564
return nextafterf(a, b); 
# 565
} 
# 567
static inline float remainder(float a, float b) 
# 568
{ 
# 569
return remainderf(a, b); 
# 570
} 
# 572
static inline float remquo(float a, float b, int *quo) 
# 573
{ 
# 574
return remquof(a, b, quo); 
# 575
} 
# 577
static inline float round(float a) 
# 578
{ 
# 579
return roundf(a); 
# 580
} 
# 582
static inline long lround(float a) 
# 583
{ 
# 584
return lroundf(a); 
# 585
} 
# 587
static inline long long llround(float a) 
# 588
{ 
# 589
return llroundf(a); 
# 590
} 
# 592
static inline float trunc(float a) 
# 593
{ 
# 594
return truncf(a); 
# 595
} 
# 597
static inline float rint(float a) 
# 598
{ 
# 599
return rintf(a); 
# 600
} 
# 602
static inline long lrint(float a) 
# 603
{ 
# 604
return lrintf(a); 
# 605
} 
# 607
static inline long long llrint(float a) 
# 608
{ 
# 609
return llrintf(a); 
# 610
} 
# 612
static inline float nearbyint(float a) 
# 613
{ 
# 614
return nearbyintf(a); 
# 615
} 
# 617
static inline float fdim(float a, float b) 
# 618
{ 
# 619
return fdimf(a, b); 
# 620
} 
# 622
static inline float fma(float a, float b, float c) 
# 623
{ 
# 624
return fmaf(a, b, c); 
# 625
} 
# 627
static inline float fmax(float a, float b) 
# 628
{ 
# 629
return fmaxf(a, b); 
# 630
} 
# 632
static inline float fmin(float a, float b) 
# 633
{ 
# 634
return fminf(a, b); 
# 635
} 
# 639
static inline float exp10(float a) 
# 640
{ 
# 641
return exp10f(a); 
# 642
} 
# 644
static inline float rsqrt(float a) 
# 645
{ 
# 646
return rsqrtf(a); 
# 647
} 
# 649
static inline float rcbrt(float a) 
# 650
{ 
# 651
return rcbrtf(a); 
# 652
} 
# 654
static inline float sinpi(float a) 
# 655
{ 
# 656
return sinpif(a); 
# 657
} 
# 659
static inline float cospi(float a) 
# 660
{ 
# 661
return cospif(a); 
# 662
} 
# 664
static inline void sincospi(float a, float *sptr, float *cptr) 
# 665
{ 
# 666
sincospif(a, sptr, cptr); 
# 667
} 
# 669
static inline void sincos(float a, float *sptr, float *cptr) 
# 670
{ 
# 671
sincosf(a, sptr, cptr); 
# 672
} 
# 674
static inline float j0(float a) 
# 675
{ 
# 676
return j0f(a); 
# 677
} 
# 679
static inline float j1(float a) 
# 680
{ 
# 681
return j1f(a); 
# 682
} 
# 684
static inline float jn(int n, float a) 
# 685
{ 
# 686
return jnf(n, a); 
# 687
} 
# 689
static inline float y0(float a) 
# 690
{ 
# 691
return y0f(a); 
# 692
} 
# 694
static inline float y1(float a) 
# 695
{ 
# 696
return y1f(a); 
# 697
} 
# 699
static inline float yn(int n, float a) 
# 700
{ 
# 701
return ynf(n, a); 
# 702
} 
# 704
static inline float cyl_bessel_i0(float a) 
# 705
{ 
# 706
return cyl_bessel_i0f(a); 
# 707
} 
# 709
static inline float cyl_bessel_i1(float a) 
# 710
{ 
# 711
return cyl_bessel_i1f(a); 
# 712
} 
# 714
static inline float erfinv(float a) 
# 715
{ 
# 716
return erfinvf(a); 
# 717
} 
# 719
static inline float erfcinv(float a) 
# 720
{ 
# 721
return erfcinvf(a); 
# 722
} 
# 724
static inline float normcdfinv(float a) 
# 725
{ 
# 726
return normcdfinvf(a); 
# 727
} 
# 729
static inline float normcdf(float a) 
# 730
{ 
# 731
return normcdff(a); 
# 732
} 
# 734
static inline float erfcx(float a) 
# 735
{ 
# 736
return erfcxf(a); 
# 737
} 
# 739
static inline double copysign(double a, float b) 
# 740
{ 
# 741
return copysign(a, (double)b); 
# 742
} 
# 744
static inline float copysign(float a, double b) 
# 745
{ 
# 746
return copysignf(a, (float)b); 
# 747
} 
# 749
static inline unsigned min(unsigned a, unsigned b) 
# 750
{ 
# 751
return umin(a, b); 
# 752
} 
# 754
static inline unsigned min(int a, unsigned b) 
# 755
{ 
# 756
return umin((unsigned)a, b); 
# 757
} 
# 759
static inline unsigned min(unsigned a, int b) 
# 760
{ 
# 761
return umin(a, (unsigned)b); 
# 762
} 
# 764
static inline long min(long a, long b) 
# 765
{ 
# 771
if (sizeof(long) == sizeof(int)) { 
# 775
return (long)min((int)a, (int)b); 
# 776
} else { 
# 777
return (long)llmin((long long)a, (long long)b); 
# 778
}  
# 779
} 
# 781
static inline unsigned long min(unsigned long a, unsigned long b) 
# 782
{ 
# 786
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 790
return (unsigned long)umin((unsigned)a, (unsigned)b); 
# 791
} else { 
# 792
return (unsigned long)ullmin((unsigned long long)a, (unsigned long long)b); 
# 793
}  
# 794
} 
# 796
static inline unsigned long min(long a, unsigned long b) 
# 797
{ 
# 801
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 805
return (unsigned long)umin((unsigned)a, (unsigned)b); 
# 806
} else { 
# 807
return (unsigned long)ullmin((unsigned long long)a, (unsigned long long)b); 
# 808
}  
# 809
} 
# 811
static inline unsigned long min(unsigned long a, long b) 
# 812
{ 
# 816
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 820
return (unsigned long)umin((unsigned)a, (unsigned)b); 
# 821
} else { 
# 822
return (unsigned long)ullmin((unsigned long long)a, (unsigned long long)b); 
# 823
}  
# 824
} 
# 826
static inline long long min(long long a, long long b) 
# 827
{ 
# 828
return llmin(a, b); 
# 829
} 
# 831
static inline unsigned long long min(unsigned long long a, unsigned long long b) 
# 832
{ 
# 833
return ullmin(a, b); 
# 834
} 
# 836
static inline unsigned long long min(long long a, unsigned long long b) 
# 837
{ 
# 838
return ullmin((unsigned long long)a, b); 
# 839
} 
# 841
static inline unsigned long long min(unsigned long long a, long long b) 
# 842
{ 
# 843
return ullmin(a, (unsigned long long)b); 
# 844
} 
# 846
static inline float min(float a, float b) 
# 847
{ 
# 848
return fminf(a, b); 
# 849
} 
# 851
static inline double min(double a, double b) 
# 852
{ 
# 853
return fmin(a, b); 
# 854
} 
# 856
static inline double min(float a, double b) 
# 857
{ 
# 858
return fmin((double)a, b); 
# 859
} 
# 861
static inline double min(double a, float b) 
# 862
{ 
# 863
return fmin(a, (double)b); 
# 864
} 
# 866
static inline unsigned max(unsigned a, unsigned b) 
# 867
{ 
# 868
return umax(a, b); 
# 869
} 
# 871
static inline unsigned max(int a, unsigned b) 
# 872
{ 
# 873
return umax((unsigned)a, b); 
# 874
} 
# 876
static inline unsigned max(unsigned a, int b) 
# 877
{ 
# 878
return umax(a, (unsigned)b); 
# 879
} 
# 881
static inline long max(long a, long b) 
# 882
{ 
# 887
if (sizeof(long) == sizeof(int)) { 
# 891
return (long)max((int)a, (int)b); 
# 892
} else { 
# 893
return (long)llmax((long long)a, (long long)b); 
# 894
}  
# 895
} 
# 897
static inline unsigned long max(unsigned long a, unsigned long b) 
# 898
{ 
# 902
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 906
return (unsigned long)umax((unsigned)a, (unsigned)b); 
# 907
} else { 
# 908
return (unsigned long)ullmax((unsigned long long)a, (unsigned long long)b); 
# 909
}  
# 910
} 
# 912
static inline unsigned long max(long a, unsigned long b) 
# 913
{ 
# 917
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 921
return (unsigned long)umax((unsigned)a, (unsigned)b); 
# 922
} else { 
# 923
return (unsigned long)ullmax((unsigned long long)a, (unsigned long long)b); 
# 924
}  
# 925
} 
# 927
static inline unsigned long max(unsigned long a, long b) 
# 928
{ 
# 932
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 936
return (unsigned long)umax((unsigned)a, (unsigned)b); 
# 937
} else { 
# 938
return (unsigned long)ullmax((unsigned long long)a, (unsigned long long)b); 
# 939
}  
# 940
} 
# 942
static inline long long max(long long a, long long b) 
# 943
{ 
# 944
return llmax(a, b); 
# 945
} 
# 947
static inline unsigned long long max(unsigned long long a, unsigned long long b) 
# 948
{ 
# 949
return ullmax(a, b); 
# 950
} 
# 952
static inline unsigned long long max(long long a, unsigned long long b) 
# 953
{ 
# 954
return ullmax((unsigned long long)a, b); 
# 955
} 
# 957
static inline unsigned long long max(unsigned long long a, long long b) 
# 958
{ 
# 959
return ullmax(a, (unsigned long long)b); 
# 960
} 
# 962
static inline float max(float a, float b) 
# 963
{ 
# 964
return fmaxf(a, b); 
# 965
} 
# 967
static inline double max(double a, double b) 
# 968
{ 
# 969
return fmax(a, b); 
# 970
} 
# 972
static inline double max(float a, double b) 
# 973
{ 
# 974
return fmax((double)a, b); 
# 975
} 
# 977
static inline double max(double a, float b) 
# 978
{ 
# 979
return fmax(a, (double)b); 
# 980
} 
# 991 "/usr/include/math_functions.hpp" 3
inline int min(int a, int b) 
# 992
{ 
# 993
return (a < b) ? a : b; 
# 994
} 
# 996
inline unsigned umin(unsigned a, unsigned b) 
# 997
{ 
# 998
return (a < b) ? a : b; 
# 999
} 
# 1001
inline long long llmin(long long a, long long b) 
# 1002
{ 
# 1003
return (a < b) ? a : b; 
# 1004
} 
# 1006
inline unsigned long long ullmin(unsigned long long a, unsigned long long 
# 1007
b) 
# 1008
{ 
# 1009
return (a < b) ? a : b; 
# 1010
} 
# 1012
inline int max(int a, int b) 
# 1013
{ 
# 1014
return (a > b) ? a : b; 
# 1015
} 
# 1017
inline unsigned umax(unsigned a, unsigned b) 
# 1018
{ 
# 1019
return (a > b) ? a : b; 
# 1020
} 
# 1022
inline long long llmax(long long a, long long b) 
# 1023
{ 
# 1024
return (a > b) ? a : b; 
# 1025
} 
# 1027
inline unsigned long long ullmax(unsigned long long a, unsigned long long 
# 1028
b) 
# 1029
{ 
# 1030
return (a > b) ? a : b; 
# 1031
} 
# 77 "/usr/include/cuda_surface_types.h" 3
template< class T, int dim = 1> 
# 78
struct surface : public surfaceReference { 
# 81
surface() 
# 82
{ 
# 83
(surfaceReference::channelDesc) = cudaCreateChannelDesc< T> (); 
# 84
} 
# 86
surface(cudaChannelFormatDesc desc) 
# 87
{ 
# 88
(surfaceReference::channelDesc) = desc; 
# 89
} 
# 91
}; 
# 93
template< int dim> 
# 94
struct surface< void, dim>  : public surfaceReference { 
# 97
surface() 
# 98
{ 
# 99
(surfaceReference::channelDesc) = cudaCreateChannelDesc< void> (); 
# 100
} 
# 102
}; 
# 77 "/usr/include/cuda_texture_types.h" 3
template< class T, int texType = 1, cudaTextureReadMode mode = cudaReadModeElementType> 
# 78
struct texture : public textureReference { 
# 81
texture(int norm = 0, cudaTextureFilterMode 
# 82
fMode = cudaFilterModePoint, cudaTextureAddressMode 
# 83
aMode = cudaAddressModeClamp) 
# 84
{ 
# 85
(textureReference::normalized) = norm; 
# 86
(textureReference::filterMode) = fMode; 
# 87
((textureReference::addressMode)[0]) = aMode; 
# 88
((textureReference::addressMode)[1]) = aMode; 
# 89
((textureReference::addressMode)[2]) = aMode; 
# 90
(textureReference::channelDesc) = cudaCreateChannelDesc< T> (); 
# 91
(textureReference::sRGB) = 0; 
# 92
} 
# 94
texture(int norm, cudaTextureFilterMode 
# 95
fMode, cudaTextureAddressMode 
# 96
aMode, cudaChannelFormatDesc 
# 97
desc) 
# 98
{ 
# 99
(textureReference::normalized) = norm; 
# 100
(textureReference::filterMode) = fMode; 
# 101
((textureReference::addressMode)[0]) = aMode; 
# 102
((textureReference::addressMode)[1]) = aMode; 
# 103
((textureReference::addressMode)[2]) = aMode; 
# 104
(textureReference::channelDesc) = desc; 
# 105
(textureReference::sRGB) = 0; 
# 106
} 
# 108
}; 
# 3230 "/usr/include/device_functions.h" 3
__attribute__((unused)) static inline int mulhi(int a, int b); 
# 3232
__attribute__((unused)) static inline unsigned mulhi(unsigned a, unsigned b); 
# 3234
__attribute__((unused)) static inline unsigned mulhi(int a, unsigned b); 
# 3236
__attribute__((unused)) static inline unsigned mulhi(unsigned a, int b); 
# 3238
__attribute__((unused)) static inline long long mul64hi(long long a, long long b); 
# 3240
__attribute__((unused)) static inline unsigned long long mul64hi(unsigned long long a, unsigned long long b); 
# 3242
__attribute__((unused)) static inline unsigned long long mul64hi(long long a, unsigned long long b); 
# 3244
__attribute__((unused)) static inline unsigned long long mul64hi(unsigned long long a, long long b); 
# 3246
__attribute__((unused)) static inline int float_as_int(float a); 
# 3248
__attribute__((unused)) static inline float int_as_float(int a); 
# 3250
__attribute__((unused)) static inline unsigned float_as_uint(float a); 
# 3252
__attribute__((unused)) static inline float uint_as_float(unsigned a); 
# 3254
__attribute__((unused)) static inline float saturate(float a); 
# 3256
__attribute__((unused)) static inline int mul24(int a, int b); 
# 3258
__attribute__((unused)) static inline unsigned umul24(unsigned a, unsigned b); 
# 3260
__attribute__((unused)) static inline void trap(); 
# 3263
__attribute__((unused)) static inline void brkpt(int c = 0); 
# 3265
__attribute__((unused)) static inline void syncthreads(); 
# 3267
__attribute__((unused)) static inline void prof_trigger(int e); 
# 3269
__attribute__((unused)) static inline void threadfence(bool global = true); 
# 3271
__attribute__((unused)) static inline int float2int(float a, cudaRoundMode mode = cudaRoundZero); 
# 3273
__attribute__((unused)) static inline unsigned float2uint(float a, cudaRoundMode mode = cudaRoundZero); 
# 3275
__attribute__((unused)) static inline float int2float(int a, cudaRoundMode mode = cudaRoundNearest); 
# 3277
__attribute__((unused)) static inline float uint2float(unsigned a, cudaRoundMode mode = cudaRoundNearest); 
# 83 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline int mulhi(int a, int b) 
# 84
{int volatile ___ = 1;(void)a;(void)b;
# 86
::exit(___);}
#if 0
# 84
{ 
# 85
return __mulhi(a, b); 
# 86
} 
#endif
# 88 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline unsigned mulhi(unsigned a, unsigned b) 
# 89
{int volatile ___ = 1;(void)a;(void)b;
# 91
::exit(___);}
#if 0
# 89
{ 
# 90
return __umulhi(a, b); 
# 91
} 
#endif
# 93 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline unsigned mulhi(int a, unsigned b) 
# 94
{int volatile ___ = 1;(void)a;(void)b;
# 96
::exit(___);}
#if 0
# 94
{ 
# 95
return __umulhi((unsigned)a, b); 
# 96
} 
#endif
# 98 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline unsigned mulhi(unsigned a, int b) 
# 99
{int volatile ___ = 1;(void)a;(void)b;
# 101
::exit(___);}
#if 0
# 99
{ 
# 100
return __umulhi(a, (unsigned)b); 
# 101
} 
#endif
# 103 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline long long mul64hi(long long a, long long b) 
# 104
{int volatile ___ = 1;(void)a;(void)b;
# 106
::exit(___);}
#if 0
# 104
{ 
# 105
return __mul64hi(a, b); 
# 106
} 
#endif
# 108 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline unsigned long long mul64hi(unsigned long long a, unsigned long long b) 
# 109
{int volatile ___ = 1;(void)a;(void)b;
# 111
::exit(___);}
#if 0
# 109
{ 
# 110
return __umul64hi(a, b); 
# 111
} 
#endif
# 113 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline unsigned long long mul64hi(long long a, unsigned long long b) 
# 114
{int volatile ___ = 1;(void)a;(void)b;
# 116
::exit(___);}
#if 0
# 114
{ 
# 115
return __umul64hi((unsigned long long)a, b); 
# 116
} 
#endif
# 118 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline unsigned long long mul64hi(unsigned long long a, long long b) 
# 119
{int volatile ___ = 1;(void)a;(void)b;
# 121
::exit(___);}
#if 0
# 119
{ 
# 120
return __umul64hi(a, (unsigned long long)b); 
# 121
} 
#endif
# 123 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline int float_as_int(float a) 
# 124
{int volatile ___ = 1;(void)a;
# 126
::exit(___);}
#if 0
# 124
{ 
# 125
return __float_as_int(a); 
# 126
} 
#endif
# 128 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline float int_as_float(int a) 
# 129
{int volatile ___ = 1;(void)a;
# 131
::exit(___);}
#if 0
# 129
{ 
# 130
return __int_as_float(a); 
# 131
} 
#endif
# 133 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline unsigned float_as_uint(float a) 
# 134
{int volatile ___ = 1;(void)a;
# 136
::exit(___);}
#if 0
# 134
{ 
# 135
return __float_as_uint(a); 
# 136
} 
#endif
# 138 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline float uint_as_float(unsigned a) 
# 139
{int volatile ___ = 1;(void)a;
# 141
::exit(___);}
#if 0
# 139
{ 
# 140
return __uint_as_float(a); 
# 141
} 
#endif
# 142 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline float saturate(float a) 
# 143
{int volatile ___ = 1;(void)a;
# 145
::exit(___);}
#if 0
# 143
{ 
# 144
return __saturatef(a); 
# 145
} 
#endif
# 147 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline int mul24(int a, int b) 
# 148
{int volatile ___ = 1;(void)a;(void)b;
# 150
::exit(___);}
#if 0
# 148
{ 
# 149
return __mul24(a, b); 
# 150
} 
#endif
# 152 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline unsigned umul24(unsigned a, unsigned b) 
# 153
{int volatile ___ = 1;(void)a;(void)b;
# 155
::exit(___);}
#if 0
# 153
{ 
# 154
return __umul24(a, b); 
# 155
} 
#endif
# 157 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline void trap() 
# 158
{int volatile ___ = 1;
# 160
::exit(___);}
#if 0
# 158
{ 
# 159
__trap(); 
# 160
} 
#endif
# 163 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline void brkpt(int c) 
# 164
{int volatile ___ = 1;(void)c;
# 166
::exit(___);}
#if 0
# 164
{ 
# 165
__brkpt(c); 
# 166
} 
#endif
# 168 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline void syncthreads() 
# 169
{int volatile ___ = 1;
# 171
::exit(___);}
#if 0
# 169
{ 
# 170
__syncthreads(); 
# 171
} 
#endif
# 173 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline void prof_trigger(int e) 
# 174
{int volatile ___ = 1;(void)e;
# 191
::exit(___);}
#if 0
# 174
{ 
# 175
if (e == 0) { __prof_trigger(0); } else { 
# 176
if (e == 1) { __prof_trigger(1); } else { 
# 177
if (e == 2) { __prof_trigger(2); } else { 
# 178
if (e == 3) { __prof_trigger(3); } else { 
# 179
if (e == 4) { __prof_trigger(4); } else { 
# 180
if (e == 5) { __prof_trigger(5); } else { 
# 181
if (e == 6) { __prof_trigger(6); } else { 
# 182
if (e == 7) { __prof_trigger(7); } else { 
# 183
if (e == 8) { __prof_trigger(8); } else { 
# 184
if (e == 9) { __prof_trigger(9); } else { 
# 185
if (e == 10) { __prof_trigger(10); } else { 
# 186
if (e == 11) { __prof_trigger(11); } else { 
# 187
if (e == 12) { __prof_trigger(12); } else { 
# 188
if (e == 13) { __prof_trigger(13); } else { 
# 189
if (e == 14) { __prof_trigger(14); } else { 
# 190
if (e == 15) { __prof_trigger(15); }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  
# 191
} 
#endif
# 193 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline void threadfence(bool global) 
# 194
{int volatile ___ = 1;(void)global;
# 196
::exit(___);}
#if 0
# 194
{ 
# 195
global ? __threadfence() : __threadfence_block(); 
# 196
} 
#endif
# 198 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline int float2int(float a, cudaRoundMode mode) 
# 199
{int volatile ___ = 1;(void)a;(void)mode;
# 204
::exit(___);}
#if 0
# 199
{ 
# 200
return (mode == (cudaRoundNearest)) ? __float2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2int_rd(a) : __float2int_rz(a))); 
# 204
} 
#endif
# 206 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline unsigned float2uint(float a, cudaRoundMode mode) 
# 207
{int volatile ___ = 1;(void)a;(void)mode;
# 212
::exit(___);}
#if 0
# 207
{ 
# 208
return (mode == (cudaRoundNearest)) ? __float2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2uint_rd(a) : __float2uint_rz(a))); 
# 212
} 
#endif
# 214 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline float int2float(int a, cudaRoundMode mode) 
# 215
{int volatile ___ = 1;(void)a;(void)mode;
# 220
::exit(___);}
#if 0
# 215
{ 
# 216
return (mode == (cudaRoundZero)) ? __int2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __int2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __int2float_rd(a) : __int2float_rn(a))); 
# 220
} 
#endif
# 222 "/usr/include/device_functions.hpp" 3
__attribute__((unused)) static inline float uint2float(unsigned a, cudaRoundMode mode) 
# 223
{int volatile ___ = 1;(void)a;(void)mode;
# 228
::exit(___);}
#if 0
# 223
{ 
# 224
return (mode == (cudaRoundZero)) ? __uint2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __uint2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __uint2float_rd(a) : __uint2float_rn(a))); 
# 228
} 
#endif
# 105 "/usr/include/device_atomic_functions.h" 3
__attribute__((unused)) static inline int atomicAdd(int * address, int val); 
# 107
__attribute__((unused)) static inline unsigned atomicAdd(unsigned * address, unsigned val); 
# 109
__attribute__((unused)) static inline int atomicSub(int * address, int val); 
# 111
__attribute__((unused)) static inline unsigned atomicSub(unsigned * address, unsigned val); 
# 113
__attribute__((unused)) static inline int atomicExch(int * address, int val); 
# 115
__attribute__((unused)) static inline unsigned atomicExch(unsigned * address, unsigned val); 
# 117
__attribute__((unused)) static inline float atomicExch(float * address, float val); 
# 119
__attribute__((unused)) static inline int atomicMin(int * address, int val); 
# 121
__attribute__((unused)) static inline unsigned atomicMin(unsigned * address, unsigned val); 
# 123
__attribute__((unused)) static inline int atomicMax(int * address, int val); 
# 125
__attribute__((unused)) static inline unsigned atomicMax(unsigned * address, unsigned val); 
# 127
__attribute__((unused)) static inline unsigned atomicInc(unsigned * address, unsigned val); 
# 129
__attribute__((unused)) static inline unsigned atomicDec(unsigned * address, unsigned val); 
# 131
__attribute__((unused)) static inline int atomicAnd(int * address, int val); 
# 133
__attribute__((unused)) static inline unsigned atomicAnd(unsigned * address, unsigned val); 
# 135
__attribute__((unused)) static inline int atomicOr(int * address, int val); 
# 137
__attribute__((unused)) static inline unsigned atomicOr(unsigned * address, unsigned val); 
# 139
__attribute__((unused)) static inline int atomicXor(int * address, int val); 
# 141
__attribute__((unused)) static inline unsigned atomicXor(unsigned * address, unsigned val); 
# 143
__attribute__((unused)) static inline int atomicCAS(int * address, int compare, int val); 
# 145
__attribute__((unused)) static inline unsigned atomicCAS(unsigned * address, unsigned compare, unsigned val); 
# 178 "/usr/include/device_atomic_functions.h" 3
__attribute__((unused)) static inline unsigned long long atomicAdd(unsigned long long * address, unsigned long long val); 
# 180
__attribute__((unused)) static inline unsigned long long atomicExch(unsigned long long * address, unsigned long long val); 
# 182
__attribute__((unused)) static inline unsigned long long atomicCAS(unsigned long long * address, unsigned long long compare, unsigned long long val); 
# 184
__attribute__((unused)) static inline bool any(bool cond); 
# 186
__attribute__((unused)) static inline bool all(bool cond); 
# 78 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline int atomicAdd(int *address, int val) 
# 79
{int volatile ___ = 1;(void)address;(void)val;
# 81
::exit(___);}
#if 0
# 79
{ 
# 80
return __iAtomicAdd(address, val); 
# 81
} 
#endif
# 83 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned atomicAdd(unsigned *address, unsigned val) 
# 84
{int volatile ___ = 1;(void)address;(void)val;
# 86
::exit(___);}
#if 0
# 84
{ 
# 85
return __uAtomicAdd(address, val); 
# 86
} 
#endif
# 88 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline int atomicSub(int *address, int val) 
# 89
{int volatile ___ = 1;(void)address;(void)val;
# 91
::exit(___);}
#if 0
# 89
{ 
# 90
return __iAtomicAdd(address, (unsigned)(-((int)val))); 
# 91
} 
#endif
# 93 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned atomicSub(unsigned *address, unsigned val) 
# 94
{int volatile ___ = 1;(void)address;(void)val;
# 96
::exit(___);}
#if 0
# 94
{ 
# 95
return __uAtomicAdd(address, (unsigned)(-((int)val))); 
# 96
} 
#endif
# 98 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline int atomicExch(int *address, int val) 
# 99
{int volatile ___ = 1;(void)address;(void)val;
# 101
::exit(___);}
#if 0
# 99
{ 
# 100
return __iAtomicExch(address, val); 
# 101
} 
#endif
# 103 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned atomicExch(unsigned *address, unsigned val) 
# 104
{int volatile ___ = 1;(void)address;(void)val;
# 106
::exit(___);}
#if 0
# 104
{ 
# 105
return __uAtomicExch(address, val); 
# 106
} 
#endif
# 108 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline float atomicExch(float *address, float val) 
# 109
{int volatile ___ = 1;(void)address;(void)val;
# 111
::exit(___);}
#if 0
# 109
{ 
# 110
return __fAtomicExch(address, val); 
# 111
} 
#endif
# 113 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline int atomicMin(int *address, int val) 
# 114
{int volatile ___ = 1;(void)address;(void)val;
# 116
::exit(___);}
#if 0
# 114
{ 
# 115
return __iAtomicMin(address, val); 
# 116
} 
#endif
# 118 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned atomicMin(unsigned *address, unsigned val) 
# 119
{int volatile ___ = 1;(void)address;(void)val;
# 121
::exit(___);}
#if 0
# 119
{ 
# 120
return __uAtomicMin(address, val); 
# 121
} 
#endif
# 123 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline int atomicMax(int *address, int val) 
# 124
{int volatile ___ = 1;(void)address;(void)val;
# 126
::exit(___);}
#if 0
# 124
{ 
# 125
return __iAtomicMax(address, val); 
# 126
} 
#endif
# 128 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned atomicMax(unsigned *address, unsigned val) 
# 129
{int volatile ___ = 1;(void)address;(void)val;
# 131
::exit(___);}
#if 0
# 129
{ 
# 130
return __uAtomicMax(address, val); 
# 131
} 
#endif
# 133 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned atomicInc(unsigned *address, unsigned val) 
# 134
{int volatile ___ = 1;(void)address;(void)val;
# 136
::exit(___);}
#if 0
# 134
{ 
# 135
return __uAtomicInc(address, val); 
# 136
} 
#endif
# 138 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned atomicDec(unsigned *address, unsigned val) 
# 139
{int volatile ___ = 1;(void)address;(void)val;
# 141
::exit(___);}
#if 0
# 139
{ 
# 140
return __uAtomicDec(address, val); 
# 141
} 
#endif
# 143 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline int atomicAnd(int *address, int val) 
# 144
{int volatile ___ = 1;(void)address;(void)val;
# 146
::exit(___);}
#if 0
# 144
{ 
# 145
return __iAtomicAnd(address, val); 
# 146
} 
#endif
# 148 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned atomicAnd(unsigned *address, unsigned val) 
# 149
{int volatile ___ = 1;(void)address;(void)val;
# 151
::exit(___);}
#if 0
# 149
{ 
# 150
return __uAtomicAnd(address, val); 
# 151
} 
#endif
# 153 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline int atomicOr(int *address, int val) 
# 154
{int volatile ___ = 1;(void)address;(void)val;
# 156
::exit(___);}
#if 0
# 154
{ 
# 155
return __iAtomicOr(address, val); 
# 156
} 
#endif
# 158 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned atomicOr(unsigned *address, unsigned val) 
# 159
{int volatile ___ = 1;(void)address;(void)val;
# 161
::exit(___);}
#if 0
# 159
{ 
# 160
return __uAtomicOr(address, val); 
# 161
} 
#endif
# 163 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline int atomicXor(int *address, int val) 
# 164
{int volatile ___ = 1;(void)address;(void)val;
# 166
::exit(___);}
#if 0
# 164
{ 
# 165
return __iAtomicXor(address, val); 
# 166
} 
#endif
# 168 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned atomicXor(unsigned *address, unsigned val) 
# 169
{int volatile ___ = 1;(void)address;(void)val;
# 171
::exit(___);}
#if 0
# 169
{ 
# 170
return __uAtomicXor(address, val); 
# 171
} 
#endif
# 173 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline int atomicCAS(int *address, int compare, int val) 
# 174
{int volatile ___ = 1;(void)address;(void)compare;(void)val;
# 176
::exit(___);}
#if 0
# 174
{ 
# 175
return __iAtomicCAS(address, compare, val); 
# 176
} 
#endif
# 178 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned atomicCAS(unsigned *address, unsigned compare, unsigned val) 
# 179
{int volatile ___ = 1;(void)address;(void)compare;(void)val;
# 181
::exit(___);}
#if 0
# 179
{ 
# 180
return __uAtomicCAS(address, compare, val); 
# 181
} 
#endif
# 201 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned long long atomicAdd(unsigned long long *address, unsigned long long val) 
# 202
{int volatile ___ = 1;(void)address;(void)val;
# 204
::exit(___);}
#if 0
# 202
{ 
# 203
return __ullAtomicAdd(address, val); 
# 204
} 
#endif
# 206 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned long long atomicExch(unsigned long long *address, unsigned long long val) 
# 207
{int volatile ___ = 1;(void)address;(void)val;
# 209
::exit(___);}
#if 0
# 207
{ 
# 208
return __ullAtomicExch(address, val); 
# 209
} 
#endif
# 211 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned long long atomicCAS(unsigned long long *address, unsigned long long compare, unsigned long long val) 
# 212
{int volatile ___ = 1;(void)address;(void)compare;(void)val;
# 214
::exit(___);}
#if 0
# 212
{ 
# 213
return __ullAtomicCAS(address, compare, val); 
# 214
} 
#endif
# 216 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline bool any(bool cond) 
# 217
{int volatile ___ = 1;(void)cond;
# 219
::exit(___);}
#if 0
# 217
{ 
# 218
return (bool)__any((int)cond); 
# 219
} 
#endif
# 221 "/usr/include/device_atomic_functions.hpp" 3
__attribute__((unused)) static inline bool all(bool cond) 
# 222
{int volatile ___ = 1;(void)cond;
# 224
::exit(___);}
#if 0
# 222
{ 
# 223
return (bool)__all((int)cond); 
# 224
} 
#endif
# 1143 "/usr/include/device_double_functions.h" 3
__attribute__((unused)) static inline double fma(double a, double b, double c, cudaRoundMode mode); 
# 1145
__attribute__((unused)) static inline double dmul(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
# 1147
__attribute__((unused)) static inline double dadd(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
# 1149
__attribute__((unused)) static inline double dsub(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
# 1151
__attribute__((unused)) static inline int double2int(double a, cudaRoundMode mode = cudaRoundZero); 
# 1153
__attribute__((unused)) static inline unsigned double2uint(double a, cudaRoundMode mode = cudaRoundZero); 
# 1155
__attribute__((unused)) static inline long long double2ll(double a, cudaRoundMode mode = cudaRoundZero); 
# 1157
__attribute__((unused)) static inline unsigned long long double2ull(double a, cudaRoundMode mode = cudaRoundZero); 
# 1159
__attribute__((unused)) static inline double ll2double(long long a, cudaRoundMode mode = cudaRoundNearest); 
# 1161
__attribute__((unused)) static inline double ull2double(unsigned long long a, cudaRoundMode mode = cudaRoundNearest); 
# 1163
__attribute__((unused)) static inline double int2double(int a, cudaRoundMode mode = cudaRoundNearest); 
# 1165
__attribute__((unused)) static inline double uint2double(unsigned a, cudaRoundMode mode = cudaRoundNearest); 
# 1167
__attribute__((unused)) static inline double float2double(float a, cudaRoundMode mode = cudaRoundNearest); 
# 85 "/usr/include/device_double_functions.hpp" 3
__attribute__((unused)) static inline double fma(double a, double b, double c, cudaRoundMode mode) 
# 86
{int volatile ___ = 1;(void)a;(void)b;(void)c;(void)mode;
# 91
::exit(___);}
#if 0
# 86
{ 
# 87
return (mode == (cudaRoundZero)) ? __fma_rz(a, b, c) : ((mode == (cudaRoundPosInf)) ? __fma_ru(a, b, c) : ((mode == (cudaRoundMinInf)) ? __fma_rd(a, b, c) : __fma_rn(a, b, c))); 
# 91
} 
#endif
# 93 "/usr/include/device_double_functions.hpp" 3
__attribute__((unused)) static inline double dmul(double a, double b, cudaRoundMode mode) 
# 94
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
# 99
::exit(___);}
#if 0
# 94
{ 
# 95
return (mode == (cudaRoundZero)) ? __dmul_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dmul_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dmul_rd(a, b) : __dmul_rn(a, b))); 
# 99
} 
#endif
# 101 "/usr/include/device_double_functions.hpp" 3
__attribute__((unused)) static inline double dadd(double a, double b, cudaRoundMode mode) 
# 102
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
# 107
::exit(___);}
#if 0
# 102
{ 
# 103
return (mode == (cudaRoundZero)) ? __dadd_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dadd_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dadd_rd(a, b) : __dadd_rn(a, b))); 
# 107
} 
#endif
# 109 "/usr/include/device_double_functions.hpp" 3
__attribute__((unused)) static inline double dsub(double a, double b, cudaRoundMode mode) 
# 110
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
# 115
::exit(___);}
#if 0
# 110
{ 
# 111
return (mode == (cudaRoundZero)) ? __dsub_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dsub_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dsub_rd(a, b) : __dsub_rn(a, b))); 
# 115
} 
#endif
# 117 "/usr/include/device_double_functions.hpp" 3
__attribute__((unused)) static inline int double2int(double a, cudaRoundMode mode) 
# 118
{int volatile ___ = 1;(void)a;(void)mode;
# 123
::exit(___);}
#if 0
# 118
{ 
# 119
return (mode == (cudaRoundNearest)) ? __double2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2int_rd(a) : __double2int_rz(a))); 
# 123
} 
#endif
# 125 "/usr/include/device_double_functions.hpp" 3
__attribute__((unused)) static inline unsigned double2uint(double a, cudaRoundMode mode) 
# 126
{int volatile ___ = 1;(void)a;(void)mode;
# 131
::exit(___);}
#if 0
# 126
{ 
# 127
return (mode == (cudaRoundNearest)) ? __double2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2uint_rd(a) : __double2uint_rz(a))); 
# 131
} 
#endif
# 133 "/usr/include/device_double_functions.hpp" 3
__attribute__((unused)) static inline long long double2ll(double a, cudaRoundMode mode) 
# 134
{int volatile ___ = 1;(void)a;(void)mode;
# 139
::exit(___);}
#if 0
# 134
{ 
# 135
return (mode == (cudaRoundNearest)) ? __double2ll_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ll_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ll_rd(a) : __double2ll_rz(a))); 
# 139
} 
#endif
# 141 "/usr/include/device_double_functions.hpp" 3
__attribute__((unused)) static inline unsigned long long double2ull(double a, cudaRoundMode mode) 
# 142
{int volatile ___ = 1;(void)a;(void)mode;
# 147
::exit(___);}
#if 0
# 142
{ 
# 143
return (mode == (cudaRoundNearest)) ? __double2ull_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ull_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ull_rd(a) : __double2ull_rz(a))); 
# 147
} 
#endif
# 149 "/usr/include/device_double_functions.hpp" 3
__attribute__((unused)) static inline double ll2double(long long a, cudaRoundMode mode) 
# 150
{int volatile ___ = 1;(void)a;(void)mode;
# 155
::exit(___);}
#if 0
# 150
{ 
# 151
return (mode == (cudaRoundZero)) ? __ll2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ll2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ll2double_rd(a) : __ll2double_rn(a))); 
# 155
} 
#endif
# 157 "/usr/include/device_double_functions.hpp" 3
__attribute__((unused)) static inline double ull2double(unsigned long long a, cudaRoundMode mode) 
# 158
{int volatile ___ = 1;(void)a;(void)mode;
# 163
::exit(___);}
#if 0
# 158
{ 
# 159
return (mode == (cudaRoundZero)) ? __ull2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ull2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ull2double_rd(a) : __ull2double_rn(a))); 
# 163
} 
#endif
# 165 "/usr/include/device_double_functions.hpp" 3
__attribute__((unused)) static inline double int2double(int a, cudaRoundMode mode) 
# 166
{int volatile ___ = 1;(void)a;(void)mode;
# 168
::exit(___);}
#if 0
# 166
{ 
# 167
return (double)a; 
# 168
} 
#endif
# 170 "/usr/include/device_double_functions.hpp" 3
__attribute__((unused)) static inline double uint2double(unsigned a, cudaRoundMode mode) 
# 171
{int volatile ___ = 1;(void)a;(void)mode;
# 173
::exit(___);}
#if 0
# 171
{ 
# 172
return (double)a; 
# 173
} 
#endif
# 175 "/usr/include/device_double_functions.hpp" 3
__attribute__((unused)) static inline double float2double(float a, cudaRoundMode mode) 
# 176
{int volatile ___ = 1;(void)a;(void)mode;
# 178
::exit(___);}
#if 0
# 176
{ 
# 177
return (double)a; 
# 178
} 
#endif
# 85 "/usr/include/sm_20_atomic_functions.h" 3
__attribute__((unused)) static inline float atomicAdd(float * address, float val); 
# 76 "/usr/include/sm_20_atomic_functions.hpp" 3
__attribute__((unused)) static inline float atomicAdd(float *address, float val) 
# 77
{int volatile ___ = 1;(void)address;(void)val;
# 79
::exit(___);}
#if 0
# 77
{ 
# 78
return __fAtomicAdd(address, val); 
# 79
} 
#endif
# 93 "/usr/include/sm_32_atomic_functions.h" 3
__attribute__((unused)) static inline long long atomicMin(long long * address, long long val); 
# 95
__attribute__((unused)) static inline long long atomicMax(long long * address, long long val); 
# 97
__attribute__((unused)) static inline unsigned long long atomicMin(unsigned long long * address, unsigned long long val); 
# 99
__attribute__((unused)) static inline unsigned long long atomicMax(unsigned long long * address, unsigned long long val); 
# 101
__attribute__((unused)) static inline unsigned long long atomicAnd(unsigned long long * address, unsigned long long val); 
# 103
__attribute__((unused)) static inline unsigned long long atomicOr(unsigned long long * address, unsigned long long val); 
# 105
__attribute__((unused)) static inline unsigned long long atomicXor(unsigned long long * address, unsigned long long val); 
# 78 "/usr/include/sm_32_atomic_functions.hpp" 3
__attribute__((unused)) static inline long long atomicMin(long long *address, long long val) 
# 79
{int volatile ___ = 1;(void)address;(void)val;
# 81
::exit(___);}
#if 0
# 79
{ 
# 80
return __illAtomicMin(address, val); 
# 81
} 
#endif
# 83 "/usr/include/sm_32_atomic_functions.hpp" 3
__attribute__((unused)) static inline long long atomicMax(long long *address, long long val) 
# 84
{int volatile ___ = 1;(void)address;(void)val;
# 86
::exit(___);}
#if 0
# 84
{ 
# 85
return __illAtomicMax(address, val); 
# 86
} 
#endif
# 88 "/usr/include/sm_32_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned long long atomicMin(unsigned long long *address, unsigned long long val) 
# 89
{int volatile ___ = 1;(void)address;(void)val;
# 91
::exit(___);}
#if 0
# 89
{ 
# 90
return __ullAtomicMin(address, val); 
# 91
} 
#endif
# 93 "/usr/include/sm_32_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned long long atomicMax(unsigned long long *address, unsigned long long val) 
# 94
{int volatile ___ = 1;(void)address;(void)val;
# 96
::exit(___);}
#if 0
# 94
{ 
# 95
return __ullAtomicMax(address, val); 
# 96
} 
#endif
# 98 "/usr/include/sm_32_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned long long atomicAnd(unsigned long long *address, unsigned long long val) 
# 99
{int volatile ___ = 1;(void)address;(void)val;
# 101
::exit(___);}
#if 0
# 99
{ 
# 100
return __ullAtomicAnd(address, val); 
# 101
} 
#endif
# 103 "/usr/include/sm_32_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned long long atomicOr(unsigned long long *address, unsigned long long val) 
# 104
{int volatile ___ = 1;(void)address;(void)val;
# 106
::exit(___);}
#if 0
# 104
{ 
# 105
return __ullAtomicOr(address, val); 
# 106
} 
#endif
# 108 "/usr/include/sm_32_atomic_functions.hpp" 3
__attribute__((unused)) static inline unsigned long long atomicXor(unsigned long long *address, unsigned long long val) 
# 109
{int volatile ___ = 1;(void)address;(void)val;
# 111
::exit(___);}
#if 0
# 109
{ 
# 110
return __ullAtomicXor(address, val); 
# 111
} 
#endif
# 1468 "/usr/include/sm_20_intrinsics.h" 3
__attribute__((unused)) static inline unsigned ballot(bool pred); 
# 1470
__attribute__((unused)) static inline int syncthreads_count(bool pred); 
# 1472
__attribute__((unused)) static inline bool syncthreads_and(bool pred); 
# 1474
__attribute__((unused)) static inline bool syncthreads_or(bool pred); 
# 1479
__attribute__((unused)) static inline unsigned __isGlobal(const void * ptr); 
# 77 "/usr/include/sm_20_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned ballot(bool pred) 
# 78
{int volatile ___ = 1;(void)pred;
# 80
::exit(___);}
#if 0
# 78
{ 
# 79
return __ballot((int)pred); 
# 80
} 
#endif
# 82 "/usr/include/sm_20_intrinsics.hpp" 3
__attribute__((unused)) static inline int syncthreads_count(bool pred) 
# 83
{int volatile ___ = 1;(void)pred;
# 85
::exit(___);}
#if 0
# 83
{ 
# 84
return __syncthreads_count((int)pred); 
# 85
} 
#endif
# 87 "/usr/include/sm_20_intrinsics.hpp" 3
__attribute__((unused)) static inline bool syncthreads_and(bool pred) 
# 88
{int volatile ___ = 1;(void)pred;
# 90
::exit(___);}
#if 0
# 88
{ 
# 89
return (bool)__syncthreads_and((int)pred); 
# 90
} 
#endif
# 92 "/usr/include/sm_20_intrinsics.hpp" 3
__attribute__((unused)) static inline bool syncthreads_or(bool pred) 
# 93
{int volatile ___ = 1;(void)pred;
# 95
::exit(___);}
#if 0
# 93
{ 
# 94
return (bool)__syncthreads_or((int)pred); 
# 95
} 
#endif
# 100 "/usr/include/sm_20_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned __isGlobal(const void *ptr) 
# 101
{int volatile ___ = 1;(void)ptr;
# 114
::exit(___);}
#if 0
# 101
{ 
# 102
unsigned ret; 
# 103
__asm__ volatile("{ \n\t    .reg .pred p; \n\t    isspacep.global p, %1; \n\t    selp.u32 %0, 1, 0, p;  \n\t} \n\t" : "=r" (ret) : "l" (ptr)); 
# 113
return ret; 
# 114
} 
#endif
# 91 "/usr/include/sm_30_intrinsics.h" 3
__attribute__((unused)) static inline int __shfl(int var, int srcLane, int width = 32); 
# 93
__attribute__((unused)) static inline unsigned __shfl(unsigned var, int srcLane, int width = 32); 
# 95
__attribute__((unused)) static inline int __shfl_up(int var, unsigned delta, int width = 32); 
# 96
__attribute__((unused)) static inline unsigned __shfl_up(unsigned var, unsigned delta, int width = 32); 
# 98
__attribute__((unused)) static inline int __shfl_down(int var, unsigned delta, int width = 32); 
# 100
__attribute__((unused)) static inline unsigned __shfl_down(unsigned var, unsigned delta, int width = 32); 
# 102
__attribute__((unused)) static inline int __shfl_xor(int var, int laneMask, int width = 32); 
# 104
__attribute__((unused)) static inline unsigned __shfl_xor(unsigned var, int laneMask, int width = 32); 
# 106
__attribute__((unused)) static inline float __shfl(float var, int srcLane, int width = 32); 
# 108
__attribute__((unused)) static inline float __shfl_up(float var, unsigned delta, int width = 32); 
# 110
__attribute__((unused)) static inline float __shfl_down(float var, unsigned delta, int width = 32); 
# 112
__attribute__((unused)) static inline float __shfl_xor(float var, int laneMask, int width = 32); 
# 115
__attribute__((unused)) static inline long long __shfl(long long var, int srcLane, int width = 32); 
# 117
__attribute__((unused)) static inline unsigned long long __shfl(unsigned long long var, int srcLane, int width = 32); 
# 119
__attribute__((unused)) static inline long long __shfl_up(long long var, unsigned delta, int width = 32); 
# 121
__attribute__((unused)) static inline unsigned long long __shfl_up(unsigned long long var, unsigned delta, int width = 32); 
# 123
__attribute__((unused)) static inline long long __shfl_down(long long var, unsigned delta, int width = 32); 
# 125
__attribute__((unused)) static inline unsigned long long __shfl_down(unsigned long long var, unsigned delta, int width = 32); 
# 127
__attribute__((unused)) static inline long long __shfl_xor(long long var, int laneMask, int width = 32); 
# 129
__attribute__((unused)) static inline unsigned long long __shfl_xor(unsigned long long var, int laneMask, int width = 32); 
# 131
__attribute__((unused)) static inline double __shfl(double var, int srcLane, int width = 32); 
# 133
__attribute__((unused)) static inline double __shfl_up(double var, unsigned delta, int width = 32); 
# 135
__attribute__((unused)) static inline double __shfl_down(double var, unsigned delta, int width = 32); 
# 137
__attribute__((unused)) static inline double __shfl_xor(double var, int laneMask, int width = 32); 
# 141
__attribute__((unused)) static inline long __shfl(long var, int srcLane, int width = 32); 
# 143
__attribute__((unused)) static inline unsigned long __shfl(unsigned long var, int srcLane, int width = 32); 
# 145
__attribute__((unused)) static inline long __shfl_up(long var, unsigned delta, int width = 32); 
# 147
__attribute__((unused)) static inline unsigned long __shfl_up(unsigned long var, unsigned delta, int width = 32); 
# 149
__attribute__((unused)) static inline long __shfl_down(long var, unsigned delta, int width = 32); 
# 151
__attribute__((unused)) static inline unsigned long __shfl_down(unsigned long var, unsigned delta, int width = 32); 
# 153
__attribute__((unused)) static inline long __shfl_xor(long var, int laneMask, int width = 32); 
# 155
__attribute__((unused)) static inline unsigned long __shfl_xor(unsigned long var, int laneMask, int width = 32); 
# 99 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline int __shfl(int var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
# 104
::exit(___);}
#if 0
# 99
{ 
# 100
int ret; 
# 101
int c = ((32 - width) << 8) | 31; 
# 102
__asm__ volatile("shfl.idx.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (var), "r" (srcLane), "r" (c)); 
# 103
return ret; 
# 104
} 
#endif
# 106 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned __shfl(unsigned var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
# 108
::exit(___);}
#if 0
# 106
{ 
# 107
return (unsigned)__shfl((int)var, srcLane, width); 
# 108
} 
#endif
# 110 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline int __shfl_up(int var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 115
::exit(___);}
#if 0
# 110
{ 
# 111
int ret; 
# 112
int c = (32 - width) << 8; 
# 113
__asm__ volatile("shfl.up.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (var), "r" (delta), "r" (c)); 
# 114
return ret; 
# 115
} 
#endif
# 116 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned __shfl_up(unsigned var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 118
::exit(___);}
#if 0
# 116
{ 
# 117
return (unsigned)__shfl_up((int)var, delta, width); 
# 118
} 
#endif
# 120 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline int __shfl_down(int var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 125
::exit(___);}
#if 0
# 120
{ 
# 121
int ret; 
# 122
int c = ((32 - width) << 8) | 31; 
# 123
__asm__ volatile("shfl.down.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (var), "r" (delta), "r" (c)); 
# 124
return ret; 
# 125
} 
#endif
# 127 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned __shfl_down(unsigned var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 129
::exit(___);}
#if 0
# 127
{ 
# 128
return (unsigned)__shfl_down((int)var, delta, width); 
# 129
} 
#endif
# 131 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline int __shfl_xor(int var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
# 136
::exit(___);}
#if 0
# 131
{ 
# 132
int ret; 
# 133
int c = ((32 - width) << 8) | 31; 
# 134
__asm__ volatile("shfl.bfly.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (var), "r" (laneMask), "r" (c)); 
# 135
return ret; 
# 136
} 
#endif
# 138 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned __shfl_xor(unsigned var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
# 140
::exit(___);}
#if 0
# 138
{ 
# 139
return (unsigned)__shfl_xor((int)var, laneMask, width); 
# 140
} 
#endif
# 142 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline float __shfl(float var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
# 148
::exit(___);}
#if 0
# 142
{ 
# 143
float ret; 
# 144
int c; 
# 145
c = (((32 - width) << 8) | 31); 
# 146
__asm__ volatile("shfl.idx.b32 %0, %1, %2, %3;" : "=f" (ret) : "f" (var), "r" (srcLane), "r" (c)); 
# 147
return ret; 
# 148
} 
#endif
# 150 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline float __shfl_up(float var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 156
::exit(___);}
#if 0
# 150
{ 
# 151
float ret; 
# 152
int c; 
# 153
c = ((32 - width) << 8); 
# 154
__asm__ volatile("shfl.up.b32 %0, %1, %2, %3;" : "=f" (ret) : "f" (var), "r" (delta), "r" (c)); 
# 155
return ret; 
# 156
} 
#endif
# 158 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline float __shfl_down(float var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 164
::exit(___);}
#if 0
# 158
{ 
# 159
float ret; 
# 160
int c; 
# 161
c = (((32 - width) << 8) | 31); 
# 162
__asm__ volatile("shfl.down.b32 %0, %1, %2, %3;" : "=f" (ret) : "f" (var), "r" (delta), "r" (c)); 
# 163
return ret; 
# 164
} 
#endif
# 166 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline float __shfl_xor(float var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
# 172
::exit(___);}
#if 0
# 166
{ 
# 167
float ret; 
# 168
int c; 
# 169
c = (((32 - width) << 8) | 31); 
# 170
__asm__ volatile("shfl.bfly.b32 %0, %1, %2, %3;" : "=f" (ret) : "f" (var), "r" (laneMask), "r" (c)); 
# 171
return ret; 
# 172
} 
#endif
# 175 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline long long __shfl(long long var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
# 182
::exit(___);}
#if 0
# 175
{ 
# 176
int lo, hi; 
# 177
__asm__ volatile("mov.b64 {%0,%1}, %2;" : "=r" (lo), "=r" (hi) : "l" (var)); 
# 178
hi = __shfl(hi, srcLane, width); 
# 179
lo = __shfl(lo, srcLane, width); 
# 180
__asm__ volatile("mov.b64 %0, {%1,%2};" : "=l" (var) : "r" (lo), "r" (hi)); 
# 181
return var; 
# 182
} 
#endif
# 184 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned long long __shfl(unsigned long long var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
# 186
::exit(___);}
#if 0
# 184
{ 
# 185
return (unsigned long long)__shfl((long long)var, srcLane, width); 
# 186
} 
#endif
# 188 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline long long __shfl_up(long long var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 195
::exit(___);}
#if 0
# 188
{ 
# 189
int lo, hi; 
# 190
__asm__ volatile("mov.b64 {%0,%1}, %2;" : "=r" (lo), "=r" (hi) : "l" (var)); 
# 191
hi = __shfl_up(hi, delta, width); 
# 192
lo = __shfl_up(lo, delta, width); 
# 193
__asm__ volatile("mov.b64 %0, {%1,%2};" : "=l" (var) : "r" (lo), "r" (hi)); 
# 194
return var; 
# 195
} 
#endif
# 197 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned long long __shfl_up(unsigned long long var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 199
::exit(___);}
#if 0
# 197
{ 
# 198
return (unsigned long long)__shfl_up((long long)var, delta, width); 
# 199
} 
#endif
# 201 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline long long __shfl_down(long long var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 208
::exit(___);}
#if 0
# 201
{ 
# 202
int lo, hi; 
# 203
__asm__ volatile("mov.b64 {%0,%1}, %2;" : "=r" (lo), "=r" (hi) : "l" (var)); 
# 204
hi = __shfl_down(hi, delta, width); 
# 205
lo = __shfl_down(lo, delta, width); 
# 206
__asm__ volatile("mov.b64 %0, {%1,%2};" : "=l" (var) : "r" (lo), "r" (hi)); 
# 207
return var; 
# 208
} 
#endif
# 210 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned long long __shfl_down(unsigned long long var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 212
::exit(___);}
#if 0
# 210
{ 
# 211
return (unsigned long long)__shfl_down((long long)var, delta, width); 
# 212
} 
#endif
# 214 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline long long __shfl_xor(long long var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
# 221
::exit(___);}
#if 0
# 214
{ 
# 215
int lo, hi; 
# 216
__asm__ volatile("mov.b64 {%0,%1}, %2;" : "=r" (lo), "=r" (hi) : "l" (var)); 
# 217
hi = __shfl_xor(hi, laneMask, width); 
# 218
lo = __shfl_xor(lo, laneMask, width); 
# 219
__asm__ volatile("mov.b64 %0, {%1,%2};" : "=l" (var) : "r" (lo), "r" (hi)); 
# 220
return var; 
# 221
} 
#endif
# 223 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned long long __shfl_xor(unsigned long long var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
# 225
::exit(___);}
#if 0
# 223
{ 
# 224
return (unsigned long long)__shfl_xor((long long)var, laneMask, width); 
# 225
} 
#endif
# 227 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline double __shfl(double var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
# 234
::exit(___);}
#if 0
# 227
{ 
# 228
float lo, hi; 
# 229
__asm__ volatile("mov.b64 {%0,%1}, %2;" : "=f" (lo), "=f" (hi) : "d" (var)); 
# 230
hi = __shfl(hi, srcLane, width); 
# 231
lo = __shfl(lo, srcLane, width); 
# 232
__asm__ volatile("mov.b64 %0, {%1,%2};" : "=d" (var) : "f" (lo), "f" (hi)); 
# 233
return var; 
# 234
} 
#endif
# 236 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline double __shfl_up(double var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 243
::exit(___);}
#if 0
# 236
{ 
# 237
float lo, hi; 
# 238
__asm__ volatile("mov.b64 {%0,%1}, %2;" : "=f" (lo), "=f" (hi) : "d" (var)); 
# 239
hi = __shfl_up(hi, delta, width); 
# 240
lo = __shfl_up(lo, delta, width); 
# 241
__asm__ volatile("mov.b64 %0, {%1,%2};" : "=d" (var) : "f" (lo), "f" (hi)); 
# 242
return var; 
# 243
} 
#endif
# 245 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline double __shfl_down(double var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 252
::exit(___);}
#if 0
# 245
{ 
# 246
float lo, hi; 
# 247
__asm__ volatile("mov.b64 {%0,%1}, %2;" : "=f" (lo), "=f" (hi) : "d" (var)); 
# 248
hi = __shfl_down(hi, delta, width); 
# 249
lo = __shfl_down(lo, delta, width); 
# 250
__asm__ volatile("mov.b64 %0, {%1,%2};" : "=d" (var) : "f" (lo), "f" (hi)); 
# 251
return var; 
# 252
} 
#endif
# 254 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline double __shfl_xor(double var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
# 261
::exit(___);}
#if 0
# 254
{ 
# 255
float lo, hi; 
# 256
__asm__ volatile("mov.b64 {%0,%1}, %2;" : "=f" (lo), "=f" (hi) : "d" (var)); 
# 257
hi = __shfl_xor(hi, laneMask, width); 
# 258
lo = __shfl_xor(lo, laneMask, width); 
# 259
__asm__ volatile("mov.b64 %0, {%1,%2};" : "=d" (var) : "f" (lo), "f" (hi)); 
# 260
return var; 
# 261
} 
#endif
# 265 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline long __shfl(long var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
# 269
::exit(___);}
#if 0
# 265
{ 
# 266
return (sizeof(long) == sizeof(long long)) ? __shfl((long long)var, srcLane, width) : (__shfl((int)var, srcLane, width)); 
# 269
} 
#endif
# 271 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned long __shfl(unsigned long var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
# 275
::exit(___);}
#if 0
# 271
{ 
# 272
return (sizeof(long) == sizeof(long long)) ? __shfl((unsigned long long)var, srcLane, width) : (__shfl((unsigned)var, srcLane, width)); 
# 275
} 
#endif
# 277 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline long __shfl_up(long var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 281
::exit(___);}
#if 0
# 277
{ 
# 278
return (sizeof(long) == sizeof(long long)) ? __shfl_up((long long)var, delta, width) : (__shfl_up((int)var, delta, width)); 
# 281
} 
#endif
# 283 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned long __shfl_up(unsigned long var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 287
::exit(___);}
#if 0
# 283
{ 
# 284
return (sizeof(long) == sizeof(long long)) ? __shfl_up((unsigned long long)var, delta, width) : (__shfl_up((unsigned)var, delta, width)); 
# 287
} 
#endif
# 289 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline long __shfl_down(long var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 293
::exit(___);}
#if 0
# 289
{ 
# 290
return (sizeof(long) == sizeof(long long)) ? __shfl_down((long long)var, delta, width) : (__shfl_down((int)var, delta, width)); 
# 293
} 
#endif
# 295 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned long __shfl_down(unsigned long var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 299
::exit(___);}
#if 0
# 295
{ 
# 296
return (sizeof(long) == sizeof(long long)) ? __shfl_down((unsigned long long)var, delta, width) : (__shfl_down((unsigned)var, delta, width)); 
# 299
} 
#endif
# 301 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline long __shfl_xor(long var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
# 305
::exit(___);}
#if 0
# 301
{ 
# 302
return (sizeof(long) == sizeof(long long)) ? __shfl_xor((long long)var, laneMask, width) : (__shfl_xor((int)var, laneMask, width)); 
# 305
} 
#endif
# 307 "/usr/include/sm_30_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned long __shfl_xor(unsigned long var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
# 311
::exit(___);}
#if 0
# 307
{ 
# 308
return (sizeof(long) == sizeof(long long)) ? __shfl_xor((unsigned long long)var, laneMask, width) : (__shfl_xor((unsigned)var, laneMask, width)); 
# 311
} 
#endif
# 80 "/usr/include/sm_32_intrinsics.h" 3
__attribute__((unused)) static inline long __ldg(const long * ptr); 
# 81
__attribute__((unused)) static inline unsigned long __ldg(const unsigned long * ptr); 
# 84
__attribute__((unused)) static inline char __ldg(const char * ptr); 
# 85
__attribute__((unused)) static inline signed char __ldg(const signed char * ptr); 
# 86
__attribute__((unused)) static inline short __ldg(const short * ptr); 
# 87
__attribute__((unused)) static inline int __ldg(const int * ptr); 
# 88
__attribute__((unused)) static inline long long __ldg(const long long * ptr); 
# 89
__attribute__((unused)) static inline char2 __ldg(const char2 * ptr); 
# 90
__attribute__((unused)) static inline char4 __ldg(const char4 * ptr); 
# 91
__attribute__((unused)) static inline short2 __ldg(const short2 * ptr); 
# 92
__attribute__((unused)) static inline short4 __ldg(const short4 * ptr); 
# 93
__attribute__((unused)) static inline int2 __ldg(const int2 * ptr); 
# 94
__attribute__((unused)) static inline int4 __ldg(const int4 * ptr); 
# 95
__attribute__((unused)) static inline longlong2 __ldg(const longlong2 * ptr); 
# 97
__attribute__((unused)) static inline unsigned char __ldg(const unsigned char * ptr); 
# 98
__attribute__((unused)) static inline unsigned short __ldg(const unsigned short * ptr); 
# 99
__attribute__((unused)) static inline unsigned __ldg(const unsigned * ptr); 
# 100
__attribute__((unused)) static inline unsigned long long __ldg(const unsigned long long * ptr); 
# 101
__attribute__((unused)) static inline uchar2 __ldg(const uchar2 * ptr); 
# 102
__attribute__((unused)) static inline uchar4 __ldg(const uchar4 * ptr); 
# 103
__attribute__((unused)) static inline ushort2 __ldg(const ushort2 * ptr); 
# 104
__attribute__((unused)) static inline ushort4 __ldg(const ushort4 * ptr); 
# 105
__attribute__((unused)) static inline uint2 __ldg(const uint2 * ptr); 
# 106
__attribute__((unused)) static inline uint4 __ldg(const uint4 * ptr); 
# 107
__attribute__((unused)) static inline ulonglong2 __ldg(const ulonglong2 * ptr); 
# 109
__attribute__((unused)) static inline float __ldg(const float * ptr); 
# 110
__attribute__((unused)) static inline double __ldg(const double * ptr); 
# 111
__attribute__((unused)) static inline float2 __ldg(const float2 * ptr); 
# 112
__attribute__((unused)) static inline float4 __ldg(const float4 * ptr); 
# 113
__attribute__((unused)) static inline double2 __ldg(const double2 * ptr); 
# 120
__attribute__((unused)) static inline unsigned __funnelshift_l(unsigned lo, unsigned hi, unsigned shift); 
# 121
__attribute__((unused)) static inline unsigned __funnelshift_lc(unsigned lo, unsigned hi, unsigned shift); 
# 124
__attribute__((unused)) static inline unsigned __funnelshift_r(unsigned lo, unsigned hi, unsigned shift); 
# 125
__attribute__((unused)) static inline unsigned __funnelshift_rc(unsigned lo, unsigned hi, unsigned shift); 
# 99 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline long __ldg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 99
{ unsigned long ret; __asm__ volatile("ld.global.nc.s64 %0, [%1];" : "=l" (ret) : "l" (ptr)); return (long)ret; } 
#endif
# 100 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned long __ldg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 100
{ unsigned long ret; __asm__ volatile("ld.global.nc.u64 %0, [%1];" : "=l" (ret) : "l" (ptr)); return ret; } 
#endif
# 107 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline char __ldg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 107
{ unsigned ret; __asm__ volatile("ld.global.nc.s8 %0, [%1];" : "=r" (ret) : "l" (ptr)); return (char)ret; } 
#endif
# 108 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline signed char __ldg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 108
{ unsigned ret; __asm__ volatile("ld.global.nc.s8 %0, [%1];" : "=r" (ret) : "l" (ptr)); return (signed char)ret; } 
#endif
# 109 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline short __ldg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 109
{ unsigned short ret; __asm__ volatile("ld.global.nc.s16 %0, [%1];" : "=h" (ret) : "l" (ptr)); return (short)ret; } 
#endif
# 110 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline int __ldg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 110
{ unsigned ret; __asm__ volatile("ld.global.nc.s32 %0, [%1];" : "=r" (ret) : "l" (ptr)); return (int)ret; } 
#endif
# 111 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline long long __ldg(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 111
{ unsigned long long ret; __asm__ volatile("ld.global.nc.s64 %0, [%1];" : "=l" (ret) : "l" (ptr)); return (long long)ret; } 
#endif
# 112 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline char2 __ldg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 112
{ char2 ret; int2 tmp; __asm__ volatile("ld.global.nc.v2.s8 {%0,%1}, [%2];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (ptr)); (ret.x) = ((char)(tmp.x)); (ret.y) = ((char)(tmp.y)); return ret; } 
#endif
# 113 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline char4 __ldg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 113
{ char4 ret; int4 tmp; __asm__ volatile("ld.global.nc.v4.s8 {%0,%1,%2,%3}, [%4];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (ptr)); (ret.x) = ((char)(tmp.x)); (ret.y) = ((char)(tmp.y)); (ret.z) = ((char)(tmp.z)); (ret.w) = ((char)(tmp.w)); return ret; } 
#endif
# 114 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline short2 __ldg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 114
{ short2 ret; __asm__ volatile("ld.global.nc.v2.s16 {%0,%1}, [%2];" : "=h" (ret.x), "=h" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 115 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline short4 __ldg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 115
{ short4 ret; __asm__ volatile("ld.global.nc.v4.s16 {%0,%1,%2,%3}, [%4];" : "=h" (ret.x), "=h" (ret.y), "=h" (ret.z), "=h" (ret.w) : "l" (ptr)); return ret; } 
#endif
# 116 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline int2 __ldg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 116
{ int2 ret; __asm__ volatile("ld.global.nc.v2.s32 {%0,%1}, [%2];" : "=r" (ret.x), "=r" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 117 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline int4 __ldg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 117
{ int4 ret; __asm__ volatile("ld.global.nc.v4.s32 {%0,%1,%2,%3}, [%4];" : "=r" (ret.x), "=r" (ret.y), "=r" (ret.z), "=r" (ret.w) : "l" (ptr)); return ret; } 
#endif
# 118 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline longlong2 __ldg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 118
{ longlong2 ret; __asm__ volatile("ld.global.nc.v2.s64 %0, [%1];" : "=l" (ret.x), "=l" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 120 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned char __ldg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 120
{ unsigned ret; __asm__ volatile("ld.global.nc.u8 %0, [%1];" : "=r" (ret) : "l" (ptr)); return (unsigned char)ret; } 
#endif
# 121 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned short __ldg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 121
{ unsigned short ret; __asm__ volatile("ld.global.nc.u16 %0, [%1];" : "=h" (ret) : "l" (ptr)); return ret; } 
#endif
# 122 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned __ldg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 122
{ unsigned ret; __asm__ volatile("ld.global.nc.u32 %0, [%1];" : "=r" (ret) : "l" (ptr)); return ret; } 
#endif
# 123 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned long long __ldg(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 123
{ unsigned long long ret; __asm__ volatile("ld.global.nc.u64 %0, [%1];" : "=l" (ret) : "l" (ptr)); return ret; } 
#endif
# 124 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline uchar2 __ldg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 124
{ uchar2 ret; uint2 tmp; __asm__ volatile("ld.global.nc.v2.u8 {%0,%1}, [%2];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (ptr)); (ret.x) = ((unsigned char)(tmp.x)); (ret.y) = ((unsigned char)(tmp.y)); return ret; } 
#endif
# 125 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline uchar4 __ldg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 125
{ uchar4 ret; uint4 tmp; __asm__ volatile("ld.global.nc.v4.u8 {%0,%1,%2,%3}, [%4];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (ptr)); (ret.x) = ((unsigned char)(tmp.x)); (ret.y) = ((unsigned char)(tmp.y)); (ret.z) = ((unsigned char)(tmp.z)); (ret.w) = ((unsigned char)(tmp.w)); return ret; } 
#endif
# 126 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline ushort2 __ldg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 126
{ ushort2 ret; __asm__ volatile("ld.global.nc.v2.u16 {%0,%1}, [%2];" : "=h" (ret.x), "=h" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 127 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline ushort4 __ldg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 127
{ ushort4 ret; __asm__ volatile("ld.global.nc.v4.u16 {%0,%1,%2,%3}, [%4];" : "=h" (ret.x), "=h" (ret.y), "=h" (ret.z), "=h" (ret.w) : "l" (ptr)); return ret; } 
#endif
# 128 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline uint2 __ldg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 128
{ uint2 ret; __asm__ volatile("ld.global.nc.v2.u32 {%0,%1}, [%2];" : "=r" (ret.x), "=r" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 129 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline uint4 __ldg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 129
{ uint4 ret; __asm__ volatile("ld.global.nc.v4.u32 {%0,%1,%2,%3}, [%4];" : "=r" (ret.x), "=r" (ret.y), "=r" (ret.z), "=r" (ret.w) : "l" (ptr)); return ret; } 
#endif
# 130 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline ulonglong2 __ldg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 130
{ ulonglong2 ret; __asm__ volatile("ld.global.nc.v2.u64 %0, [%1];" : "=l" (ret.x), "=l" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 132 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline float __ldg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 132
{ float ret; __asm__ volatile("ld.global.nc.f32 %0, [%1];" : "=f" (ret) : "l" (ptr)); return ret; } 
#endif
# 133 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline double __ldg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 133
{ double ret; __asm__ volatile("ld.global.nc.f64 %0, [%1];" : "=d" (ret) : "l" (ptr)); return ret; } 
#endif
# 134 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline float2 __ldg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 134
{ float2 ret; __asm__ volatile("ld.global.nc.v2.f32 {%0,%1}, [%2];" : "=f" (ret.x), "=f" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 135 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline float4 __ldg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 135
{ float4 ret; __asm__ volatile("ld.global.nc.v4.f32 {%0,%1,%2,%3}, [%4];" : "=f" (ret.x), "=f" (ret.y), "=f" (ret.z), "=f" (ret.w) : "l" (ptr)); return ret; } 
#endif
# 136 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline double2 __ldg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 136
{ double2 ret; __asm__ volatile("ld.global.nc.v2.f64 {%0,%1}, [%2];" : "=d" (ret.x), "=d" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 145 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned __funnelshift_l(unsigned lo, unsigned hi, unsigned shift) 
# 146
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
# 150
::exit(___);}
#if 0
# 146
{ 
# 147
unsigned ret; 
# 148
__asm__ volatile("shf.l.wrap.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (lo), "r" (hi), "r" (shift)); 
# 149
return ret; 
# 150
} 
#endif
# 151 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned __funnelshift_lc(unsigned lo, unsigned hi, unsigned shift) 
# 152
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
# 156
::exit(___);}
#if 0
# 152
{ 
# 153
unsigned ret; 
# 154
__asm__ volatile("shf.l.clamp.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (lo), "r" (hi), "r" (shift)); 
# 155
return ret; 
# 156
} 
#endif
# 159 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned __funnelshift_r(unsigned lo, unsigned hi, unsigned shift) 
# 160
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
# 164
::exit(___);}
#if 0
# 160
{ 
# 161
unsigned ret; 
# 162
__asm__ volatile("shf.r.wrap.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (lo), "r" (hi), "r" (shift)); 
# 163
return ret; 
# 164
} 
#endif
# 165 "/usr/include/sm_32_intrinsics.hpp" 3
__attribute__((unused)) static inline unsigned __funnelshift_rc(unsigned lo, unsigned hi, unsigned shift) 
# 166
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
# 170
::exit(___);}
#if 0
# 166
{ 
# 167
unsigned ret; 
# 168
__asm__ volatile("shf.r.clamp.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (lo), "r" (hi), "r" (shift)); 
# 169
return ret; 
# 170
} 
#endif
# 112 "/usr/include/surface_functions.h" 3
template< class T> 
# 113
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(T *res, surface< void, 1>  surf, int x, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 114
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)s;(void)mode;
# 121
::exit(___);}
#if 0
# 114
{ 
# 115
(s == 1) ? (void)((*((uchar1 *)res)) = __surf1Dreadc1(surf, x, cudaBoundaryModeTrap)) : ((s == 2) ? (void)((*((ushort1 *)res)) = __surf1Dreads1(surf, x, cudaBoundaryModeTrap)) : ((s == 4) ? (void)((*((uint1 *)res)) = __surf1Dreadu1(surf, x, cudaBoundaryModeTrap)) : ((s == 8) ? (void)((*((uint2 *)res)) = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap)) : ((s == 16) ? (void)((*((uint4 *)res)) = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap)) : ((void)0))))); 
# 121
} 
#endif
# 123 "/usr/include/surface_functions.h" 3
template< class T> 
# 124
__attribute((always_inline)) __attribute__((unused)) static inline T surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 125
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 131
::exit(___);}
#if 0
# 125
{ 
# 126
T tmp; 
# 128
surf1Dread(&tmp, surf, x, (int)sizeof(T), mode); 
# 130
return tmp; 
# 131
} 
#endif
# 133 "/usr/include/surface_functions.h" 3
template< class T> 
# 134
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(T *res, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 135
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)mode;
# 137
::exit(___);}
#if 0
# 135
{ 
# 136
(*res) = surf1Dread< T> (surf, x, mode); 
# 137
} 
#endif
# 140 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 140
__attribute((always_inline)) __attribute__((unused)) inline char surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 141
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 143
::exit(___);}
#if 0
# 141
{ 
# 142
return (char)(__surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x); 
# 143
} 
#endif
# 146 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 146
__attribute((always_inline)) __attribute__((unused)) inline signed char surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 147
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 149
::exit(___);}
#if 0
# 147
{ 
# 148
return (signed char)(__surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x); 
# 149
} 
#endif
# 152 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 152
__attribute((always_inline)) __attribute__((unused)) inline unsigned char surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 153
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 155
::exit(___);}
#if 0
# 153
{ 
# 154
return __surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x; 
# 155
} 
#endif
# 158 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 158
__attribute((always_inline)) __attribute__((unused)) inline char1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 159
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 161
::exit(___);}
#if 0
# 159
{ 
# 160
return make_char1((signed char)(__surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x)); 
# 161
} 
#endif
# 164 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 164
__attribute((always_inline)) __attribute__((unused)) inline uchar1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 165
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 167
::exit(___);}
#if 0
# 165
{ 
# 166
return __surf1Dreadc1(surf, x, cudaBoundaryModeTrap); 
# 167
} 
#endif
# 170 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 170
__attribute((always_inline)) __attribute__((unused)) inline char2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 171
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 175
::exit(___);}
#if 0
# 171
{ 
# 172
uchar2 tmp = __surf1Dreadc2(surf, x, cudaBoundaryModeTrap); 
# 174
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
# 175
} 
#endif
# 178 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 178
__attribute((always_inline)) __attribute__((unused)) inline uchar2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 179
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 181
::exit(___);}
#if 0
# 179
{ 
# 180
return __surf1Dreadc2(surf, x, cudaBoundaryModeTrap); 
# 181
} 
#endif
# 184 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 184
__attribute((always_inline)) __attribute__((unused)) inline char4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 185
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 189
::exit(___);}
#if 0
# 185
{ 
# 186
uchar4 tmp = __surf1Dreadc4(surf, x, cudaBoundaryModeTrap); 
# 188
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
# 189
} 
#endif
# 192 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 192
__attribute((always_inline)) __attribute__((unused)) inline uchar4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 193
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 195
::exit(___);}
#if 0
# 193
{ 
# 194
return __surf1Dreadc4(surf, x, cudaBoundaryModeTrap); 
# 195
} 
#endif
# 198 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 198
__attribute((always_inline)) __attribute__((unused)) inline short surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 199
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 201
::exit(___);}
#if 0
# 199
{ 
# 200
return (short)(__surf1Dreads1(surf, x, cudaBoundaryModeTrap).x); 
# 201
} 
#endif
# 204 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 204
__attribute((always_inline)) __attribute__((unused)) inline unsigned short surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 205
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 207
::exit(___);}
#if 0
# 205
{ 
# 206
return __surf1Dreads1(surf, x, cudaBoundaryModeTrap).x; 
# 207
} 
#endif
# 210 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 210
__attribute((always_inline)) __attribute__((unused)) inline short1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 211
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 213
::exit(___);}
#if 0
# 211
{ 
# 212
return make_short1((signed short)(__surf1Dreads1(surf, x, cudaBoundaryModeTrap).x)); 
# 213
} 
#endif
# 216 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 216
__attribute((always_inline)) __attribute__((unused)) inline ushort1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 217
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 219
::exit(___);}
#if 0
# 217
{ 
# 218
return __surf1Dreads1(surf, x, cudaBoundaryModeTrap); 
# 219
} 
#endif
# 222 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 222
__attribute((always_inline)) __attribute__((unused)) inline short2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 223
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 227
::exit(___);}
#if 0
# 223
{ 
# 224
ushort2 tmp = __surf1Dreads2(surf, x, cudaBoundaryModeTrap); 
# 226
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
# 227
} 
#endif
# 230 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 230
__attribute((always_inline)) __attribute__((unused)) inline ushort2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 231
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 233
::exit(___);}
#if 0
# 231
{ 
# 232
return __surf1Dreads2(surf, x, cudaBoundaryModeTrap); 
# 233
} 
#endif
# 236 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 236
__attribute((always_inline)) __attribute__((unused)) inline short4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 237
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 241
::exit(___);}
#if 0
# 237
{ 
# 238
ushort4 tmp = __surf1Dreads4(surf, x, cudaBoundaryModeTrap); 
# 240
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
# 241
} 
#endif
# 244 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 244
__attribute((always_inline)) __attribute__((unused)) inline ushort4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 245
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 247
::exit(___);}
#if 0
# 245
{ 
# 246
return __surf1Dreads4(surf, x, cudaBoundaryModeTrap); 
# 247
} 
#endif
# 250 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 250
__attribute((always_inline)) __attribute__((unused)) inline int surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 251
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 253
::exit(___);}
#if 0
# 251
{ 
# 252
return (int)(__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x); 
# 253
} 
#endif
# 256 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 256
__attribute((always_inline)) __attribute__((unused)) inline unsigned surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 257
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 259
::exit(___);}
#if 0
# 257
{ 
# 258
return __surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x; 
# 259
} 
#endif
# 262 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 262
__attribute((always_inline)) __attribute__((unused)) inline int1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 263
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 265
::exit(___);}
#if 0
# 263
{ 
# 264
return make_int1((signed int)(__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x)); 
# 265
} 
#endif
# 268 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 268
__attribute((always_inline)) __attribute__((unused)) inline uint1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 269
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 271
::exit(___);}
#if 0
# 269
{ 
# 270
return __surf1Dreadu1(surf, x, cudaBoundaryModeTrap); 
# 271
} 
#endif
# 274 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 274
__attribute((always_inline)) __attribute__((unused)) inline int2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 275
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 279
::exit(___);}
#if 0
# 275
{ 
# 276
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
# 278
return make_int2((int)(tmp.x), (int)(tmp.y)); 
# 279
} 
#endif
# 282 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 282
__attribute((always_inline)) __attribute__((unused)) inline uint2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 283
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 285
::exit(___);}
#if 0
# 283
{ 
# 284
return __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
# 285
} 
#endif
# 288 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 288
__attribute((always_inline)) __attribute__((unused)) inline int4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 289
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 293
::exit(___);}
#if 0
# 289
{ 
# 290
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
# 292
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
# 293
} 
#endif
# 296 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 296
__attribute((always_inline)) __attribute__((unused)) inline uint4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 297
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 299
::exit(___);}
#if 0
# 297
{ 
# 298
return __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
# 299
} 
#endif
# 302 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 302
__attribute((always_inline)) __attribute__((unused)) inline long long surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 303
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 305
::exit(___);}
#if 0
# 303
{ 
# 304
return (long long)(__surf1Dreadl1(surf, x, cudaBoundaryModeTrap).x); 
# 305
} 
#endif
# 308 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 308
__attribute((always_inline)) __attribute__((unused)) inline unsigned long long surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 309
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 311
::exit(___);}
#if 0
# 309
{ 
# 310
return __surf1Dreadl1(surf, x, cudaBoundaryModeTrap).x; 
# 311
} 
#endif
# 314 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 314
__attribute((always_inline)) __attribute__((unused)) inline longlong1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 315
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 317
::exit(___);}
#if 0
# 315
{ 
# 316
return make_longlong1((long long)(__surf1Dreadl1(surf, x, cudaBoundaryModeTrap).x)); 
# 317
} 
#endif
# 320 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 320
__attribute((always_inline)) __attribute__((unused)) inline ulonglong1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 321
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 323
::exit(___);}
#if 0
# 321
{ 
# 322
return __surf1Dreadl1(surf, x, cudaBoundaryModeTrap); 
# 323
} 
#endif
# 326 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 326
__attribute((always_inline)) __attribute__((unused)) inline longlong2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 327
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 331
::exit(___);}
#if 0
# 327
{ 
# 328
ulonglong2 tmp = __surf1Dreadl2(surf, x, cudaBoundaryModeTrap); 
# 330
return make_longlong2((long long)(tmp.x), (long long)(tmp.y)); 
# 331
} 
#endif
# 334 "/usr/include/surface_functions.h" 3
template<> 
# 124
__attribute((always_inline)) 
# 334
__attribute((always_inline)) __attribute__((unused)) inline ulonglong2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 335
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 337
::exit(___);}
#if 0
# 335
{ 
# 336
return __surf1Dreadl2(surf, x, cudaBoundaryModeTrap); 
# 337
} 
#endif
# 400 "/usr/include/surface_functions.h" 3
template<> 
# 124 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 400 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 401
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 403
::exit(___);}
#if 0
# 401
{ 
# 402
return __int_as_float((int)(__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x)); 
# 403
} 
#endif
# 406 "/usr/include/surface_functions.h" 3
template<> 
# 124 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 406 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 407
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 409
::exit(___);}
#if 0
# 407
{ 
# 408
return make_float1(__int_as_float((int)(__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x))); 
# 409
} 
#endif
# 412 "/usr/include/surface_functions.h" 3
template<> 
# 124 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 412 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 413
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 417
::exit(___);}
#if 0
# 413
{ 
# 414
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
# 416
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
# 417
} 
#endif
# 420 "/usr/include/surface_functions.h" 3
template<> 
# 124 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 420 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 421
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 425
::exit(___);}
#if 0
# 421
{ 
# 422
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
# 424
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
# 425
} 
#endif
# 460 "/usr/include/surface_functions.h" 3
template< class T> 
# 461
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(T *res, surface< void, 2>  surf, int x, int y, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 462
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)s;(void)mode;
# 469
::exit(___);}
#if 0
# 462
{ 
# 463
(s == 1) ? (void)((*((uchar1 *)res)) = __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)) : ((s == 2) ? (void)((*((ushort1 *)res)) = __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap)) : ((s == 4) ? (void)((*((uint1 *)res)) = __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)) : ((s == 8) ? (void)((*((uint2 *)res)) = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap)) : ((s == 16) ? (void)((*((uint4 *)res)) = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap)) : ((void)0))))); 
# 469
} 
#endif
# 471 "/usr/include/surface_functions.h" 3
template< class T> 
# 472
__attribute((always_inline)) __attribute__((unused)) static inline T surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 473
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 479
::exit(___);}
#if 0
# 473
{ 
# 474
T tmp; 
# 476
surf2Dread(&tmp, surf, x, y, (int)sizeof(T), mode); 
# 478
return tmp; 
# 479
} 
#endif
# 481 "/usr/include/surface_functions.h" 3
template< class T> 
# 482
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(T *res, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 483
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)mode;
# 485
::exit(___);}
#if 0
# 483
{ 
# 484
(*res) = surf2Dread< T> (surf, x, y, mode); 
# 485
} 
#endif
# 488 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 488
__attribute((always_inline)) __attribute__((unused)) inline char surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 489
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 491
::exit(___);}
#if 0
# 489
{ 
# 490
return (char)(__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x); 
# 491
} 
#endif
# 494 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 494
__attribute((always_inline)) __attribute__((unused)) inline signed char surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 495
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 497
::exit(___);}
#if 0
# 495
{ 
# 496
return (signed char)(__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x); 
# 497
} 
#endif
# 500 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 500
__attribute((always_inline)) __attribute__((unused)) inline unsigned char surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 501
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 503
::exit(___);}
#if 0
# 501
{ 
# 502
return __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x; 
# 503
} 
#endif
# 506 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 506
__attribute((always_inline)) __attribute__((unused)) inline char1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 507
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 509
::exit(___);}
#if 0
# 507
{ 
# 508
return make_char1((signed char)(__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x)); 
# 509
} 
#endif
# 512 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 512
__attribute((always_inline)) __attribute__((unused)) inline uchar1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 513
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 515
::exit(___);}
#if 0
# 513
{ 
# 514
return __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap); 
# 515
} 
#endif
# 518 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 518
__attribute((always_inline)) __attribute__((unused)) inline char2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 519
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 523
::exit(___);}
#if 0
# 519
{ 
# 520
uchar2 tmp = __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap); 
# 522
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
# 523
} 
#endif
# 526 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 526
__attribute((always_inline)) __attribute__((unused)) inline uchar2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 527
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 529
::exit(___);}
#if 0
# 527
{ 
# 528
return __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap); 
# 529
} 
#endif
# 532 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 532
__attribute((always_inline)) __attribute__((unused)) inline char4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 533
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 537
::exit(___);}
#if 0
# 533
{ 
# 534
uchar4 tmp = __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap); 
# 536
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
# 537
} 
#endif
# 540 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 540
__attribute((always_inline)) __attribute__((unused)) inline uchar4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 541
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 543
::exit(___);}
#if 0
# 541
{ 
# 542
return __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap); 
# 543
} 
#endif
# 546 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 546
__attribute((always_inline)) __attribute__((unused)) inline short surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 547
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 549
::exit(___);}
#if 0
# 547
{ 
# 548
return (short)(__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap).x); 
# 549
} 
#endif
# 552 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 552
__attribute((always_inline)) __attribute__((unused)) inline unsigned short surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 553
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 555
::exit(___);}
#if 0
# 553
{ 
# 554
return __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap).x; 
# 555
} 
#endif
# 558 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 558
__attribute((always_inline)) __attribute__((unused)) inline short1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 559
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 561
::exit(___);}
#if 0
# 559
{ 
# 560
return make_short1((signed short)(__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap).x)); 
# 561
} 
#endif
# 564 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 564
__attribute((always_inline)) __attribute__((unused)) inline ushort1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 565
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 567
::exit(___);}
#if 0
# 565
{ 
# 566
return __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap); 
# 567
} 
#endif
# 570 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 570
__attribute((always_inline)) __attribute__((unused)) inline short2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 571
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 575
::exit(___);}
#if 0
# 571
{ 
# 572
ushort2 tmp = __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap); 
# 574
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
# 575
} 
#endif
# 578 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 578
__attribute((always_inline)) __attribute__((unused)) inline ushort2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 579
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 581
::exit(___);}
#if 0
# 579
{ 
# 580
return __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap); 
# 581
} 
#endif
# 584 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 584
__attribute((always_inline)) __attribute__((unused)) inline short4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 585
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 589
::exit(___);}
#if 0
# 585
{ 
# 586
ushort4 tmp = __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap); 
# 588
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
# 589
} 
#endif
# 592 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 592
__attribute((always_inline)) __attribute__((unused)) inline ushort4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 593
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 595
::exit(___);}
#if 0
# 593
{ 
# 594
return __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap); 
# 595
} 
#endif
# 598 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 598
__attribute((always_inline)) __attribute__((unused)) inline int surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 599
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 601
::exit(___);}
#if 0
# 599
{ 
# 600
return (int)(__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x); 
# 601
} 
#endif
# 604 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 604
__attribute((always_inline)) __attribute__((unused)) inline unsigned surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 605
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 607
::exit(___);}
#if 0
# 605
{ 
# 606
return __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x; 
# 607
} 
#endif
# 610 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 610
__attribute((always_inline)) __attribute__((unused)) inline int1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 611
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 613
::exit(___);}
#if 0
# 611
{ 
# 612
return make_int1((signed int)(__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x)); 
# 613
} 
#endif
# 616 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 616
__attribute((always_inline)) __attribute__((unused)) inline uint1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 617
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 619
::exit(___);}
#if 0
# 617
{ 
# 618
return __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap); 
# 619
} 
#endif
# 622 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 622
__attribute((always_inline)) __attribute__((unused)) inline int2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 623
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 627
::exit(___);}
#if 0
# 623
{ 
# 624
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
# 626
return make_int2((int)(tmp.x), (int)(tmp.y)); 
# 627
} 
#endif
# 630 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 630
__attribute((always_inline)) __attribute__((unused)) inline uint2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 631
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 633
::exit(___);}
#if 0
# 631
{ 
# 632
return __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
# 633
} 
#endif
# 636 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 636
__attribute((always_inline)) __attribute__((unused)) inline int4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 637
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 641
::exit(___);}
#if 0
# 637
{ 
# 638
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
# 640
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
# 641
} 
#endif
# 644 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 644
__attribute((always_inline)) __attribute__((unused)) inline uint4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 645
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 647
::exit(___);}
#if 0
# 645
{ 
# 646
return __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
# 647
} 
#endif
# 650 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 650
__attribute((always_inline)) __attribute__((unused)) inline long long surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 651
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 653
::exit(___);}
#if 0
# 651
{ 
# 652
return (long long)(__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap).x); 
# 653
} 
#endif
# 656 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 656
__attribute((always_inline)) __attribute__((unused)) inline unsigned long long surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 657
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 659
::exit(___);}
#if 0
# 657
{ 
# 658
return __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap).x; 
# 659
} 
#endif
# 662 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 662
__attribute((always_inline)) __attribute__((unused)) inline longlong1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 663
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 665
::exit(___);}
#if 0
# 663
{ 
# 664
return make_longlong1((long long)(__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap).x)); 
# 665
} 
#endif
# 668 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 668
__attribute((always_inline)) __attribute__((unused)) inline ulonglong1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 669
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 671
::exit(___);}
#if 0
# 669
{ 
# 670
return __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap); 
# 671
} 
#endif
# 674 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 674
__attribute((always_inline)) __attribute__((unused)) inline longlong2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 675
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 679
::exit(___);}
#if 0
# 675
{ 
# 676
ulonglong2 tmp = __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap); 
# 678
return make_longlong2((long long)(tmp.x), (long long)(tmp.y)); 
# 679
} 
#endif
# 682 "/usr/include/surface_functions.h" 3
template<> 
# 472
__attribute((always_inline)) 
# 682
__attribute((always_inline)) __attribute__((unused)) inline ulonglong2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 683
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 685
::exit(___);}
#if 0
# 683
{ 
# 684
return __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap); 
# 685
} 
#endif
# 748 "/usr/include/surface_functions.h" 3
template<> 
# 472 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 748 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 749
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 751
::exit(___);}
#if 0
# 749
{ 
# 750
return __int_as_float((int)(__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x)); 
# 751
} 
#endif
# 754 "/usr/include/surface_functions.h" 3
template<> 
# 472 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 754 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 755
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 757
::exit(___);}
#if 0
# 755
{ 
# 756
return make_float1(__int_as_float((int)(__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x))); 
# 757
} 
#endif
# 760 "/usr/include/surface_functions.h" 3
template<> 
# 472 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 760 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 761
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 765
::exit(___);}
#if 0
# 761
{ 
# 762
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
# 764
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
# 765
} 
#endif
# 768 "/usr/include/surface_functions.h" 3
template<> 
# 472 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 768 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 769
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 773
::exit(___);}
#if 0
# 769
{ 
# 770
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
# 772
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
# 773
} 
#endif
# 808 "/usr/include/surface_functions.h" 3
template< class T> 
# 809
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(T *res, surface< void, 3>  surf, int x, int y, int z, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 810
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
# 817
::exit(___);}
#if 0
# 810
{ 
# 811
(s == 1) ? (void)((*((uchar1 *)res)) = __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 2) ? (void)((*((ushort1 *)res)) = __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 4) ? (void)((*((uint1 *)res)) = __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 8) ? (void)((*((uint2 *)res)) = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 16) ? (void)((*((uint4 *)res)) = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap)) : ((void)0))))); 
# 817
} 
#endif
# 819 "/usr/include/surface_functions.h" 3
template< class T> 
# 820
__attribute((always_inline)) __attribute__((unused)) static inline T surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 821
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 827
::exit(___);}
#if 0
# 821
{ 
# 822
T tmp; 
# 824
surf3Dread(&tmp, surf, x, y, z, (int)sizeof(T), mode); 
# 826
return tmp; 
# 827
} 
#endif
# 829 "/usr/include/surface_functions.h" 3
template< class T> 
# 830
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(T *res, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 831
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 833
::exit(___);}
#if 0
# 831
{ 
# 832
(*res) = surf3Dread< T> (surf, x, y, z, mode); 
# 833
} 
#endif
# 836 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 836
__attribute((always_inline)) __attribute__((unused)) inline char surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 837
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 839
::exit(___);}
#if 0
# 837
{ 
# 838
return (char)(__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x); 
# 839
} 
#endif
# 842 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 842
__attribute((always_inline)) __attribute__((unused)) inline signed char surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 843
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 845
::exit(___);}
#if 0
# 843
{ 
# 844
return (signed char)(__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x); 
# 845
} 
#endif
# 848 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 848
__attribute((always_inline)) __attribute__((unused)) inline unsigned char surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 849
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 851
::exit(___);}
#if 0
# 849
{ 
# 850
return __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x; 
# 851
} 
#endif
# 854 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 854
__attribute((always_inline)) __attribute__((unused)) inline char1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 855
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 857
::exit(___);}
#if 0
# 855
{ 
# 856
return make_char1((signed char)(__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x)); 
# 857
} 
#endif
# 860 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 860
__attribute((always_inline)) __attribute__((unused)) inline uchar1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 861
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 863
::exit(___);}
#if 0
# 861
{ 
# 862
return __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap); 
# 863
} 
#endif
# 866 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 866
__attribute((always_inline)) __attribute__((unused)) inline char2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 867
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 871
::exit(___);}
#if 0
# 867
{ 
# 868
uchar2 tmp = __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap); 
# 870
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
# 871
} 
#endif
# 874 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 874
__attribute((always_inline)) __attribute__((unused)) inline uchar2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 875
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 877
::exit(___);}
#if 0
# 875
{ 
# 876
return __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap); 
# 877
} 
#endif
# 880 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 880
__attribute((always_inline)) __attribute__((unused)) inline char4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 881
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 885
::exit(___);}
#if 0
# 881
{ 
# 882
uchar4 tmp = __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap); 
# 884
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
# 885
} 
#endif
# 888 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 888
__attribute((always_inline)) __attribute__((unused)) inline uchar4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 889
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 891
::exit(___);}
#if 0
# 889
{ 
# 890
return __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap); 
# 891
} 
#endif
# 894 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 894
__attribute((always_inline)) __attribute__((unused)) inline short surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 895
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 897
::exit(___);}
#if 0
# 895
{ 
# 896
return (short)(__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap).x); 
# 897
} 
#endif
# 900 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 900
__attribute((always_inline)) __attribute__((unused)) inline unsigned short surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 901
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 903
::exit(___);}
#if 0
# 901
{ 
# 902
return __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap).x; 
# 903
} 
#endif
# 906 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 906
__attribute((always_inline)) __attribute__((unused)) inline short1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 907
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 909
::exit(___);}
#if 0
# 907
{ 
# 908
return make_short1((signed short)(__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap).x)); 
# 909
} 
#endif
# 912 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 912
__attribute((always_inline)) __attribute__((unused)) inline ushort1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 913
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 915
::exit(___);}
#if 0
# 913
{ 
# 914
return __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap); 
# 915
} 
#endif
# 918 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 918
__attribute((always_inline)) __attribute__((unused)) inline short2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 919
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 923
::exit(___);}
#if 0
# 919
{ 
# 920
ushort2 tmp = __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap); 
# 922
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
# 923
} 
#endif
# 926 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 926
__attribute((always_inline)) __attribute__((unused)) inline ushort2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 927
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 929
::exit(___);}
#if 0
# 927
{ 
# 928
return __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap); 
# 929
} 
#endif
# 932 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 932
__attribute((always_inline)) __attribute__((unused)) inline short4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 933
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 937
::exit(___);}
#if 0
# 933
{ 
# 934
ushort4 tmp = __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap); 
# 936
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
# 937
} 
#endif
# 940 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 940
__attribute((always_inline)) __attribute__((unused)) inline ushort4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 941
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 943
::exit(___);}
#if 0
# 941
{ 
# 942
return __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap); 
# 943
} 
#endif
# 946 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 946
__attribute((always_inline)) __attribute__((unused)) inline int surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 947
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 949
::exit(___);}
#if 0
# 947
{ 
# 948
return (int)(__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x); 
# 949
} 
#endif
# 952 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 952
__attribute((always_inline)) __attribute__((unused)) inline unsigned surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 953
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 955
::exit(___);}
#if 0
# 953
{ 
# 954
return __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x; 
# 955
} 
#endif
# 958 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 958
__attribute((always_inline)) __attribute__((unused)) inline int1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 959
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 961
::exit(___);}
#if 0
# 959
{ 
# 960
return make_int1((signed int)(__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x)); 
# 961
} 
#endif
# 964 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 964
__attribute((always_inline)) __attribute__((unused)) inline uint1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 965
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 967
::exit(___);}
#if 0
# 965
{ 
# 966
return __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap); 
# 967
} 
#endif
# 970 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 970
__attribute((always_inline)) __attribute__((unused)) inline int2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 971
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 975
::exit(___);}
#if 0
# 971
{ 
# 972
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
# 974
return make_int2((int)(tmp.x), (int)(tmp.y)); 
# 975
} 
#endif
# 978 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 978
__attribute((always_inline)) __attribute__((unused)) inline uint2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 979
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 981
::exit(___);}
#if 0
# 979
{ 
# 980
return __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
# 981
} 
#endif
# 984 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 984
__attribute((always_inline)) __attribute__((unused)) inline int4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 985
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 989
::exit(___);}
#if 0
# 985
{ 
# 986
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
# 988
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
# 989
} 
#endif
# 992 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 992
__attribute((always_inline)) __attribute__((unused)) inline uint4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 993
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 995
::exit(___);}
#if 0
# 993
{ 
# 994
return __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
# 995
} 
#endif
# 998 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 998
__attribute((always_inline)) __attribute__((unused)) inline long long surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 999
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1001
::exit(___);}
#if 0
# 999
{ 
# 1000
return (long long)(__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap).x); 
# 1001
} 
#endif
# 1004 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 1004
__attribute((always_inline)) __attribute__((unused)) inline unsigned long long surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1005
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1007
::exit(___);}
#if 0
# 1005
{ 
# 1006
return __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap).x; 
# 1007
} 
#endif
# 1010 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 1010
__attribute((always_inline)) __attribute__((unused)) inline longlong1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1011
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1013
::exit(___);}
#if 0
# 1011
{ 
# 1012
return make_longlong1((long long)(__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap).x)); 
# 1013
} 
#endif
# 1016 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 1016
__attribute((always_inline)) __attribute__((unused)) inline ulonglong1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1017
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1019
::exit(___);}
#if 0
# 1017
{ 
# 1018
return __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap); 
# 1019
} 
#endif
# 1022 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 1022
__attribute((always_inline)) __attribute__((unused)) inline longlong2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1023
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1027
::exit(___);}
#if 0
# 1023
{ 
# 1024
ulonglong2 tmp = __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap); 
# 1026
return make_longlong2((long long)(tmp.x), (long long)(tmp.y)); 
# 1027
} 
#endif
# 1030 "/usr/include/surface_functions.h" 3
template<> 
# 820
__attribute((always_inline)) 
# 1030
__attribute((always_inline)) __attribute__((unused)) inline ulonglong2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1031
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1033
::exit(___);}
#if 0
# 1031
{ 
# 1032
return __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap); 
# 1033
} 
#endif
# 1096 "/usr/include/surface_functions.h" 3
template<> 
# 820 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 1096 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1097
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1099
::exit(___);}
#if 0
# 1097
{ 
# 1098
return __int_as_float((int)(__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x)); 
# 1099
} 
#endif
# 1102 "/usr/include/surface_functions.h" 3
template<> 
# 820 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 1102 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1103
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1105
::exit(___);}
#if 0
# 1103
{ 
# 1104
return make_float1(__int_as_float((int)(__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x))); 
# 1105
} 
#endif
# 1108 "/usr/include/surface_functions.h" 3
template<> 
# 820 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 1108 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1109
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1113
::exit(___);}
#if 0
# 1109
{ 
# 1110
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
# 1112
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
# 1113
} 
#endif
# 1116 "/usr/include/surface_functions.h" 3
template<> 
# 820 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 1116 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1117
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1121
::exit(___);}
#if 0
# 1117
{ 
# 1118
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
# 1120
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
# 1121
} 
#endif
# 1156 "/usr/include/surface_functions.h" 3
template< class T> 
# 1157
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(T *res, surface< void, 241>  surf, int x, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1158
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
# 1165
::exit(___);}
#if 0
# 1158
{ 
# 1159
(s == 1) ? (void)((*((uchar1 *)res)) = __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)) : ((s == 2) ? (void)((*((ushort1 *)res)) = __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap)) : ((s == 4) ? (void)((*((uint1 *)res)) = __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)) : ((s == 8) ? (void)((*((uint2 *)res)) = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap)) : ((s == 16) ? (void)((*((uint4 *)res)) = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap)) : ((void)0))))); 
# 1165
} 
#endif
# 1167 "/usr/include/surface_functions.h" 3
template< class T> 
# 1168
__attribute((always_inline)) __attribute__((unused)) static inline T surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1169
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1175
::exit(___);}
#if 0
# 1169
{ 
# 1170
T tmp; 
# 1172
surf1DLayeredread(&tmp, surf, x, layer, (int)sizeof(T), mode); 
# 1174
return tmp; 
# 1175
} 
#endif
# 1177 "/usr/include/surface_functions.h" 3
template< class T> 
# 1178
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(T *res, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1179
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)mode;
# 1181
::exit(___);}
#if 0
# 1179
{ 
# 1180
(*res) = surf1DLayeredread< T> (surf, x, layer, mode); 
# 1181
} 
#endif
# 1184 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1184
__attribute((always_inline)) __attribute__((unused)) inline char surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1185
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1187
::exit(___);}
#if 0
# 1185
{ 
# 1186
return (char)(__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x); 
# 1187
} 
#endif
# 1190 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1190
__attribute((always_inline)) __attribute__((unused)) inline signed char surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1191
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1193
::exit(___);}
#if 0
# 1191
{ 
# 1192
return (signed char)(__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x); 
# 1193
} 
#endif
# 1196 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1196
__attribute((always_inline)) __attribute__((unused)) inline unsigned char surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1197
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1199
::exit(___);}
#if 0
# 1197
{ 
# 1198
return __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x; 
# 1199
} 
#endif
# 1202 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1202
__attribute((always_inline)) __attribute__((unused)) inline char1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1203
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1205
::exit(___);}
#if 0
# 1203
{ 
# 1204
return make_char1((signed char)(__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x)); 
# 1205
} 
#endif
# 1208 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1208
__attribute((always_inline)) __attribute__((unused)) inline uchar1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1209
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1211
::exit(___);}
#if 0
# 1209
{ 
# 1210
return __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap); 
# 1211
} 
#endif
# 1214 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1214
__attribute((always_inline)) __attribute__((unused)) inline char2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1215
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1219
::exit(___);}
#if 0
# 1215
{ 
# 1216
uchar2 tmp = __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap); 
# 1218
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
# 1219
} 
#endif
# 1222 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1222
__attribute((always_inline)) __attribute__((unused)) inline uchar2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1223
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1225
::exit(___);}
#if 0
# 1223
{ 
# 1224
return __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap); 
# 1225
} 
#endif
# 1228 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1228
__attribute((always_inline)) __attribute__((unused)) inline char4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1229
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1233
::exit(___);}
#if 0
# 1229
{ 
# 1230
uchar4 tmp = __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap); 
# 1232
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
# 1233
} 
#endif
# 1236 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1236
__attribute((always_inline)) __attribute__((unused)) inline uchar4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1237
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1239
::exit(___);}
#if 0
# 1237
{ 
# 1238
return __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap); 
# 1239
} 
#endif
# 1242 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1242
__attribute((always_inline)) __attribute__((unused)) inline short surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1243
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1245
::exit(___);}
#if 0
# 1243
{ 
# 1244
return (short)(__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap).x); 
# 1245
} 
#endif
# 1248 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1248
__attribute((always_inline)) __attribute__((unused)) inline unsigned short surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1249
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1251
::exit(___);}
#if 0
# 1249
{ 
# 1250
return __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap).x; 
# 1251
} 
#endif
# 1254 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1254
__attribute((always_inline)) __attribute__((unused)) inline short1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1255
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1257
::exit(___);}
#if 0
# 1255
{ 
# 1256
return make_short1((signed short)(__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap).x)); 
# 1257
} 
#endif
# 1260 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1260
__attribute((always_inline)) __attribute__((unused)) inline ushort1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1261
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1263
::exit(___);}
#if 0
# 1261
{ 
# 1262
return __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap); 
# 1263
} 
#endif
# 1266 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1266
__attribute((always_inline)) __attribute__((unused)) inline short2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1267
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1271
::exit(___);}
#if 0
# 1267
{ 
# 1268
ushort2 tmp = __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap); 
# 1270
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
# 1271
} 
#endif
# 1274 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1274
__attribute((always_inline)) __attribute__((unused)) inline ushort2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1275
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1277
::exit(___);}
#if 0
# 1275
{ 
# 1276
return __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap); 
# 1277
} 
#endif
# 1280 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1280
__attribute((always_inline)) __attribute__((unused)) inline short4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1281
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1285
::exit(___);}
#if 0
# 1281
{ 
# 1282
ushort4 tmp = __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap); 
# 1284
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
# 1285
} 
#endif
# 1288 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1288
__attribute((always_inline)) __attribute__((unused)) inline ushort4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1289
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1291
::exit(___);}
#if 0
# 1289
{ 
# 1290
return __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap); 
# 1291
} 
#endif
# 1294 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1294
__attribute((always_inline)) __attribute__((unused)) inline int surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1295
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1297
::exit(___);}
#if 0
# 1295
{ 
# 1296
return (int)(__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x); 
# 1297
} 
#endif
# 1300 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1300
__attribute((always_inline)) __attribute__((unused)) inline unsigned surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1301
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1303
::exit(___);}
#if 0
# 1301
{ 
# 1302
return __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x; 
# 1303
} 
#endif
# 1306 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1306
__attribute((always_inline)) __attribute__((unused)) inline int1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1307
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1309
::exit(___);}
#if 0
# 1307
{ 
# 1308
return make_int1((signed int)(__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x)); 
# 1309
} 
#endif
# 1312 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1312
__attribute((always_inline)) __attribute__((unused)) inline uint1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1313
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1315
::exit(___);}
#if 0
# 1313
{ 
# 1314
return __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap); 
# 1315
} 
#endif
# 1318 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1318
__attribute((always_inline)) __attribute__((unused)) inline int2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1319
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1323
::exit(___);}
#if 0
# 1319
{ 
# 1320
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
# 1322
return make_int2((int)(tmp.x), (int)(tmp.y)); 
# 1323
} 
#endif
# 1326 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1326
__attribute((always_inline)) __attribute__((unused)) inline uint2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1327
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1329
::exit(___);}
#if 0
# 1327
{ 
# 1328
return __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
# 1329
} 
#endif
# 1332 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1332
__attribute((always_inline)) __attribute__((unused)) inline int4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1333
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1337
::exit(___);}
#if 0
# 1333
{ 
# 1334
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
# 1336
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
# 1337
} 
#endif
# 1340 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1340
__attribute((always_inline)) __attribute__((unused)) inline uint4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1341
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1343
::exit(___);}
#if 0
# 1341
{ 
# 1342
return __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
# 1343
} 
#endif
# 1346 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1346
__attribute((always_inline)) __attribute__((unused)) inline long long surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1347
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1349
::exit(___);}
#if 0
# 1347
{ 
# 1348
return (long long)(__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap).x); 
# 1349
} 
#endif
# 1352 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1352
__attribute((always_inline)) __attribute__((unused)) inline unsigned long long surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1353
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1355
::exit(___);}
#if 0
# 1353
{ 
# 1354
return __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap).x; 
# 1355
} 
#endif
# 1358 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1358
__attribute((always_inline)) __attribute__((unused)) inline longlong1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1359
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1361
::exit(___);}
#if 0
# 1359
{ 
# 1360
return make_longlong1((long long)(__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap).x)); 
# 1361
} 
#endif
# 1364 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1364
__attribute((always_inline)) __attribute__((unused)) inline ulonglong1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1365
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1367
::exit(___);}
#if 0
# 1365
{ 
# 1366
return __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap); 
# 1367
} 
#endif
# 1370 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1370
__attribute((always_inline)) __attribute__((unused)) inline longlong2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1371
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1375
::exit(___);}
#if 0
# 1371
{ 
# 1372
ulonglong2 tmp = __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap); 
# 1374
return make_longlong2((long long)(tmp.x), (long long)(tmp.y)); 
# 1375
} 
#endif
# 1378 "/usr/include/surface_functions.h" 3
template<> 
# 1168
__attribute((always_inline)) 
# 1378
__attribute((always_inline)) __attribute__((unused)) inline ulonglong2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1379
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1381
::exit(___);}
#if 0
# 1379
{ 
# 1380
return __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap); 
# 1381
} 
#endif
# 1444 "/usr/include/surface_functions.h" 3
template<> 
# 1168 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 1444 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1445
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1447
::exit(___);}
#if 0
# 1445
{ 
# 1446
return __int_as_float((int)(__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x)); 
# 1447
} 
#endif
# 1450 "/usr/include/surface_functions.h" 3
template<> 
# 1168 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 1450 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1451
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1453
::exit(___);}
#if 0
# 1451
{ 
# 1452
return make_float1(__int_as_float((int)(__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x))); 
# 1453
} 
#endif
# 1456 "/usr/include/surface_functions.h" 3
template<> 
# 1168 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 1456 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1457
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1461
::exit(___);}
#if 0
# 1457
{ 
# 1458
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
# 1460
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
# 1461
} 
#endif
# 1464 "/usr/include/surface_functions.h" 3
template<> 
# 1168 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 1464 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1465
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1469
::exit(___);}
#if 0
# 1465
{ 
# 1466
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
# 1468
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
# 1469
} 
#endif
# 1515 "/usr/include/surface_functions.h" 3
template< class T> 
# 1516
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(T *res, surface< void, 242>  surf, int x, int y, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1517
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
# 1524
::exit(___);}
#if 0
# 1517
{ 
# 1518
(s == 1) ? (void)((*((uchar1 *)res)) = __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 2) ? (void)((*((ushort1 *)res)) = __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 4) ? (void)((*((uint1 *)res)) = __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 8) ? (void)((*((uint2 *)res)) = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 16) ? (void)((*((uint4 *)res)) = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap)) : ((void)0))))); 
# 1524
} 
#endif
# 1526 "/usr/include/surface_functions.h" 3
template< class T> 
# 1527
__attribute((always_inline)) __attribute__((unused)) static inline T surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1528
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1534
::exit(___);}
#if 0
# 1528
{ 
# 1529
T tmp; 
# 1531
surf2DLayeredread(&tmp, surf, x, y, layer, (int)sizeof(T), mode); 
# 1533
return tmp; 
# 1534
} 
#endif
# 1536 "/usr/include/surface_functions.h" 3
template< class T> 
# 1537
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(T *res, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1538
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1540
::exit(___);}
#if 0
# 1538
{ 
# 1539
(*res) = surf2DLayeredread< T> (surf, x, y, layer, mode); 
# 1540
} 
#endif
# 1543 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1543
__attribute((always_inline)) __attribute__((unused)) inline char surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1544
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1546
::exit(___);}
#if 0
# 1544
{ 
# 1545
return (char)(__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x); 
# 1546
} 
#endif
# 1549 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1549
__attribute((always_inline)) __attribute__((unused)) inline signed char surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1550
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1552
::exit(___);}
#if 0
# 1550
{ 
# 1551
return (signed char)(__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x); 
# 1552
} 
#endif
# 1555 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1555
__attribute((always_inline)) __attribute__((unused)) inline unsigned char surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1556
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1558
::exit(___);}
#if 0
# 1556
{ 
# 1557
return __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x; 
# 1558
} 
#endif
# 1561 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1561
__attribute((always_inline)) __attribute__((unused)) inline char1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1562
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1564
::exit(___);}
#if 0
# 1562
{ 
# 1563
return make_char1((signed char)(__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x)); 
# 1564
} 
#endif
# 1567 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1567
__attribute((always_inline)) __attribute__((unused)) inline uchar1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1568
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1570
::exit(___);}
#if 0
# 1568
{ 
# 1569
return __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1570
} 
#endif
# 1573 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1573
__attribute((always_inline)) __attribute__((unused)) inline char2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1574
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1578
::exit(___);}
#if 0
# 1574
{ 
# 1575
uchar2 tmp = __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1577
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
# 1578
} 
#endif
# 1581 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1581
__attribute((always_inline)) __attribute__((unused)) inline uchar2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1582
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1584
::exit(___);}
#if 0
# 1582
{ 
# 1583
return __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1584
} 
#endif
# 1587 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1587
__attribute((always_inline)) __attribute__((unused)) inline char4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1588
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1592
::exit(___);}
#if 0
# 1588
{ 
# 1589
uchar4 tmp = __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1591
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
# 1592
} 
#endif
# 1595 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1595
__attribute((always_inline)) __attribute__((unused)) inline uchar4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1596
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1598
::exit(___);}
#if 0
# 1596
{ 
# 1597
return __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1598
} 
#endif
# 1601 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1601
__attribute((always_inline)) __attribute__((unused)) inline short surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1602
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1604
::exit(___);}
#if 0
# 1602
{ 
# 1603
return (short)(__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap).x); 
# 1604
} 
#endif
# 1607 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1607
__attribute((always_inline)) __attribute__((unused)) inline unsigned short surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1608
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1610
::exit(___);}
#if 0
# 1608
{ 
# 1609
return __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap).x; 
# 1610
} 
#endif
# 1613 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1613
__attribute((always_inline)) __attribute__((unused)) inline short1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1614
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1616
::exit(___);}
#if 0
# 1614
{ 
# 1615
return make_short1((signed short)(__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap).x)); 
# 1616
} 
#endif
# 1619 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1619
__attribute((always_inline)) __attribute__((unused)) inline ushort1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1620
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1622
::exit(___);}
#if 0
# 1620
{ 
# 1621
return __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1622
} 
#endif
# 1625 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1625
__attribute((always_inline)) __attribute__((unused)) inline short2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1626
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1630
::exit(___);}
#if 0
# 1626
{ 
# 1627
ushort2 tmp = __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1629
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
# 1630
} 
#endif
# 1633 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1633
__attribute((always_inline)) __attribute__((unused)) inline ushort2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1634
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1636
::exit(___);}
#if 0
# 1634
{ 
# 1635
return __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1636
} 
#endif
# 1639 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1639
__attribute((always_inline)) __attribute__((unused)) inline short4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1640
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1644
::exit(___);}
#if 0
# 1640
{ 
# 1641
ushort4 tmp = __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1643
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
# 1644
} 
#endif
# 1647 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1647
__attribute((always_inline)) __attribute__((unused)) inline ushort4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1648
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1650
::exit(___);}
#if 0
# 1648
{ 
# 1649
return __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1650
} 
#endif
# 1653 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1653
__attribute((always_inline)) __attribute__((unused)) inline int surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1654
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1656
::exit(___);}
#if 0
# 1654
{ 
# 1655
return (int)(__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x); 
# 1656
} 
#endif
# 1659 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1659
__attribute((always_inline)) __attribute__((unused)) inline unsigned surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1660
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1662
::exit(___);}
#if 0
# 1660
{ 
# 1661
return __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x; 
# 1662
} 
#endif
# 1665 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1665
__attribute((always_inline)) __attribute__((unused)) inline int1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1666
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1668
::exit(___);}
#if 0
# 1666
{ 
# 1667
return make_int1((signed int)(__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x)); 
# 1668
} 
#endif
# 1671 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1671
__attribute((always_inline)) __attribute__((unused)) inline uint1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1672
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1674
::exit(___);}
#if 0
# 1672
{ 
# 1673
return __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1674
} 
#endif
# 1677 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1677
__attribute((always_inline)) __attribute__((unused)) inline int2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1678
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1682
::exit(___);}
#if 0
# 1678
{ 
# 1679
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1681
return make_int2((int)(tmp.x), (int)(tmp.y)); 
# 1682
} 
#endif
# 1685 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1685
__attribute((always_inline)) __attribute__((unused)) inline uint2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1686
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1688
::exit(___);}
#if 0
# 1686
{ 
# 1687
return __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1688
} 
#endif
# 1691 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1691
__attribute((always_inline)) __attribute__((unused)) inline int4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1692
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1696
::exit(___);}
#if 0
# 1692
{ 
# 1693
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1695
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
# 1696
} 
#endif
# 1699 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1699
__attribute((always_inline)) __attribute__((unused)) inline uint4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1700
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1702
::exit(___);}
#if 0
# 1700
{ 
# 1701
return __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1702
} 
#endif
# 1705 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1705
__attribute((always_inline)) __attribute__((unused)) inline long long surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1706
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1708
::exit(___);}
#if 0
# 1706
{ 
# 1707
return (long long)(__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap).x); 
# 1708
} 
#endif
# 1711 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1711
__attribute((always_inline)) __attribute__((unused)) inline unsigned long long surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1712
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1714
::exit(___);}
#if 0
# 1712
{ 
# 1713
return __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap).x; 
# 1714
} 
#endif
# 1717 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1717
__attribute((always_inline)) __attribute__((unused)) inline longlong1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1718
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1720
::exit(___);}
#if 0
# 1718
{ 
# 1719
return make_longlong1((long long)(__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap).x)); 
# 1720
} 
#endif
# 1723 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1723
__attribute((always_inline)) __attribute__((unused)) inline ulonglong1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1724
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1726
::exit(___);}
#if 0
# 1724
{ 
# 1725
return __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1726
} 
#endif
# 1729 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1729
__attribute((always_inline)) __attribute__((unused)) inline longlong2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1730
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1734
::exit(___);}
#if 0
# 1730
{ 
# 1731
ulonglong2 tmp = __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1733
return make_longlong2((long long)(tmp.x), (long long)(tmp.y)); 
# 1734
} 
#endif
# 1737 "/usr/include/surface_functions.h" 3
template<> 
# 1527
__attribute((always_inline)) 
# 1737
__attribute((always_inline)) __attribute__((unused)) inline ulonglong2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1738
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1740
::exit(___);}
#if 0
# 1738
{ 
# 1739
return __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1740
} 
#endif
# 1803 "/usr/include/surface_functions.h" 3
template<> 
# 1527 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 1803 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1804
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1806
::exit(___);}
#if 0
# 1804
{ 
# 1805
return __int_as_float((int)(__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x)); 
# 1806
} 
#endif
# 1809 "/usr/include/surface_functions.h" 3
template<> 
# 1527 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 1809 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1810
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1812
::exit(___);}
#if 0
# 1810
{ 
# 1811
return make_float1(__int_as_float((int)(__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x))); 
# 1812
} 
#endif
# 1815 "/usr/include/surface_functions.h" 3
template<> 
# 1527 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 1815 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1816
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1820
::exit(___);}
#if 0
# 1816
{ 
# 1817
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1819
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
# 1820
} 
#endif
# 1823 "/usr/include/surface_functions.h" 3
template<> 
# 1527 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 1823 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1824
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1828
::exit(___);}
#if 0
# 1824
{ 
# 1825
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1827
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
# 1828
} 
#endif
# 1851 "/usr/include/surface_functions.h" 3
template< class T> 
# 1852
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(T *res, surface< void, 12>  surf, int x, int y, int face, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1853
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
# 1860
::exit(___);}
#if 0
# 1853
{ 
# 1854
(s == 1) ? (void)((*((uchar1 *)res)) = __surf2DLayeredreadc1(surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 2) ? (void)((*((ushort1 *)res)) = __surf2DLayeredreads1(surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 4) ? (void)((*((uint1 *)res)) = __surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 8) ? (void)((*((uint2 *)res)) = __surf2DLayeredreadu2(surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 16) ? (void)((*((uint4 *)res)) = __surf2DLayeredreadu4(surf, x, y, face, cudaBoundaryModeTrap)) : ((void)0))))); 
# 1860
} 
#endif
# 1862 "/usr/include/surface_functions.h" 3
template< class T> 
# 1863
__attribute((always_inline)) __attribute__((unused)) static inline T surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1864
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1870
::exit(___);}
#if 0
# 1864
{ 
# 1865
T tmp; 
# 1867
surfCubemapread(&tmp, surf, x, y, face, (int)sizeof(T), mode); 
# 1869
return tmp; 
# 1870
} 
#endif
# 1872 "/usr/include/surface_functions.h" 3
template< class T> 
# 1873
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(T *res, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1874
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1876
::exit(___);}
#if 0
# 1874
{ 
# 1875
(*res) = surfCubemapread< T> (surf, x, y, face, mode); 
# 1876
} 
#endif
# 1879 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1879
__attribute((always_inline)) __attribute__((unused)) inline char surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1880
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1882
::exit(___);}
#if 0
# 1880
{ 
# 1881
return (char)(__surf2DLayeredreadc1(surf, x, y, face, cudaBoundaryModeTrap).x); 
# 1882
} 
#endif
# 1885 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1885
__attribute((always_inline)) __attribute__((unused)) inline signed char surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1886
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1888
::exit(___);}
#if 0
# 1886
{ 
# 1887
return (signed char)(__surf2DLayeredreadc1(surf, x, y, face, cudaBoundaryModeTrap).x); 
# 1888
} 
#endif
# 1891 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1891
__attribute((always_inline)) __attribute__((unused)) inline unsigned char surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1892
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1894
::exit(___);}
#if 0
# 1892
{ 
# 1893
return __surf2DLayeredreadc1(surf, x, y, face, cudaBoundaryModeTrap).x; 
# 1894
} 
#endif
# 1897 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1897
__attribute((always_inline)) __attribute__((unused)) inline char1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1898
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1900
::exit(___);}
#if 0
# 1898
{ 
# 1899
return make_char1((signed char)(__surf2DLayeredreadc1(surf, x, y, face, cudaBoundaryModeTrap).x)); 
# 1900
} 
#endif
# 1903 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1903
__attribute((always_inline)) __attribute__((unused)) inline uchar1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1904
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1906
::exit(___);}
#if 0
# 1904
{ 
# 1905
return __surf2DLayeredreadc1(surf, x, y, face, cudaBoundaryModeTrap); 
# 1906
} 
#endif
# 1909 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1909
__attribute((always_inline)) __attribute__((unused)) inline char2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1910
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1914
::exit(___);}
#if 0
# 1910
{ 
# 1911
uchar2 tmp = __surf2DLayeredreadc2(surf, x, y, face, cudaBoundaryModeTrap); 
# 1913
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
# 1914
} 
#endif
# 1917 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1917
__attribute((always_inline)) __attribute__((unused)) inline uchar2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1918
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1920
::exit(___);}
#if 0
# 1918
{ 
# 1919
return __surf2DLayeredreadc2(surf, x, y, face, cudaBoundaryModeTrap); 
# 1920
} 
#endif
# 1923 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1923
__attribute((always_inline)) __attribute__((unused)) inline char4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1924
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1928
::exit(___);}
#if 0
# 1924
{ 
# 1925
uchar4 tmp = __surf2DLayeredreadc4(surf, x, y, face, cudaBoundaryModeTrap); 
# 1927
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
# 1928
} 
#endif
# 1931 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1931
__attribute((always_inline)) __attribute__((unused)) inline uchar4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1932
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1934
::exit(___);}
#if 0
# 1932
{ 
# 1933
return __surf2DLayeredreadc4(surf, x, y, face, cudaBoundaryModeTrap); 
# 1934
} 
#endif
# 1937 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1937
__attribute((always_inline)) __attribute__((unused)) inline short surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1938
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1940
::exit(___);}
#if 0
# 1938
{ 
# 1939
return (short)(__surf2DLayeredreads1(surf, x, y, face, cudaBoundaryModeTrap).x); 
# 1940
} 
#endif
# 1943 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1943
__attribute((always_inline)) __attribute__((unused)) inline unsigned short surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1944
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1946
::exit(___);}
#if 0
# 1944
{ 
# 1945
return __surf2DLayeredreads1(surf, x, y, face, cudaBoundaryModeTrap).x; 
# 1946
} 
#endif
# 1949 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1949
__attribute((always_inline)) __attribute__((unused)) inline short1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1950
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1952
::exit(___);}
#if 0
# 1950
{ 
# 1951
return make_short1((signed short)(__surf2DLayeredreads1(surf, x, y, face, cudaBoundaryModeTrap).x)); 
# 1952
} 
#endif
# 1955 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1955
__attribute((always_inline)) __attribute__((unused)) inline ushort1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1956
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1958
::exit(___);}
#if 0
# 1956
{ 
# 1957
return __surf2DLayeredreads1(surf, x, y, face, cudaBoundaryModeTrap); 
# 1958
} 
#endif
# 1961 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1961
__attribute((always_inline)) __attribute__((unused)) inline short2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1962
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1966
::exit(___);}
#if 0
# 1962
{ 
# 1963
ushort2 tmp = __surf2DLayeredreads2(surf, x, y, face, cudaBoundaryModeTrap); 
# 1965
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
# 1966
} 
#endif
# 1969 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1969
__attribute((always_inline)) __attribute__((unused)) inline ushort2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1970
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1972
::exit(___);}
#if 0
# 1970
{ 
# 1971
return __surf2DLayeredreads2(surf, x, y, face, cudaBoundaryModeTrap); 
# 1972
} 
#endif
# 1975 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1975
__attribute((always_inline)) __attribute__((unused)) inline short4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1976
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1980
::exit(___);}
#if 0
# 1976
{ 
# 1977
ushort4 tmp = __surf2DLayeredreads4(surf, x, y, face, cudaBoundaryModeTrap); 
# 1979
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
# 1980
} 
#endif
# 1983 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1983
__attribute((always_inline)) __attribute__((unused)) inline ushort4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1984
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1986
::exit(___);}
#if 0
# 1984
{ 
# 1985
return __surf2DLayeredreads4(surf, x, y, face, cudaBoundaryModeTrap); 
# 1986
} 
#endif
# 1989 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1989
__attribute((always_inline)) __attribute__((unused)) inline int surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1990
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1992
::exit(___);}
#if 0
# 1990
{ 
# 1991
return (int)(__surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap).x); 
# 1992
} 
#endif
# 1995 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 1995
__attribute((always_inline)) __attribute__((unused)) inline unsigned surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1996
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1998
::exit(___);}
#if 0
# 1996
{ 
# 1997
return __surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap).x; 
# 1998
} 
#endif
# 2001 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 2001
__attribute((always_inline)) __attribute__((unused)) inline int1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2002
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2004
::exit(___);}
#if 0
# 2002
{ 
# 2003
return make_int1((signed int)(__surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap).x)); 
# 2004
} 
#endif
# 2007 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 2007
__attribute((always_inline)) __attribute__((unused)) inline uint1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2008
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2010
::exit(___);}
#if 0
# 2008
{ 
# 2009
return __surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap); 
# 2010
} 
#endif
# 2013 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 2013
__attribute((always_inline)) __attribute__((unused)) inline int2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2014
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2018
::exit(___);}
#if 0
# 2014
{ 
# 2015
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
# 2017
return make_int2((int)(tmp.x), (int)(tmp.y)); 
# 2018
} 
#endif
# 2021 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 2021
__attribute((always_inline)) __attribute__((unused)) inline uint2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2022
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2024
::exit(___);}
#if 0
# 2022
{ 
# 2023
return __surf2DLayeredreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
# 2024
} 
#endif
# 2027 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 2027
__attribute((always_inline)) __attribute__((unused)) inline int4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2028
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2032
::exit(___);}
#if 0
# 2028
{ 
# 2029
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
# 2031
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
# 2032
} 
#endif
# 2035 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 2035
__attribute((always_inline)) __attribute__((unused)) inline uint4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2036
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2038
::exit(___);}
#if 0
# 2036
{ 
# 2037
return __surf2DLayeredreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
# 2038
} 
#endif
# 2041 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 2041
__attribute((always_inline)) __attribute__((unused)) inline long long surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2042
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2044
::exit(___);}
#if 0
# 2042
{ 
# 2043
return (long long)(__surf2DLayeredreadl1(surf, x, y, face, cudaBoundaryModeTrap).x); 
# 2044
} 
#endif
# 2047 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 2047
__attribute((always_inline)) __attribute__((unused)) inline unsigned long long surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2048
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2050
::exit(___);}
#if 0
# 2048
{ 
# 2049
return __surf2DLayeredreadl1(surf, x, y, face, cudaBoundaryModeTrap).x; 
# 2050
} 
#endif
# 2053 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 2053
__attribute((always_inline)) __attribute__((unused)) inline longlong1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2054
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2056
::exit(___);}
#if 0
# 2054
{ 
# 2055
return make_longlong1((long long)(__surf2DLayeredreadl1(surf, x, y, face, cudaBoundaryModeTrap).x)); 
# 2056
} 
#endif
# 2059 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 2059
__attribute((always_inline)) __attribute__((unused)) inline ulonglong1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2060
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2062
::exit(___);}
#if 0
# 2060
{ 
# 2061
return __surf2DLayeredreadl1(surf, x, y, face, cudaBoundaryModeTrap); 
# 2062
} 
#endif
# 2065 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 2065
__attribute((always_inline)) __attribute__((unused)) inline longlong2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2066
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2070
::exit(___);}
#if 0
# 2066
{ 
# 2067
ulonglong2 tmp = __surf2DLayeredreadl2(surf, x, y, face, cudaBoundaryModeTrap); 
# 2069
return make_longlong2((long long)(tmp.x), (long long)(tmp.y)); 
# 2070
} 
#endif
# 2073 "/usr/include/surface_functions.h" 3
template<> 
# 1863
__attribute((always_inline)) 
# 2073
__attribute((always_inline)) __attribute__((unused)) inline ulonglong2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2074
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2076
::exit(___);}
#if 0
# 2074
{ 
# 2075
return __surf2DLayeredreadl2(surf, x, y, face, cudaBoundaryModeTrap); 
# 2076
} 
#endif
# 2139 "/usr/include/surface_functions.h" 3
template<> 
# 1863 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 2139 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2140
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2142
::exit(___);}
#if 0
# 2140
{ 
# 2141
return __int_as_float((int)(__surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap).x)); 
# 2142
} 
#endif
# 2145 "/usr/include/surface_functions.h" 3
template<> 
# 1863 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 2145 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2146
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2148
::exit(___);}
#if 0
# 2146
{ 
# 2147
return make_float1(__int_as_float((int)(__surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap).x))); 
# 2148
} 
#endif
# 2151 "/usr/include/surface_functions.h" 3
template<> 
# 1863 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 2151 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2152
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2156
::exit(___);}
#if 0
# 2152
{ 
# 2153
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
# 2155
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
# 2156
} 
#endif
# 2159 "/usr/include/surface_functions.h" 3
template<> 
# 1863 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 2159 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2160
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2164
::exit(___);}
#if 0
# 2160
{ 
# 2161
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
# 2163
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
# 2164
} 
#endif
# 2188 "/usr/include/surface_functions.h" 3
template< class T> 
# 2189
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(T *res, surface< void, 252>  surf, int x, int y, int layerFace, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2190
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
# 2197
::exit(___);}
#if 0
# 2190
{ 
# 2191
(s == 1) ? (void)((*((uchar1 *)res)) = __surf2DLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 2) ? (void)((*((ushort1 *)res)) = __surf2DLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 4) ? (void)((*((uint1 *)res)) = __surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 8) ? (void)((*((uint2 *)res)) = __surf2DLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 16) ? (void)((*((uint4 *)res)) = __surf2DLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((void)0))))); 
# 2197
} 
#endif
# 2199 "/usr/include/surface_functions.h" 3
template< class T> 
# 2200
__attribute((always_inline)) __attribute__((unused)) static inline T surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2201
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2207
::exit(___);}
#if 0
# 2201
{ 
# 2202
T tmp; 
# 2204
surfCubemapLayeredread(&tmp, surf, x, y, layerFace, (int)sizeof(T), mode); 
# 2206
return tmp; 
# 2207
} 
#endif
# 2209 "/usr/include/surface_functions.h" 3
template< class T> 
# 2210
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(T *res, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2211
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2213
::exit(___);}
#if 0
# 2211
{ 
# 2212
(*res) = surfCubemapLayeredread< T> (surf, x, y, layerFace, mode); 
# 2213
} 
#endif
# 2216 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2216
__attribute((always_inline)) __attribute__((unused)) inline char surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2217
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2219
::exit(___);}
#if 0
# 2217
{ 
# 2218
return (char)(__surf2DLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x); 
# 2219
} 
#endif
# 2222 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2222
__attribute((always_inline)) __attribute__((unused)) inline signed char surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2223
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2225
::exit(___);}
#if 0
# 2223
{ 
# 2224
return (signed char)(__surf2DLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x); 
# 2225
} 
#endif
# 2228 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2228
__attribute((always_inline)) __attribute__((unused)) inline unsigned char surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2229
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2231
::exit(___);}
#if 0
# 2229
{ 
# 2230
return __surf2DLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x; 
# 2231
} 
#endif
# 2234 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2234
__attribute((always_inline)) __attribute__((unused)) inline char1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2235
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2237
::exit(___);}
#if 0
# 2235
{ 
# 2236
return make_char1((signed char)(__surf2DLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x)); 
# 2237
} 
#endif
# 2240 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2240
__attribute((always_inline)) __attribute__((unused)) inline uchar1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2241
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2243
::exit(___);}
#if 0
# 2241
{ 
# 2242
return __surf2DLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2243
} 
#endif
# 2246 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2246
__attribute((always_inline)) __attribute__((unused)) inline char2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2247
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2251
::exit(___);}
#if 0
# 2247
{ 
# 2248
uchar2 tmp = __surf2DLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2250
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
# 2251
} 
#endif
# 2254 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2254
__attribute((always_inline)) __attribute__((unused)) inline uchar2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2255
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2257
::exit(___);}
#if 0
# 2255
{ 
# 2256
return __surf2DLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2257
} 
#endif
# 2260 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2260
__attribute((always_inline)) __attribute__((unused)) inline char4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2261
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2265
::exit(___);}
#if 0
# 2261
{ 
# 2262
uchar4 tmp = __surf2DLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2264
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
# 2265
} 
#endif
# 2268 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2268
__attribute((always_inline)) __attribute__((unused)) inline uchar4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2269
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2271
::exit(___);}
#if 0
# 2269
{ 
# 2270
return __surf2DLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2271
} 
#endif
# 2274 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2274
__attribute((always_inline)) __attribute__((unused)) inline short surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2275
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2277
::exit(___);}
#if 0
# 2275
{ 
# 2276
return (short)(__surf2DLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap).x); 
# 2277
} 
#endif
# 2280 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2280
__attribute((always_inline)) __attribute__((unused)) inline unsigned short surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2281
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2283
::exit(___);}
#if 0
# 2281
{ 
# 2282
return __surf2DLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap).x; 
# 2283
} 
#endif
# 2286 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2286
__attribute((always_inline)) __attribute__((unused)) inline short1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2287
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2289
::exit(___);}
#if 0
# 2287
{ 
# 2288
return make_short1((signed short)(__surf2DLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap).x)); 
# 2289
} 
#endif
# 2292 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2292
__attribute((always_inline)) __attribute__((unused)) inline ushort1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2293
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2295
::exit(___);}
#if 0
# 2293
{ 
# 2294
return __surf2DLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2295
} 
#endif
# 2298 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2298
__attribute((always_inline)) __attribute__((unused)) inline short2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2299
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2303
::exit(___);}
#if 0
# 2299
{ 
# 2300
ushort2 tmp = __surf2DLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2302
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
# 2303
} 
#endif
# 2306 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2306
__attribute((always_inline)) __attribute__((unused)) inline ushort2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2307
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2309
::exit(___);}
#if 0
# 2307
{ 
# 2308
return __surf2DLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2309
} 
#endif
# 2312 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2312
__attribute((always_inline)) __attribute__((unused)) inline short4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2313
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2317
::exit(___);}
#if 0
# 2313
{ 
# 2314
ushort4 tmp = __surf2DLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2316
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
# 2317
} 
#endif
# 2320 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2320
__attribute((always_inline)) __attribute__((unused)) inline ushort4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2321
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2323
::exit(___);}
#if 0
# 2321
{ 
# 2322
return __surf2DLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2323
} 
#endif
# 2326 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2326
__attribute((always_inline)) __attribute__((unused)) inline int surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2327
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2329
::exit(___);}
#if 0
# 2327
{ 
# 2328
return (int)(__surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x); 
# 2329
} 
#endif
# 2332 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2332
__attribute((always_inline)) __attribute__((unused)) inline unsigned surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2333
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2335
::exit(___);}
#if 0
# 2333
{ 
# 2334
return __surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x; 
# 2335
} 
#endif
# 2338 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2338
__attribute((always_inline)) __attribute__((unused)) inline int1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2339
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2341
::exit(___);}
#if 0
# 2339
{ 
# 2340
return make_int1((signed int)(__surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x)); 
# 2341
} 
#endif
# 2344 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2344
__attribute((always_inline)) __attribute__((unused)) inline uint1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2345
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2347
::exit(___);}
#if 0
# 2345
{ 
# 2346
return __surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2347
} 
#endif
# 2350 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2350
__attribute((always_inline)) __attribute__((unused)) inline int2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2351
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2355
::exit(___);}
#if 0
# 2351
{ 
# 2352
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2354
return make_int2((int)(tmp.x), (int)(tmp.y)); 
# 2355
} 
#endif
# 2358 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2358
__attribute((always_inline)) __attribute__((unused)) inline uint2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2359
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2361
::exit(___);}
#if 0
# 2359
{ 
# 2360
return __surf2DLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2361
} 
#endif
# 2364 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2364
__attribute((always_inline)) __attribute__((unused)) inline int4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2365
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2369
::exit(___);}
#if 0
# 2365
{ 
# 2366
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2368
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
# 2369
} 
#endif
# 2372 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2372
__attribute((always_inline)) __attribute__((unused)) inline uint4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2373
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2375
::exit(___);}
#if 0
# 2373
{ 
# 2374
return __surf2DLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2375
} 
#endif
# 2378 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2378
__attribute((always_inline)) __attribute__((unused)) inline long long surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2379
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2381
::exit(___);}
#if 0
# 2379
{ 
# 2380
return (long long)(__surf2DLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap).x); 
# 2381
} 
#endif
# 2384 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2384
__attribute((always_inline)) __attribute__((unused)) inline unsigned long long surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2385
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2387
::exit(___);}
#if 0
# 2385
{ 
# 2386
return __surf2DLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap).x; 
# 2387
} 
#endif
# 2390 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2390
__attribute((always_inline)) __attribute__((unused)) inline longlong1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2391
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2393
::exit(___);}
#if 0
# 2391
{ 
# 2392
return make_longlong1((long long)(__surf2DLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap).x)); 
# 2393
} 
#endif
# 2396 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2396
__attribute((always_inline)) __attribute__((unused)) inline ulonglong1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2397
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2399
::exit(___);}
#if 0
# 2397
{ 
# 2398
return __surf2DLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2399
} 
#endif
# 2402 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2402
__attribute((always_inline)) __attribute__((unused)) inline longlong2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2403
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2407
::exit(___);}
#if 0
# 2403
{ 
# 2404
ulonglong2 tmp = __surf2DLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2406
return make_longlong2((long long)(tmp.x), (long long)(tmp.y)); 
# 2407
} 
#endif
# 2410 "/usr/include/surface_functions.h" 3
template<> 
# 2200
__attribute((always_inline)) 
# 2410
__attribute((always_inline)) __attribute__((unused)) inline ulonglong2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2411
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2413
::exit(___);}
#if 0
# 2411
{ 
# 2412
return __surf2DLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2413
} 
#endif
# 2476 "/usr/include/surface_functions.h" 3
template<> 
# 2200 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 2476 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2477
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2479
::exit(___);}
#if 0
# 2477
{ 
# 2478
return __int_as_float((int)(__surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x)); 
# 2479
} 
#endif
# 2482 "/usr/include/surface_functions.h" 3
template<> 
# 2200 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 2482 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2483
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2485
::exit(___);}
#if 0
# 2483
{ 
# 2484
return make_float1(__int_as_float((int)(__surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x))); 
# 2485
} 
#endif
# 2488 "/usr/include/surface_functions.h" 3
template<> 
# 2200 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 2488 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2489
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2493
::exit(___);}
#if 0
# 2489
{ 
# 2490
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2492
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
# 2493
} 
#endif
# 2496 "/usr/include/surface_functions.h" 3
template<> 
# 2200 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) 
# 2496 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) inline float4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2497
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2501
::exit(___);}
#if 0
# 2497
{ 
# 2498
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2500
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
# 2501
} 
#endif
# 2537 "/usr/include/surface_functions.h" 3
template< class T> 
# 2538
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(T val, surface< void, 1>  surf, int x, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2539
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)s;(void)mode;
# 2557
::exit(___);}
#if 0
# 2539
{ 
# 2540
union { 
# 2541
T val; 
# 2542
uchar1 c1; 
# 2543
ushort1 s1; 
# 2544
uint1 u1; 
# 2545
uint2 u2; 
# 2546
uint4 u4; 
# 2547
} tmp; 
# 2549
(tmp.val) = val; 
# 2551
(s == 1) ? (void)__surf1Dwritec1(tmp.c1, surf, x, cudaBoundaryModeTrap) : ((s == 2) ? (void)__surf1Dwrites1(tmp.s1, surf, x, cudaBoundaryModeTrap) : ((s == 4) ? (void)__surf1Dwriteu1(tmp.u1, surf, x, cudaBoundaryModeTrap) : ((s == 8) ? (void)__surf1Dwriteu2(tmp.u2, surf, x, cudaBoundaryModeTrap) : ((s == 16) ? (void)__surf1Dwriteu4(tmp.u4, surf, x, cudaBoundaryModeTrap) : ((void)0))))); 
# 2557
} 
#endif
# 2559 "/usr/include/surface_functions.h" 3
template< class T> 
# 2560
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(T val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2561
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2563
::exit(___);}
#if 0
# 2561
{ ; 
# 2562
surf1Dwrite(val, surf, x, (int)sizeof(T), mode); 
# 2563
} 
#endif
# 2566 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2568
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(signed char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2570
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2572
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2574
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2576
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2578
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2580
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2582
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2584
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2586
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned short val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2588
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2590
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2592
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2594
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2596
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2598
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2600
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2602
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2604
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2606
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2608
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2610
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2612
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2614
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2616
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(long long val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2618
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned long long val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2620
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(longlong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2622
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ulonglong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2624
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(longlong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2626
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ulonglong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2648 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2650
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2652
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2654
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2690 "/usr/include/surface_functions.h" 3
template< class T> 
# 2691
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(T val, surface< void, 2>  surf, int x, int y, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2692
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)s;(void)mode;
# 2710
::exit(___);}
#if 0
# 2692
{ 
# 2693
union { 
# 2694
T val; 
# 2695
uchar1 c1; 
# 2696
ushort1 s1; 
# 2697
uint1 u1; 
# 2698
uint2 u2; 
# 2699
uint4 u4; 
# 2700
} tmp; 
# 2702
(tmp.val) = val; 
# 2704
(s == 1) ? (void)__surf2Dwritec1(tmp.c1, surf, x, y, cudaBoundaryModeTrap) : ((s == 2) ? (void)__surf2Dwrites1(tmp.s1, surf, x, y, cudaBoundaryModeTrap) : ((s == 4) ? (void)__surf2Dwriteu1(tmp.u1, surf, x, y, cudaBoundaryModeTrap) : ((s == 8) ? (void)__surf2Dwriteu2(tmp.u2, surf, x, y, cudaBoundaryModeTrap) : ((s == 16) ? (void)__surf2Dwriteu4(tmp.u4, surf, x, y, cudaBoundaryModeTrap) : ((void)0))))); 
# 2710
} 
#endif
# 2712 "/usr/include/surface_functions.h" 3
template< class T> 
# 2713
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(T val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2714
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2716
::exit(___);}
#if 0
# 2714
{ ; 
# 2715
surf2Dwrite(val, surf, x, y, (int)sizeof(T), mode); 
# 2716
} 
#endif
# 2719 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2721
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(signed char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2723
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2725
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2727
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2729
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2731
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2733
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2735
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2737
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2739
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned short val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2741
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2743
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2745
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2747
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2749
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2751
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2753
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2755
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2757
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2759
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2761
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2763
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2765
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2767
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2769
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(long long val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2771
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned long long val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2773
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(longlong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2775
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ulonglong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2777
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(longlong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2779
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ulonglong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2801 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2803
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2805
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2807
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2843 "/usr/include/surface_functions.h" 3
template< class T> 
# 2844
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(T val, surface< void, 3>  surf, int x, int y, int z, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2845
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
# 2863
::exit(___);}
#if 0
# 2845
{ 
# 2846
union { 
# 2847
T val; 
# 2848
uchar1 c1; 
# 2849
ushort1 s1; 
# 2850
uint1 u1; 
# 2851
uint2 u2; 
# 2852
uint4 u4; 
# 2853
} tmp; 
# 2855
(tmp.val) = val; 
# 2857
(s == 1) ? (void)__surf3Dwritec1(tmp.c1, surf, x, y, z, cudaBoundaryModeTrap) : ((s == 2) ? (void)__surf3Dwrites1(tmp.s1, surf, x, y, z, cudaBoundaryModeTrap) : ((s == 4) ? (void)__surf3Dwriteu1(tmp.u1, surf, x, y, z, cudaBoundaryModeTrap) : ((s == 8) ? (void)__surf3Dwriteu2(tmp.u2, surf, x, y, z, cudaBoundaryModeTrap) : ((s == 16) ? (void)__surf3Dwriteu4(tmp.u4, surf, x, y, z, cudaBoundaryModeTrap) : ((void)0))))); 
# 2863
} 
#endif
# 2865 "/usr/include/surface_functions.h" 3
template< class T> 
# 2866
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(T val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2867
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 2869
::exit(___);}
#if 0
# 2867
{ ; 
# 2868
surf3Dwrite(val, surf, x, y, z, (int)sizeof(T), mode); 
# 2869
} 
#endif
# 2872 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2874
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(signed char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2876
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2878
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2880
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2882
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2884
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2886
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2888
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2890
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2892
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned short val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2894
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2896
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2898
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2900
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2902
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2904
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2906
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2908
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2910
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2912
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2914
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2916
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2918
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2920
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2922
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(long long val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2924
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned long long val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2926
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(longlong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2928
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ulonglong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2930
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(longlong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2932
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ulonglong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2954 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2956
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2958
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2960
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 2996 "/usr/include/surface_functions.h" 3
template< class T> 
# 2997
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(T val, surface< void, 241>  surf, int x, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2998
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
# 3016
::exit(___);}
#if 0
# 2998
{ 
# 2999
union { 
# 3000
T val; 
# 3001
uchar1 c1; 
# 3002
ushort1 s1; 
# 3003
uint1 u1; 
# 3004
uint2 u2; 
# 3005
uint4 u4; 
# 3006
} tmp; 
# 3008
(tmp.val) = val; 
# 3010
(s == 1) ? (void)__surf1DLayeredwritec1(tmp.c1, surf, x, layer, cudaBoundaryModeTrap) : ((s == 2) ? (void)__surf1DLayeredwrites1(tmp.s1, surf, x, layer, cudaBoundaryModeTrap) : ((s == 4) ? (void)__surf1DLayeredwriteu1(tmp.u1, surf, x, layer, cudaBoundaryModeTrap) : ((s == 8) ? (void)__surf1DLayeredwriteu2(tmp.u2, surf, x, layer, cudaBoundaryModeTrap) : ((s == 16) ? (void)__surf1DLayeredwriteu4(tmp.u4, surf, x, layer, cudaBoundaryModeTrap) : ((void)0))))); 
# 3016
} 
#endif
# 3018 "/usr/include/surface_functions.h" 3
template< class T> 
# 3019
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(T val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3020
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3022
::exit(___);}
#if 0
# 3020
{ ; 
# 3021
surf1DLayeredwrite(val, surf, x, layer, (int)sizeof(T), mode); 
# 3022
} 
#endif
# 3025 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3027
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(signed char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3029
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3031
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3033
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3035
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3037
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3039
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3041
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3043
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3045
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned short val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3047
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3049
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3051
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3053
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3055
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3057
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3059
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3061
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3063
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3065
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3067
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3069
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3071
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3073
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3075
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(long long val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3077
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned long long val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3079
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(longlong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3081
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ulonglong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3083
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(longlong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3085
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ulonglong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3107 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3109
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3111
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3113
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3160 "/usr/include/surface_functions.h" 3
template< class T> 
# 3161
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(T val, surface< void, 242>  surf, int x, int y, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3162
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
# 3180
::exit(___);}
#if 0
# 3162
{ 
# 3163
union { 
# 3164
T val; 
# 3165
uchar1 c1; 
# 3166
ushort1 s1; 
# 3167
uint1 u1; 
# 3168
uint2 u2; 
# 3169
uint4 u4; 
# 3170
} tmp; 
# 3172
(tmp.val) = val; 
# 3174
(s == 1) ? (void)__surf2DLayeredwritec1(tmp.c1, surf, x, y, layer, cudaBoundaryModeTrap) : ((s == 2) ? (void)__surf2DLayeredwrites1(tmp.s1, surf, x, y, layer, cudaBoundaryModeTrap) : ((s == 4) ? (void)__surf2DLayeredwriteu1(tmp.u1, surf, x, y, layer, cudaBoundaryModeTrap) : ((s == 8) ? (void)__surf2DLayeredwriteu2(tmp.u2, surf, x, y, layer, cudaBoundaryModeTrap) : ((s == 16) ? (void)__surf2DLayeredwriteu4(tmp.u4, surf, x, y, layer, cudaBoundaryModeTrap) : ((void)0))))); 
# 3180
} 
#endif
# 3182 "/usr/include/surface_functions.h" 3
template< class T> 
# 3183
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(T val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3184
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3186
::exit(___);}
#if 0
# 3184
{ ; 
# 3185
surf2DLayeredwrite(val, surf, x, y, layer, (int)sizeof(T), mode); 
# 3186
} 
#endif
# 3189 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3191
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(signed char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3193
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3195
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3197
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3199
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3201
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3203
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3205
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3207
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3209
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned short val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3211
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3213
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3215
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3217
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3219
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3221
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3223
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3225
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3227
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3229
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3231
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3233
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3235
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3237
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3239
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(long long val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3241
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned long long val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3243
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(longlong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3245
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ulonglong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3247
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(longlong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3249
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ulonglong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3271 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3273
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3275
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3277
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3302 "/usr/include/surface_functions.h" 3
template< class T> 
# 3303
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(T val, surface< void, 12>  surf, int x, int y, int face, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3304
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
# 3322
::exit(___);}
#if 0
# 3304
{ 
# 3305
union { 
# 3306
T val; 
# 3307
uchar1 c1; 
# 3308
ushort1 s1; 
# 3309
uint1 u1; 
# 3310
uint2 u2; 
# 3311
uint4 u4; 
# 3312
} tmp; 
# 3314
(tmp.val) = val; 
# 3316
(s == 1) ? (void)__surf2DLayeredwritec1(tmp.c1, surf, x, y, face, cudaBoundaryModeTrap) : ((s == 2) ? (void)__surf2DLayeredwrites1(tmp.s1, surf, x, y, face, cudaBoundaryModeTrap) : ((s == 4) ? (void)__surf2DLayeredwriteu1(tmp.u1, surf, x, y, face, cudaBoundaryModeTrap) : ((s == 8) ? (void)__surf2DLayeredwriteu2(tmp.u2, surf, x, y, face, cudaBoundaryModeTrap) : ((s == 16) ? (void)__surf2DLayeredwriteu4(tmp.u4, surf, x, y, face, cudaBoundaryModeTrap) : ((void)0))))); 
# 3322
} 
#endif
# 3324 "/usr/include/surface_functions.h" 3
template< class T> 
# 3325
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(T val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3326
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 3328
::exit(___);}
#if 0
# 3326
{ 
# 3327
surfCubemapwrite(val, surf, x, y, face, (int)sizeof(T), mode); 
# 3328
} 
#endif
# 3331 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3333
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(signed char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3335
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3337
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3339
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3341
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3343
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3345
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3347
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3349
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3351
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned short val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3353
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3355
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3357
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3359
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3361
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3363
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3365
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3367
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3369
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3371
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3373
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3375
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3377
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3379
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3381
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(long long val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3383
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned long long val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3385
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(longlong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3387
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ulonglong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3389
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(longlong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3391
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ulonglong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3413 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3415
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3417
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3419
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3444 "/usr/include/surface_functions.h" 3
template< class T> 
# 3445
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(T val, surface< void, 252>  surf, int x, int y, int layerFace, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3446
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
# 3464
::exit(___);}
#if 0
# 3446
{ 
# 3447
union { 
# 3448
T val; 
# 3449
uchar1 c1; 
# 3450
ushort1 s1; 
# 3451
uint1 u1; 
# 3452
uint2 u2; 
# 3453
uint4 u4; 
# 3454
} tmp; 
# 3456
(tmp.val) = val; 
# 3458
(s == 1) ? (void)__surf2DLayeredwritec1(tmp.c1, surf, x, y, layerFace, cudaBoundaryModeTrap) : ((s == 2) ? (void)__surf2DLayeredwrites1(tmp.s1, surf, x, y, layerFace, cudaBoundaryModeTrap) : ((s == 4) ? (void)__surf2DLayeredwriteu1(tmp.u1, surf, x, y, layerFace, cudaBoundaryModeTrap) : ((s == 8) ? (void)__surf2DLayeredwriteu2(tmp.u2, surf, x, y, layerFace, cudaBoundaryModeTrap) : ((s == 16) ? (void)__surf2DLayeredwriteu4(tmp.u4, surf, x, y, layerFace, cudaBoundaryModeTrap) : ((void)0))))); 
# 3464
} 
#endif
# 3466 "/usr/include/surface_functions.h" 3
template< class T> 
# 3467
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(T val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3468
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 3470
::exit(___);}
#if 0
# 3468
{ ; 
# 3469
surfCubemapLayeredwrite(val, surf, x, y, layerFace, (int)sizeof(T), mode); 
# 3470
} 
#endif
# 3473 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3475
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(signed char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3477
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3479
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3481
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3483
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3485
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3487
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3489
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3491
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3493
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned short val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3495
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3497
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3499
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3501
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3503
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3505
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3507
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3509
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3511
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3513
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3515
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3517
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3519
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3521
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3523
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(long long val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3525
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned long long val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3527
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(longlong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3529
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ulonglong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3531
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(longlong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3533
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ulonglong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3555 "/usr/include/surface_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3557
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3559
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 3561
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
# 94 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 95
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 97
::exit(___);}
#if 0
# 95
{ 
# 96
__surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap); 
# 97
} 
#endif
# 99 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(signed char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 100
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 102
::exit(___);}
#if 0
# 100
{ 
# 101
__surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap); 
# 102
} 
#endif
# 104 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 105
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 107
::exit(___);}
#if 0
# 105
{ 
# 106
__surf1Dwritec1(make_uchar1(val), surf, x, cudaBoundaryModeTrap); 
# 107
} 
#endif
# 109 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 110
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 112
::exit(___);}
#if 0
# 110
{ 
# 111
__surf1Dwritec1(make_uchar1((unsigned char)(val.x)), surf, x, cudaBoundaryModeTrap); 
# 112
} 
#endif
# 114 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 115
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 117
::exit(___);}
#if 0
# 115
{ 
# 116
__surf1Dwritec1(val, surf, x, cudaBoundaryModeTrap); 
# 117
} 
#endif
# 119 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 120
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 122
::exit(___);}
#if 0
# 120
{ 
# 121
__surf1Dwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, cudaBoundaryModeTrap); 
# 122
} 
#endif
# 124 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 125
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 127
::exit(___);}
#if 0
# 125
{ 
# 126
__surf1Dwritec2(val, surf, x, cudaBoundaryModeTrap); 
# 127
} 
#endif
# 129 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 130
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 132
::exit(___);}
#if 0
# 130
{ 
# 131
__surf1Dwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, cudaBoundaryModeTrap); 
# 132
} 
#endif
# 134 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 135
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 137
::exit(___);}
#if 0
# 135
{ 
# 136
__surf1Dwritec4(val, surf, x, cudaBoundaryModeTrap); 
# 137
} 
#endif
# 139 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 140
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 142
::exit(___);}
#if 0
# 140
{ 
# 141
__surf1Dwrites1(make_ushort1((unsigned short)val), surf, x, cudaBoundaryModeTrap); 
# 142
} 
#endif
# 144 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned short val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 145
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 147
::exit(___);}
#if 0
# 145
{ 
# 146
__surf1Dwrites1(make_ushort1(val), surf, x, cudaBoundaryModeTrap); 
# 147
} 
#endif
# 149 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 150
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 152
::exit(___);}
#if 0
# 150
{ 
# 151
__surf1Dwrites1(make_ushort1((unsigned short)(val.x)), surf, x, cudaBoundaryModeTrap); 
# 152
} 
#endif
# 154 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 155
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 157
::exit(___);}
#if 0
# 155
{ 
# 156
__surf1Dwrites1(val, surf, x, cudaBoundaryModeTrap); 
# 157
} 
#endif
# 159 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 160
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 162
::exit(___);}
#if 0
# 160
{ 
# 161
__surf1Dwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, cudaBoundaryModeTrap); 
# 162
} 
#endif
# 164 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 165
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 167
::exit(___);}
#if 0
# 165
{ 
# 166
__surf1Dwrites2(val, surf, x, cudaBoundaryModeTrap); 
# 167
} 
#endif
# 169 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 170
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 172
::exit(___);}
#if 0
# 170
{ 
# 171
__surf1Dwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, cudaBoundaryModeTrap); 
# 172
} 
#endif
# 174 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 175
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 177
::exit(___);}
#if 0
# 175
{ 
# 176
__surf1Dwrites4(val, surf, x, cudaBoundaryModeTrap); 
# 177
} 
#endif
# 179 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 180
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 182
::exit(___);}
#if 0
# 180
{ 
# 181
__surf1Dwriteu1(make_uint1((unsigned)val), surf, x, cudaBoundaryModeTrap); 
# 182
} 
#endif
# 184 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 185
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 187
::exit(___);}
#if 0
# 185
{ 
# 186
__surf1Dwriteu1(make_uint1(val), surf, x, cudaBoundaryModeTrap); 
# 187
} 
#endif
# 189 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 190
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 192
::exit(___);}
#if 0
# 190
{ 
# 191
__surf1Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, cudaBoundaryModeTrap); 
# 192
} 
#endif
# 194 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 195
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 197
::exit(___);}
#if 0
# 195
{ 
# 196
__surf1Dwriteu1(val, surf, x, cudaBoundaryModeTrap); 
# 197
} 
#endif
# 199 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 200
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 202
::exit(___);}
#if 0
# 200
{ 
# 201
__surf1Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, cudaBoundaryModeTrap); 
# 202
} 
#endif
# 204 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 205
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 207
::exit(___);}
#if 0
# 205
{ 
# 206
__surf1Dwriteu2(val, surf, x, cudaBoundaryModeTrap); 
# 207
} 
#endif
# 209 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 210
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 212
::exit(___);}
#if 0
# 210
{ 
# 211
__surf1Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, cudaBoundaryModeTrap); 
# 212
} 
#endif
# 214 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 215
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 217
::exit(___);}
#if 0
# 215
{ 
# 216
__surf1Dwriteu4(val, surf, x, cudaBoundaryModeTrap); 
# 217
} 
#endif
# 219 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(long long val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 220
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 222
::exit(___);}
#if 0
# 220
{ 
# 221
__surf1Dwritel1(make_ulonglong1((unsigned long long)val), surf, x, cudaBoundaryModeTrap); 
# 222
} 
#endif
# 224 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned long long val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 225
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 227
::exit(___);}
#if 0
# 225
{ 
# 226
__surf1Dwritel1(make_ulonglong1(val), surf, x, cudaBoundaryModeTrap); 
# 227
} 
#endif
# 229 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(longlong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 230
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 232
::exit(___);}
#if 0
# 230
{ 
# 231
__surf1Dwritel1(make_ulonglong1((unsigned long long)(val.x)), surf, x, cudaBoundaryModeTrap); 
# 232
} 
#endif
# 234 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ulonglong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 235
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 237
::exit(___);}
#if 0
# 235
{ 
# 236
__surf1Dwritel1(val, surf, x, cudaBoundaryModeTrap); 
# 237
} 
#endif
# 239 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(longlong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 240
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 242
::exit(___);}
#if 0
# 240
{ 
# 241
__surf1Dwritel2(make_ulonglong2((unsigned long long)(val.x), (unsigned long long)(val.y)), surf, x, cudaBoundaryModeTrap); 
# 242
} 
#endif
# 244 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ulonglong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 245
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 247
::exit(___);}
#if 0
# 245
{ 
# 246
__surf1Dwritel2(val, surf, x, cudaBoundaryModeTrap); 
# 247
} 
#endif
# 293 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 294
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 296
::exit(___);}
#if 0
# 294
{ 
# 295
__surf1Dwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, cudaBoundaryModeTrap); 
# 296
} 
#endif
# 298 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 299
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 301
::exit(___);}
#if 0
# 299
{ 
# 300
__surf1Dwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, cudaBoundaryModeTrap); 
# 301
} 
#endif
# 303 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 304
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 306
::exit(___);}
#if 0
# 304
{ 
# 305
__surf1Dwriteu2(make_uint2((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y)), surf, x, cudaBoundaryModeTrap); 
# 306
} 
#endif
# 308 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 309
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 311
::exit(___);}
#if 0
# 309
{ 
# 310
__surf1Dwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, cudaBoundaryModeTrap); 
# 311
} 
#endif
# 336 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 337
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 339
::exit(___);}
#if 0
# 337
{ 
# 338
__surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap); 
# 339
} 
#endif
# 341 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(signed char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 342
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 344
::exit(___);}
#if 0
# 342
{ 
# 343
__surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap); 
# 344
} 
#endif
# 346 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 347
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 349
::exit(___);}
#if 0
# 347
{ 
# 348
__surf2Dwritec1(make_uchar1(val), surf, x, y, cudaBoundaryModeTrap); 
# 349
} 
#endif
# 351 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 352
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 354
::exit(___);}
#if 0
# 352
{ 
# 353
__surf2Dwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
# 354
} 
#endif
# 356 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 357
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 359
::exit(___);}
#if 0
# 357
{ 
# 358
__surf2Dwritec1(val, surf, x, y, cudaBoundaryModeTrap); 
# 359
} 
#endif
# 361 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 362
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 364
::exit(___);}
#if 0
# 362
{ 
# 363
__surf2Dwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
# 364
} 
#endif
# 366 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 367
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 369
::exit(___);}
#if 0
# 367
{ 
# 368
__surf2Dwritec2(val, surf, x, y, cudaBoundaryModeTrap); 
# 369
} 
#endif
# 371 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 372
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 374
::exit(___);}
#if 0
# 372
{ 
# 373
__surf2Dwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
# 374
} 
#endif
# 376 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 377
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 379
::exit(___);}
#if 0
# 377
{ 
# 378
__surf2Dwritec4(val, surf, x, y, cudaBoundaryModeTrap); 
# 379
} 
#endif
# 381 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 382
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 384
::exit(___);}
#if 0
# 382
{ 
# 383
__surf2Dwrites1(make_ushort1((unsigned short)val), surf, x, y, cudaBoundaryModeTrap); 
# 384
} 
#endif
# 386 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned short val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 387
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 389
::exit(___);}
#if 0
# 387
{ 
# 388
__surf2Dwrites1(make_ushort1(val), surf, x, y, cudaBoundaryModeTrap); 
# 389
} 
#endif
# 391 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 392
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 394
::exit(___);}
#if 0
# 392
{ 
# 393
__surf2Dwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
# 394
} 
#endif
# 396 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 397
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 399
::exit(___);}
#if 0
# 397
{ 
# 398
__surf2Dwrites1(val, surf, x, y, cudaBoundaryModeTrap); 
# 399
} 
#endif
# 401 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 402
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 404
::exit(___);}
#if 0
# 402
{ 
# 403
__surf2Dwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
# 404
} 
#endif
# 406 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 407
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 409
::exit(___);}
#if 0
# 407
{ 
# 408
__surf2Dwrites2(val, surf, x, y, cudaBoundaryModeTrap); 
# 409
} 
#endif
# 411 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 412
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 414
::exit(___);}
#if 0
# 412
{ 
# 413
__surf2Dwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
# 414
} 
#endif
# 416 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 417
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 419
::exit(___);}
#if 0
# 417
{ 
# 418
__surf2Dwrites4(val, surf, x, y, cudaBoundaryModeTrap); 
# 419
} 
#endif
# 421 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 422
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 424
::exit(___);}
#if 0
# 422
{ 
# 423
__surf2Dwriteu1(make_uint1((unsigned)val), surf, x, y, cudaBoundaryModeTrap); 
# 424
} 
#endif
# 426 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 427
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 429
::exit(___);}
#if 0
# 427
{ 
# 428
__surf2Dwriteu1(make_uint1(val), surf, x, y, cudaBoundaryModeTrap); 
# 429
} 
#endif
# 431 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 432
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 434
::exit(___);}
#if 0
# 432
{ 
# 433
__surf2Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
# 434
} 
#endif
# 436 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 437
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 439
::exit(___);}
#if 0
# 437
{ 
# 438
__surf2Dwriteu1(val, surf, x, y, cudaBoundaryModeTrap); 
# 439
} 
#endif
# 441 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 442
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 444
::exit(___);}
#if 0
# 442
{ 
# 443
__surf2Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
# 444
} 
#endif
# 446 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 447
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 449
::exit(___);}
#if 0
# 447
{ 
# 448
__surf2Dwriteu2(val, surf, x, y, cudaBoundaryModeTrap); 
# 449
} 
#endif
# 451 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 452
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 454
::exit(___);}
#if 0
# 452
{ 
# 453
__surf2Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
# 454
} 
#endif
# 456 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 457
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 459
::exit(___);}
#if 0
# 457
{ 
# 458
__surf2Dwriteu4(val, surf, x, y, cudaBoundaryModeTrap); 
# 459
} 
#endif
# 461 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(long long val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 462
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 464
::exit(___);}
#if 0
# 462
{ 
# 463
__surf2Dwritel1(make_ulonglong1((unsigned long long)val), surf, x, y, cudaBoundaryModeTrap); 
# 464
} 
#endif
# 466 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned long long val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 467
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 469
::exit(___);}
#if 0
# 467
{ 
# 468
__surf2Dwritel1(make_ulonglong1(val), surf, x, y, cudaBoundaryModeTrap); 
# 469
} 
#endif
# 471 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(longlong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 472
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 474
::exit(___);}
#if 0
# 472
{ 
# 473
__surf2Dwritel1(make_ulonglong1((unsigned long long)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
# 474
} 
#endif
# 476 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ulonglong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 477
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 479
::exit(___);}
#if 0
# 477
{ 
# 478
__surf2Dwritel1(val, surf, x, y, cudaBoundaryModeTrap); 
# 479
} 
#endif
# 481 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(longlong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 482
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 484
::exit(___);}
#if 0
# 482
{ 
# 483
__surf2Dwritel2(make_ulonglong2((unsigned long long)(val.x), (unsigned long long)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
# 484
} 
#endif
# 486 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ulonglong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 487
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 489
::exit(___);}
#if 0
# 487
{ 
# 488
__surf2Dwritel2(val, surf, x, y, cudaBoundaryModeTrap); 
# 489
} 
#endif
# 535 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 536
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 538
::exit(___);}
#if 0
# 536
{ 
# 537
__surf2Dwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, cudaBoundaryModeTrap); 
# 538
} 
#endif
# 540 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 541
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 543
::exit(___);}
#if 0
# 541
{ 
# 542
__surf2Dwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, cudaBoundaryModeTrap); 
# 543
} 
#endif
# 545 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 546
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 548
::exit(___);}
#if 0
# 546
{ 
# 547
__surf2Dwriteu2(make_uint2((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y)), surf, x, y, cudaBoundaryModeTrap); 
# 548
} 
#endif
# 550 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 551
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 553
::exit(___);}
#if 0
# 551
{ 
# 552
__surf2Dwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, cudaBoundaryModeTrap); 
# 553
} 
#endif
# 578 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 579
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 581
::exit(___);}
#if 0
# 579
{ 
# 580
__surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap); 
# 581
} 
#endif
# 583 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(signed char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 584
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 586
::exit(___);}
#if 0
# 584
{ 
# 585
__surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap); 
# 586
} 
#endif
# 588 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 589
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 591
::exit(___);}
#if 0
# 589
{ 
# 590
__surf3Dwritec1(make_uchar1(val), surf, x, y, z, cudaBoundaryModeTrap); 
# 591
} 
#endif
# 593 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 594
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 596
::exit(___);}
#if 0
# 594
{ 
# 595
__surf3Dwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
# 596
} 
#endif
# 598 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 599
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 601
::exit(___);}
#if 0
# 599
{ 
# 600
__surf3Dwritec1(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 601
} 
#endif
# 603 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 604
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 606
::exit(___);}
#if 0
# 604
{ 
# 605
__surf3Dwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
# 606
} 
#endif
# 608 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 609
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 611
::exit(___);}
#if 0
# 609
{ 
# 610
__surf3Dwritec2(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 611
} 
#endif
# 613 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 614
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 616
::exit(___);}
#if 0
# 614
{ 
# 615
__surf3Dwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
# 616
} 
#endif
# 618 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 619
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 621
::exit(___);}
#if 0
# 619
{ 
# 620
__surf3Dwritec4(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 621
} 
#endif
# 623 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 624
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 626
::exit(___);}
#if 0
# 624
{ 
# 625
__surf3Dwrites1(make_ushort1((unsigned short)val), surf, x, y, z, cudaBoundaryModeTrap); 
# 626
} 
#endif
# 628 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned short val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 629
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 631
::exit(___);}
#if 0
# 629
{ 
# 630
__surf3Dwrites1(make_ushort1(val), surf, x, y, z, cudaBoundaryModeTrap); 
# 631
} 
#endif
# 633 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 634
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 636
::exit(___);}
#if 0
# 634
{ 
# 635
__surf3Dwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
# 636
} 
#endif
# 638 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 639
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 641
::exit(___);}
#if 0
# 639
{ 
# 640
__surf3Dwrites1(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 641
} 
#endif
# 643 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 644
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 646
::exit(___);}
#if 0
# 644
{ 
# 645
__surf3Dwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
# 646
} 
#endif
# 648 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 649
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 651
::exit(___);}
#if 0
# 649
{ 
# 650
__surf3Dwrites2(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 651
} 
#endif
# 653 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 654
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 656
::exit(___);}
#if 0
# 654
{ 
# 655
__surf3Dwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
# 656
} 
#endif
# 658 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 659
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 661
::exit(___);}
#if 0
# 659
{ 
# 660
__surf3Dwrites4(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 661
} 
#endif
# 663 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 664
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 666
::exit(___);}
#if 0
# 664
{ 
# 665
__surf3Dwriteu1(make_uint1((unsigned)val), surf, x, y, z, cudaBoundaryModeTrap); 
# 666
} 
#endif
# 668 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 669
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 671
::exit(___);}
#if 0
# 669
{ 
# 670
__surf3Dwriteu1(make_uint1(val), surf, x, y, z, cudaBoundaryModeTrap); 
# 671
} 
#endif
# 673 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 674
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 676
::exit(___);}
#if 0
# 674
{ 
# 675
__surf3Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
# 676
} 
#endif
# 678 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 679
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 681
::exit(___);}
#if 0
# 679
{ 
# 680
__surf3Dwriteu1(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 681
} 
#endif
# 683 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 684
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 686
::exit(___);}
#if 0
# 684
{ 
# 685
__surf3Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
# 686
} 
#endif
# 688 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 689
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 691
::exit(___);}
#if 0
# 689
{ 
# 690
__surf3Dwriteu2(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 691
} 
#endif
# 693 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 694
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 696
::exit(___);}
#if 0
# 694
{ 
# 695
__surf3Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
# 696
} 
#endif
# 698 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 699
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 701
::exit(___);}
#if 0
# 699
{ 
# 700
__surf3Dwriteu4(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 701
} 
#endif
# 703 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(long long val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 704
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 706
::exit(___);}
#if 0
# 704
{ 
# 705
__surf3Dwritel1(make_ulonglong1((unsigned long long)val), surf, x, y, z, cudaBoundaryModeTrap); 
# 706
} 
#endif
# 708 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned long long val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 709
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 711
::exit(___);}
#if 0
# 709
{ 
# 710
__surf3Dwritel1(make_ulonglong1(val), surf, x, y, z, cudaBoundaryModeTrap); 
# 711
} 
#endif
# 713 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(longlong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 714
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 716
::exit(___);}
#if 0
# 714
{ 
# 715
__surf3Dwritel1(make_ulonglong1((unsigned long long)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
# 716
} 
#endif
# 718 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ulonglong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 719
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 721
::exit(___);}
#if 0
# 719
{ 
# 720
__surf3Dwritel1(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 721
} 
#endif
# 723 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(longlong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 724
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 726
::exit(___);}
#if 0
# 724
{ 
# 725
__surf3Dwritel2(make_ulonglong2((unsigned long long)(val.x), (unsigned long long)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
# 726
} 
#endif
# 728 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ulonglong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 729
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 731
::exit(___);}
#if 0
# 729
{ 
# 730
__surf3Dwritel2(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 731
} 
#endif
# 777 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 778
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 780
::exit(___);}
#if 0
# 778
{ 
# 779
__surf3Dwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, z, cudaBoundaryModeTrap); 
# 780
} 
#endif
# 782 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 783
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 785
::exit(___);}
#if 0
# 783
{ 
# 784
__surf3Dwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
# 785
} 
#endif
# 787 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 788
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 790
::exit(___);}
#if 0
# 788
{ 
# 789
__surf3Dwriteu2(make_uint2((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
# 790
} 
#endif
# 792 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 793
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 795
::exit(___);}
#if 0
# 793
{ 
# 794
__surf3Dwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
# 795
} 
#endif
# 820 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 821
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 823
::exit(___);}
#if 0
# 821
{ 
# 822
__surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap); 
# 823
} 
#endif
# 825 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(signed char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 826
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 828
::exit(___);}
#if 0
# 826
{ 
# 827
__surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap); 
# 828
} 
#endif
# 830 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 831
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 833
::exit(___);}
#if 0
# 831
{ 
# 832
__surf1DLayeredwritec1(make_uchar1(val), surf, x, layer, cudaBoundaryModeTrap); 
# 833
} 
#endif
# 835 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 836
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 838
::exit(___);}
#if 0
# 836
{ 
# 837
__surf1DLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
# 838
} 
#endif
# 840 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 841
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 843
::exit(___);}
#if 0
# 841
{ 
# 842
__surf1DLayeredwritec1(val, surf, x, layer, cudaBoundaryModeTrap); 
# 843
} 
#endif
# 845 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 846
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 848
::exit(___);}
#if 0
# 846
{ 
# 847
__surf1DLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
# 848
} 
#endif
# 850 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 851
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 853
::exit(___);}
#if 0
# 851
{ 
# 852
__surf1DLayeredwritec2(val, surf, x, layer, cudaBoundaryModeTrap); 
# 853
} 
#endif
# 855 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 856
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 858
::exit(___);}
#if 0
# 856
{ 
# 857
__surf1DLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
# 858
} 
#endif
# 860 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 861
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 863
::exit(___);}
#if 0
# 861
{ 
# 862
__surf1DLayeredwritec4(val, surf, x, layer, cudaBoundaryModeTrap); 
# 863
} 
#endif
# 865 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 866
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 868
::exit(___);}
#if 0
# 866
{ 
# 867
__surf1DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, layer, cudaBoundaryModeTrap); 
# 868
} 
#endif
# 870 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned short val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 871
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 873
::exit(___);}
#if 0
# 871
{ 
# 872
__surf1DLayeredwrites1(make_ushort1(val), surf, x, layer, cudaBoundaryModeTrap); 
# 873
} 
#endif
# 875 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 876
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 878
::exit(___);}
#if 0
# 876
{ 
# 877
__surf1DLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
# 878
} 
#endif
# 880 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 881
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 883
::exit(___);}
#if 0
# 881
{ 
# 882
__surf1DLayeredwrites1(val, surf, x, layer, cudaBoundaryModeTrap); 
# 883
} 
#endif
# 885 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 886
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 888
::exit(___);}
#if 0
# 886
{ 
# 887
__surf1DLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
# 888
} 
#endif
# 890 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 891
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 893
::exit(___);}
#if 0
# 891
{ 
# 892
__surf1DLayeredwrites2(val, surf, x, layer, cudaBoundaryModeTrap); 
# 893
} 
#endif
# 895 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 896
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 898
::exit(___);}
#if 0
# 896
{ 
# 897
__surf1DLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
# 898
} 
#endif
# 900 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 901
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 903
::exit(___);}
#if 0
# 901
{ 
# 902
__surf1DLayeredwrites4(val, surf, x, layer, cudaBoundaryModeTrap); 
# 903
} 
#endif
# 905 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 906
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 908
::exit(___);}
#if 0
# 906
{ 
# 907
__surf1DLayeredwriteu1(make_uint1((unsigned)val), surf, x, layer, cudaBoundaryModeTrap); 
# 908
} 
#endif
# 910 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 911
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 913
::exit(___);}
#if 0
# 911
{ 
# 912
__surf1DLayeredwriteu1(make_uint1(val), surf, x, layer, cudaBoundaryModeTrap); 
# 913
} 
#endif
# 915 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 916
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 918
::exit(___);}
#if 0
# 916
{ 
# 917
__surf1DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
# 918
} 
#endif
# 920 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 921
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 923
::exit(___);}
#if 0
# 921
{ 
# 922
__surf1DLayeredwriteu1(val, surf, x, layer, cudaBoundaryModeTrap); 
# 923
} 
#endif
# 925 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 926
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 928
::exit(___);}
#if 0
# 926
{ 
# 927
__surf1DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
# 928
} 
#endif
# 930 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 931
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 933
::exit(___);}
#if 0
# 931
{ 
# 932
__surf1DLayeredwriteu2(val, surf, x, layer, cudaBoundaryModeTrap); 
# 933
} 
#endif
# 935 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 936
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 938
::exit(___);}
#if 0
# 936
{ 
# 937
__surf1DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
# 938
} 
#endif
# 940 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 941
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 943
::exit(___);}
#if 0
# 941
{ 
# 942
__surf1DLayeredwriteu4(val, surf, x, layer, cudaBoundaryModeTrap); 
# 943
} 
#endif
# 945 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(long long val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 946
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 948
::exit(___);}
#if 0
# 946
{ 
# 947
__surf1DLayeredwritel1(make_ulonglong1((unsigned long long)val), surf, x, layer, cudaBoundaryModeTrap); 
# 948
} 
#endif
# 950 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned long long val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 951
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 953
::exit(___);}
#if 0
# 951
{ 
# 952
__surf1DLayeredwritel1(make_ulonglong1(val), surf, x, layer, cudaBoundaryModeTrap); 
# 953
} 
#endif
# 955 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(longlong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 956
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 958
::exit(___);}
#if 0
# 956
{ 
# 957
__surf1DLayeredwritel1(make_ulonglong1((unsigned long long)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
# 958
} 
#endif
# 960 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ulonglong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 961
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 963
::exit(___);}
#if 0
# 961
{ 
# 962
__surf1DLayeredwritel1(val, surf, x, layer, cudaBoundaryModeTrap); 
# 963
} 
#endif
# 965 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(longlong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 966
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 968
::exit(___);}
#if 0
# 966
{ 
# 967
__surf1DLayeredwritel2(make_ulonglong2((unsigned long long)(val.x), (unsigned long long)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
# 968
} 
#endif
# 970 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ulonglong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 971
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 973
::exit(___);}
#if 0
# 971
{ 
# 972
__surf1DLayeredwritel2(val, surf, x, layer, cudaBoundaryModeTrap); 
# 973
} 
#endif
# 1019 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1020
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 1022
::exit(___);}
#if 0
# 1020
{ 
# 1021
__surf1DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, layer, cudaBoundaryModeTrap); 
# 1022
} 
#endif
# 1024 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1025
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 1027
::exit(___);}
#if 0
# 1025
{ 
# 1026
__surf1DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
# 1027
} 
#endif
# 1029 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1030
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 1032
::exit(___);}
#if 0
# 1030
{ 
# 1031
__surf1DLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
# 1032
} 
#endif
# 1034 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1035
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 1037
::exit(___);}
#if 0
# 1035
{ 
# 1036
__surf1DLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
# 1037
} 
#endif
# 1062 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1063
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1065
::exit(___);}
#if 0
# 1063
{ 
# 1064
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1065
} 
#endif
# 1067 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(signed char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1068
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1070
::exit(___);}
#if 0
# 1068
{ 
# 1069
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1070
} 
#endif
# 1072 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1073
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1075
::exit(___);}
#if 0
# 1073
{ 
# 1074
__surf2DLayeredwritec1(make_uchar1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1075
} 
#endif
# 1077 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1078
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1080
::exit(___);}
#if 0
# 1078
{ 
# 1079
__surf2DLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1080
} 
#endif
# 1082 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1083
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1085
::exit(___);}
#if 0
# 1083
{ 
# 1084
__surf2DLayeredwritec1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 1085
} 
#endif
# 1087 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1088
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1090
::exit(___);}
#if 0
# 1088
{ 
# 1089
__surf2DLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1090
} 
#endif
# 1092 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1093
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1095
::exit(___);}
#if 0
# 1093
{ 
# 1094
__surf2DLayeredwritec2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 1095
} 
#endif
# 1097 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1098
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1100
::exit(___);}
#if 0
# 1098
{ 
# 1099
__surf2DLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1100
} 
#endif
# 1102 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1103
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1105
::exit(___);}
#if 0
# 1103
{ 
# 1104
__surf2DLayeredwritec4(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 1105
} 
#endif
# 1107 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1108
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1110
::exit(___);}
#if 0
# 1108
{ 
# 1109
__surf2DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1110
} 
#endif
# 1112 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned short val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1113
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1115
::exit(___);}
#if 0
# 1113
{ 
# 1114
__surf2DLayeredwrites1(make_ushort1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1115
} 
#endif
# 1117 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1118
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1120
::exit(___);}
#if 0
# 1118
{ 
# 1119
__surf2DLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1120
} 
#endif
# 1122 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1123
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1125
::exit(___);}
#if 0
# 1123
{ 
# 1124
__surf2DLayeredwrites1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 1125
} 
#endif
# 1127 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1128
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1130
::exit(___);}
#if 0
# 1128
{ 
# 1129
__surf2DLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1130
} 
#endif
# 1132 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1133
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1135
::exit(___);}
#if 0
# 1133
{ 
# 1134
__surf2DLayeredwrites2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 1135
} 
#endif
# 1137 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1138
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1140
::exit(___);}
#if 0
# 1138
{ 
# 1139
__surf2DLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1140
} 
#endif
# 1142 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1143
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1145
::exit(___);}
#if 0
# 1143
{ 
# 1144
__surf2DLayeredwrites4(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 1145
} 
#endif
# 1147 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1148
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1150
::exit(___);}
#if 0
# 1148
{ 
# 1149
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1150
} 
#endif
# 1152 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1153
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1155
::exit(___);}
#if 0
# 1153
{ 
# 1154
__surf2DLayeredwriteu1(make_uint1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1155
} 
#endif
# 1157 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1158
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1160
::exit(___);}
#if 0
# 1158
{ 
# 1159
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1160
} 
#endif
# 1162 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1163
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1165
::exit(___);}
#if 0
# 1163
{ 
# 1164
__surf2DLayeredwriteu1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 1165
} 
#endif
# 1167 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1168
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1170
::exit(___);}
#if 0
# 1168
{ 
# 1169
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1170
} 
#endif
# 1172 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1173
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1175
::exit(___);}
#if 0
# 1173
{ 
# 1174
__surf2DLayeredwriteu2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 1175
} 
#endif
# 1177 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1178
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1180
::exit(___);}
#if 0
# 1178
{ 
# 1179
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1180
} 
#endif
# 1182 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1183
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1185
::exit(___);}
#if 0
# 1183
{ 
# 1184
__surf2DLayeredwriteu4(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 1185
} 
#endif
# 1187 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(long long val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1188
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1190
::exit(___);}
#if 0
# 1188
{ 
# 1189
__surf2DLayeredwritel1(make_ulonglong1((unsigned long long)val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1190
} 
#endif
# 1192 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned long long val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1193
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1195
::exit(___);}
#if 0
# 1193
{ 
# 1194
__surf2DLayeredwritel1(make_ulonglong1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1195
} 
#endif
# 1197 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(longlong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1198
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1200
::exit(___);}
#if 0
# 1198
{ 
# 1199
__surf2DLayeredwritel1(make_ulonglong1((unsigned long long)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1200
} 
#endif
# 1202 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ulonglong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1203
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1205
::exit(___);}
#if 0
# 1203
{ 
# 1204
__surf2DLayeredwritel1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 1205
} 
#endif
# 1207 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(longlong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1208
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1210
::exit(___);}
#if 0
# 1208
{ 
# 1209
__surf2DLayeredwritel2(make_ulonglong2((unsigned long long)(val.x), (unsigned long long)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1210
} 
#endif
# 1212 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ulonglong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1213
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1215
::exit(___);}
#if 0
# 1213
{ 
# 1214
__surf2DLayeredwritel2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 1215
} 
#endif
# 1261 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1262
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1264
::exit(___);}
#if 0
# 1262
{ 
# 1263
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1264
} 
#endif
# 1266 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1267
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1269
::exit(___);}
#if 0
# 1267
{ 
# 1268
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1269
} 
#endif
# 1271 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1272
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1274
::exit(___);}
#if 0
# 1272
{ 
# 1273
__surf2DLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1274
} 
#endif
# 1276 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1277
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1279
::exit(___);}
#if 0
# 1277
{ 
# 1278
__surf2DLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 1279
} 
#endif
# 1305 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1306
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1308
::exit(___);}
#if 0
# 1306
{ 
# 1307
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap); 
# 1308
} 
#endif
# 1310 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(signed char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1311
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1313
::exit(___);}
#if 0
# 1311
{ 
# 1312
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap); 
# 1313
} 
#endif
# 1315 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1316
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1318
::exit(___);}
#if 0
# 1316
{ 
# 1317
__surf2DLayeredwritec1(make_uchar1(val), surf, x, y, face, cudaBoundaryModeTrap); 
# 1318
} 
#endif
# 1320 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1321
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1323
::exit(___);}
#if 0
# 1321
{ 
# 1322
__surf2DLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
# 1323
} 
#endif
# 1325 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1326
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1328
::exit(___);}
#if 0
# 1326
{ 
# 1327
__surf2DLayeredwritec1(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 1328
} 
#endif
# 1330 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1331
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1333
::exit(___);}
#if 0
# 1331
{ 
# 1332
__surf2DLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
# 1333
} 
#endif
# 1335 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1336
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1338
::exit(___);}
#if 0
# 1336
{ 
# 1337
__surf2DLayeredwritec2(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 1338
} 
#endif
# 1340 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1341
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1343
::exit(___);}
#if 0
# 1341
{ 
# 1342
__surf2DLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
# 1343
} 
#endif
# 1345 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1346
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1348
::exit(___);}
#if 0
# 1346
{ 
# 1347
__surf2DLayeredwritec4(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 1348
} 
#endif
# 1350 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1351
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1353
::exit(___);}
#if 0
# 1351
{ 
# 1352
__surf2DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, face, cudaBoundaryModeTrap); 
# 1353
} 
#endif
# 1355 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned short val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1356
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1358
::exit(___);}
#if 0
# 1356
{ 
# 1357
__surf2DLayeredwrites1(make_ushort1(val), surf, x, y, face, cudaBoundaryModeTrap); 
# 1358
} 
#endif
# 1360 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1361
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1363
::exit(___);}
#if 0
# 1361
{ 
# 1362
__surf2DLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
# 1363
} 
#endif
# 1365 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1366
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1368
::exit(___);}
#if 0
# 1366
{ 
# 1367
__surf2DLayeredwrites1(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 1368
} 
#endif
# 1370 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1371
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1373
::exit(___);}
#if 0
# 1371
{ 
# 1372
__surf2DLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
# 1373
} 
#endif
# 1375 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1376
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1378
::exit(___);}
#if 0
# 1376
{ 
# 1377
__surf2DLayeredwrites2(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 1378
} 
#endif
# 1380 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1381
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1383
::exit(___);}
#if 0
# 1381
{ 
# 1382
__surf2DLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
# 1383
} 
#endif
# 1385 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1386
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1388
::exit(___);}
#if 0
# 1386
{ 
# 1387
__surf2DLayeredwrites4(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 1388
} 
#endif
# 1390 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1391
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1393
::exit(___);}
#if 0
# 1391
{ 
# 1392
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, face, cudaBoundaryModeTrap); 
# 1393
} 
#endif
# 1395 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1396
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1398
::exit(___);}
#if 0
# 1396
{ 
# 1397
__surf2DLayeredwriteu1(make_uint1(val), surf, x, y, face, cudaBoundaryModeTrap); 
# 1398
} 
#endif
# 1400 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1401
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1403
::exit(___);}
#if 0
# 1401
{ 
# 1402
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
# 1403
} 
#endif
# 1405 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1406
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1408
::exit(___);}
#if 0
# 1406
{ 
# 1407
__surf2DLayeredwriteu1(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 1408
} 
#endif
# 1410 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1411
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1413
::exit(___);}
#if 0
# 1411
{ 
# 1412
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
# 1413
} 
#endif
# 1415 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1416
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1418
::exit(___);}
#if 0
# 1416
{ 
# 1417
__surf2DLayeredwriteu2(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 1418
} 
#endif
# 1420 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1421
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1423
::exit(___);}
#if 0
# 1421
{ 
# 1422
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
# 1423
} 
#endif
# 1425 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1426
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1428
::exit(___);}
#if 0
# 1426
{ 
# 1427
__surf2DLayeredwriteu4(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 1428
} 
#endif
# 1430 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(long long val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1431
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1433
::exit(___);}
#if 0
# 1431
{ 
# 1432
__surf2DLayeredwritel1(make_ulonglong1((unsigned long long)val), surf, x, y, face, cudaBoundaryModeTrap); 
# 1433
} 
#endif
# 1435 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned long long val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1436
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1438
::exit(___);}
#if 0
# 1436
{ 
# 1437
__surf2DLayeredwritel1(make_ulonglong1(val), surf, x, y, face, cudaBoundaryModeTrap); 
# 1438
} 
#endif
# 1440 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(longlong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1441
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1443
::exit(___);}
#if 0
# 1441
{ 
# 1442
__surf2DLayeredwritel1(make_ulonglong1((unsigned long long)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
# 1443
} 
#endif
# 1445 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ulonglong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1446
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1448
::exit(___);}
#if 0
# 1446
{ 
# 1447
__surf2DLayeredwritel1(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 1448
} 
#endif
# 1450 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(longlong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1451
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1453
::exit(___);}
#if 0
# 1451
{ 
# 1452
__surf2DLayeredwritel2(make_ulonglong2((unsigned long long)(val.x), (unsigned long long)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
# 1453
} 
#endif
# 1455 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ulonglong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1456
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1458
::exit(___);}
#if 0
# 1456
{ 
# 1457
__surf2DLayeredwritel2(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 1458
} 
#endif
# 1504 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1505
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1507
::exit(___);}
#if 0
# 1505
{ 
# 1506
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, face, cudaBoundaryModeTrap); 
# 1507
} 
#endif
# 1509 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1510
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1512
::exit(___);}
#if 0
# 1510
{ 
# 1511
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
# 1512
} 
#endif
# 1514 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1515
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1517
::exit(___);}
#if 0
# 1515
{ 
# 1516
__surf2DLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
# 1517
} 
#endif
# 1519 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1520
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1522
::exit(___);}
#if 0
# 1520
{ 
# 1521
__surf2DLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
# 1522
} 
#endif
# 1548 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1549
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1551
::exit(___);}
#if 0
# 1549
{ 
# 1550
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1551
} 
#endif
# 1553 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(signed char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1554
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1556
::exit(___);}
#if 0
# 1554
{ 
# 1555
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1556
} 
#endif
# 1558 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1559
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1561
::exit(___);}
#if 0
# 1559
{ 
# 1560
__surf2DLayeredwritec1(make_uchar1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1561
} 
#endif
# 1563 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1564
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1566
::exit(___);}
#if 0
# 1564
{ 
# 1565
__surf2DLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1566
} 
#endif
# 1568 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1569
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1571
::exit(___);}
#if 0
# 1569
{ 
# 1570
__surf2DLayeredwritec1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1571
} 
#endif
# 1573 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1574
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1576
::exit(___);}
#if 0
# 1574
{ 
# 1575
__surf2DLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1576
} 
#endif
# 1578 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1579
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1581
::exit(___);}
#if 0
# 1579
{ 
# 1580
__surf2DLayeredwritec2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1581
} 
#endif
# 1583 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1584
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1586
::exit(___);}
#if 0
# 1584
{ 
# 1585
__surf2DLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1586
} 
#endif
# 1588 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1589
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1591
::exit(___);}
#if 0
# 1589
{ 
# 1590
__surf2DLayeredwritec4(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1591
} 
#endif
# 1593 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1594
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1596
::exit(___);}
#if 0
# 1594
{ 
# 1595
__surf2DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1596
} 
#endif
# 1598 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned short val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1599
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1601
::exit(___);}
#if 0
# 1599
{ 
# 1600
__surf2DLayeredwrites1(make_ushort1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1601
} 
#endif
# 1603 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1604
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1606
::exit(___);}
#if 0
# 1604
{ 
# 1605
__surf2DLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1606
} 
#endif
# 1608 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1609
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1611
::exit(___);}
#if 0
# 1609
{ 
# 1610
__surf2DLayeredwrites1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1611
} 
#endif
# 1613 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1614
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1616
::exit(___);}
#if 0
# 1614
{ 
# 1615
__surf2DLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1616
} 
#endif
# 1618 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1619
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1621
::exit(___);}
#if 0
# 1619
{ 
# 1620
__surf2DLayeredwrites2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1621
} 
#endif
# 1623 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1624
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1626
::exit(___);}
#if 0
# 1624
{ 
# 1625
__surf2DLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1626
} 
#endif
# 1628 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1629
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1631
::exit(___);}
#if 0
# 1629
{ 
# 1630
__surf2DLayeredwrites4(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1631
} 
#endif
# 1633 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1634
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1636
::exit(___);}
#if 0
# 1634
{ 
# 1635
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1636
} 
#endif
# 1638 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1639
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1641
::exit(___);}
#if 0
# 1639
{ 
# 1640
__surf2DLayeredwriteu1(make_uint1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1641
} 
#endif
# 1643 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1644
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1646
::exit(___);}
#if 0
# 1644
{ 
# 1645
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1646
} 
#endif
# 1648 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1649
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1651
::exit(___);}
#if 0
# 1649
{ 
# 1650
__surf2DLayeredwriteu1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1651
} 
#endif
# 1653 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1654
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1656
::exit(___);}
#if 0
# 1654
{ 
# 1655
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1656
} 
#endif
# 1658 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1659
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1661
::exit(___);}
#if 0
# 1659
{ 
# 1660
__surf2DLayeredwriteu2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1661
} 
#endif
# 1663 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1664
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1666
::exit(___);}
#if 0
# 1664
{ 
# 1665
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1666
} 
#endif
# 1668 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1669
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1671
::exit(___);}
#if 0
# 1669
{ 
# 1670
__surf2DLayeredwriteu4(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1671
} 
#endif
# 1673 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(long long val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1674
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1676
::exit(___);}
#if 0
# 1674
{ 
# 1675
__surf2DLayeredwritel1(make_ulonglong1((unsigned long long)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1676
} 
#endif
# 1678 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned long long val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1679
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1681
::exit(___);}
#if 0
# 1679
{ 
# 1680
__surf2DLayeredwritel1(make_ulonglong1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1681
} 
#endif
# 1683 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(longlong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1684
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1686
::exit(___);}
#if 0
# 1684
{ 
# 1685
__surf2DLayeredwritel1(make_ulonglong1((unsigned long long)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1686
} 
#endif
# 1688 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ulonglong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1689
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1691
::exit(___);}
#if 0
# 1689
{ 
# 1690
__surf2DLayeredwritel1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1691
} 
#endif
# 1693 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(longlong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1694
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1696
::exit(___);}
#if 0
# 1694
{ 
# 1695
__surf2DLayeredwritel2(make_ulonglong2((unsigned long long)(val.x), (unsigned long long)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1696
} 
#endif
# 1698 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ulonglong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1699
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1701
::exit(___);}
#if 0
# 1699
{ 
# 1700
__surf2DLayeredwritel2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1701
} 
#endif
# 1747 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1748
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1750
::exit(___);}
#if 0
# 1748
{ 
# 1749
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1750
} 
#endif
# 1752 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1753
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1755
::exit(___);}
#if 0
# 1753
{ 
# 1754
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1755
} 
#endif
# 1757 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1758
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1760
::exit(___);}
#if 0
# 1758
{ 
# 1759
__surf2DLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1760
} 
#endif
# 1762 "/usr/include/surface_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 1763
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1765
::exit(___);}
#if 0
# 1763
{ 
# 1764
__surf2DLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 1765
} 
#endif
# 146 "/usr/include/texture_fetch_functions.h" 3
template< class T, cudaTextureReadMode readMode> 
# 147
__attribute((always_inline)) __attribute__((unused)) static inline uint4 
# 148
__utexfetchi(texture< T, 1, readMode>  t, int4 i) 
# 149
{int volatile ___ = 1;(void)t;(void)i;
# 151
::exit(___);}
#if 0
# 149
{ 
# 150
return __utexfetchi1D(t, i); 
# 151
} 
#endif
# 153 "/usr/include/texture_fetch_functions.h" 3
template< class T, cudaTextureReadMode readMode> 
# 154
__attribute((always_inline)) __attribute__((unused)) static inline int4 
# 155
__itexfetchi(texture< T, 1, readMode>  t, int4 i) 
# 156
{int volatile ___ = 1;(void)t;(void)i;
# 158
::exit(___);}
#if 0
# 156
{ 
# 157
return __itexfetchi1D(t, i); 
# 158
} 
#endif
# 160 "/usr/include/texture_fetch_functions.h" 3
template< class T, cudaTextureReadMode readMode> 
# 161
__attribute((always_inline)) __attribute__((unused)) static inline float4 
# 162
__ftexfetchi(texture< T, 1, readMode>  t, int4 i) 
# 163
{int volatile ___ = 1;(void)t;(void)i;
# 165
::exit(___);}
#if 0
# 163
{ 
# 164
return __ftexfetchi1D(t, i); 
# 165
} 
#endif
# 167 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 168
__attribute((always_inline)) __attribute__((unused)) static inline uint4 
# 169
__utexfetch(texture< T, texType, readMode>  t, float4 i, int d = texType) 
# 170
{int volatile ___ = 1;(void)t;(void)i;(void)d;
# 177
::exit(___);}
#if 0
# 170
{ 
# 171
switch (d) { 
# 172
case 1:  return __utexfetch1D(t, i); 
# 173
case 2:  return __utexfetch2D(t, i); 
# 175
default:  return __utexfetch3D(t, i); 
# 176
}  
# 177
} 
#endif
# 179 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 180
__attribute((always_inline)) __attribute__((unused)) static inline int4 
# 181
__itexfetch(texture< T, texType, readMode>  t, float4 i, int d = texType) 
# 182
{int volatile ___ = 1;(void)t;(void)i;(void)d;
# 189
::exit(___);}
#if 0
# 182
{ 
# 183
switch (d) { 
# 184
case 1:  return __itexfetch1D(t, i); 
# 185
case 2:  return __itexfetch2D(t, i); 
# 187
default:  return __itexfetch3D(t, i); 
# 188
}  
# 189
} 
#endif
# 191 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 192
__attribute((always_inline)) __attribute__((unused)) static inline float4 
# 193
__ftexfetch(texture< T, texType, readMode>  t, float4 i, int d = texType) 
# 194
{int volatile ___ = 1;(void)t;(void)i;(void)d;
# 201
::exit(___);}
#if 0
# 194
{ 
# 195
switch (d) { 
# 196
case 1:  return __ftexfetch1D(t, i); 
# 197
case 2:  return __ftexfetch2D(t, i); 
# 199
default:  return __ftexfetch3D(t, i); 
# 200
}  
# 201
} 
#endif
# 203 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 204
__attribute((always_inline)) __attribute__((unused)) static inline uint4 
# 205
__utexfetchc(texture< T, texType, readMode>  t, float4 i) 
# 206
{int volatile ___ = 1;(void)t;(void)i;
# 208
::exit(___);}
#if 0
# 206
{ 
# 207
return __utexfetchcube(t, i); 
# 208
} 
#endif
# 210 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 211
__attribute((always_inline)) __attribute__((unused)) static inline int4 
# 212
__itexfetchc(texture< T, texType, readMode>  t, float4 i) 
# 213
{int volatile ___ = 1;(void)t;(void)i;
# 215
::exit(___);}
#if 0
# 213
{ 
# 214
return __itexfetchcube(t, i); 
# 215
} 
#endif
# 217 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 218
__attribute((always_inline)) __attribute__((unused)) static inline float4 
# 219
__ftexfetchc(texture< T, texType, readMode>  t, float4 i) 
# 220
{int volatile ___ = 1;(void)t;(void)i;
# 222
::exit(___);}
#if 0
# 220
{ 
# 221
return __ftexfetchcube(t, i); 
# 222
} 
#endif
# 224 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 225
__attribute((always_inline)) __attribute__((unused)) static inline uint4 
# 226
__utexfetchl(texture< T, texType, readMode>  t, float4 i, int l, int d = texType & 15) 
# 227
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)d;
# 233
::exit(___);}
#if 0
# 227
{ 
# 228
switch (d) { 
# 229
case 1:  return __utexfetchl1D(t, i, l); 
# 231
default:  return __utexfetchl2D(t, i, l); 
# 232
}  
# 233
} 
#endif
# 235 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 236
__attribute((always_inline)) __attribute__((unused)) static inline int4 
# 237
__itexfetchl(texture< T, texType, readMode>  t, float4 i, int l, int d = texType & 15) 
# 238
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)d;
# 244
::exit(___);}
#if 0
# 238
{ 
# 239
switch (d) { 
# 240
case 1:  return __itexfetchl1D(t, i, l); 
# 242
default:  return __itexfetchl2D(t, i, l); 
# 243
}  
# 244
} 
#endif
# 246 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 247
__attribute((always_inline)) __attribute__((unused)) static inline float4 
# 248
__ftexfetchl(texture< T, texType, readMode>  t, float4 i, int l, int d = texType & 15) 
# 249
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)d;
# 255
::exit(___);}
#if 0
# 249
{ 
# 250
switch (d) { 
# 251
case 1:  return __ftexfetchl1D(t, i, l); 
# 253
default:  return __ftexfetchl2D(t, i, l); 
# 254
}  
# 255
} 
#endif
# 257 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 258
__attribute((always_inline)) __attribute__((unused)) static inline uint4 
# 259
__utexfetchlc(texture< T, texType, readMode>  t, float4 i, int l) 
# 260
{int volatile ___ = 1;(void)t;(void)i;(void)l;
# 262
::exit(___);}
#if 0
# 260
{ 
# 261
return __utexfetchlcube(t, i, l); 
# 262
} 
#endif
# 264 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 265
__attribute((always_inline)) __attribute__((unused)) static inline int4 
# 266
__itexfetchlc(texture< T, texType, readMode>  t, float4 i, int l) 
# 267
{int volatile ___ = 1;(void)t;(void)i;(void)l;
# 269
::exit(___);}
#if 0
# 267
{ 
# 268
return __itexfetchlcube(t, i, l); 
# 269
} 
#endif
# 271 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 272
__attribute((always_inline)) __attribute__((unused)) static inline float4 
# 273
__ftexfetchlc(texture< T, texType, readMode>  t, float4 i, int l) 
# 274
{int volatile ___ = 1;(void)t;(void)i;(void)l;
# 276
::exit(___);}
#if 0
# 274
{ 
# 275
return __ftexfetchlcube(t, i, l); 
# 276
} 
#endif
# 285 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex1Dfetch(texture< char, 1, cudaReadModeElementType>  t, int x); 
# 287
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1Dfetch(texture< signed char, 1, cudaReadModeElementType>  t, int x); 
# 289
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1Dfetch(texture< unsigned char, 1, cudaReadModeElementType>  t, int x); 
# 291
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1Dfetch(texture< char1, 1, cudaReadModeElementType>  t, int x); 
# 293
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1Dfetch(texture< uchar1, 1, cudaReadModeElementType>  t, int x); 
# 295
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1Dfetch(texture< char2, 1, cudaReadModeElementType>  t, int x); 
# 297
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1Dfetch(texture< uchar2, 1, cudaReadModeElementType>  t, int x); 
# 299
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1Dfetch(texture< char4, 1, cudaReadModeElementType>  t, int x); 
# 301
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1Dfetch(texture< uchar4, 1, cudaReadModeElementType>  t, int x); 
# 309
__attribute((always_inline)) __attribute__((unused)) static inline short tex1Dfetch(texture< short, 1, cudaReadModeElementType>  t, int x); 
# 311
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1Dfetch(texture< unsigned short, 1, cudaReadModeElementType>  t, int x); 
# 313
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1Dfetch(texture< short1, 1, cudaReadModeElementType>  t, int x); 
# 315
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1Dfetch(texture< ushort1, 1, cudaReadModeElementType>  t, int x); 
# 317
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1Dfetch(texture< short2, 1, cudaReadModeElementType>  t, int x); 
# 319
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1Dfetch(texture< ushort2, 1, cudaReadModeElementType>  t, int x); 
# 321
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1Dfetch(texture< short4, 1, cudaReadModeElementType>  t, int x); 
# 323
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1Dfetch(texture< ushort4, 1, cudaReadModeElementType>  t, int x); 
# 331
__attribute((always_inline)) __attribute__((unused)) static inline int tex1Dfetch(texture< int, 1, cudaReadModeElementType>  t, int x); 
# 333
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1Dfetch(texture< unsigned, 1, cudaReadModeElementType>  t, int x); 
# 335
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1Dfetch(texture< int1, 1, cudaReadModeElementType>  t, int x); 
# 337
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1Dfetch(texture< uint1, 1, cudaReadModeElementType>  t, int x); 
# 339
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1Dfetch(texture< int2, 1, cudaReadModeElementType>  t, int x); 
# 341
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1Dfetch(texture< uint2, 1, cudaReadModeElementType>  t, int x); 
# 343
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1Dfetch(texture< int4, 1, cudaReadModeElementType>  t, int x); 
# 345
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1Dfetch(texture< uint4, 1, cudaReadModeElementType>  t, int x); 
# 379 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< float, 1, cudaReadModeElementType>  t, int x); 
# 381
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1Dfetch(texture< float1, 1, cudaReadModeElementType>  t, int x); 
# 383
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1Dfetch(texture< float2, 1, cudaReadModeElementType>  t, int x); 
# 385
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1Dfetch(texture< float4, 1, cudaReadModeElementType>  t, int x); 
# 393
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< char, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 395
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 397
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 399
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1Dfetch(texture< char1, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 401
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1Dfetch(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 403
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1Dfetch(texture< char2, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 405
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1Dfetch(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 407
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1Dfetch(texture< char4, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 409
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1Dfetch(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 417
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< short, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 419
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 421
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1Dfetch(texture< short1, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 423
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1Dfetch(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 425
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1Dfetch(texture< short2, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 427
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1Dfetch(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 429
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1Dfetch(texture< short4, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 431
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1Dfetch(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, int x); 
# 439
__attribute((always_inline)) __attribute__((unused)) static inline char tex1D(texture< char, 1, cudaReadModeElementType>  t, float x); 
# 441
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1D(texture< signed char, 1, cudaReadModeElementType>  t, float x); 
# 443
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1D(texture< unsigned char, 1, cudaReadModeElementType>  t, float x); 
# 445
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1D(texture< char1, 1, cudaReadModeElementType>  t, float x); 
# 447
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1D(texture< uchar1, 1, cudaReadModeElementType>  t, float x); 
# 449
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1D(texture< char2, 1, cudaReadModeElementType>  t, float x); 
# 451
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1D(texture< uchar2, 1, cudaReadModeElementType>  t, float x); 
# 453
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1D(texture< char4, 1, cudaReadModeElementType>  t, float x); 
# 455
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1D(texture< uchar4, 1, cudaReadModeElementType>  t, float x); 
# 463
__attribute((always_inline)) __attribute__((unused)) static inline short tex1D(texture< short, 1, cudaReadModeElementType>  t, float x); 
# 465
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1D(texture< unsigned short, 1, cudaReadModeElementType>  t, float x); 
# 467
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1D(texture< short1, 1, cudaReadModeElementType>  t, float x); 
# 469
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1D(texture< ushort1, 1, cudaReadModeElementType>  t, float x); 
# 471
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1D(texture< short2, 1, cudaReadModeElementType>  t, float x); 
# 473
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1D(texture< ushort2, 1, cudaReadModeElementType>  t, float x); 
# 475
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1D(texture< short4, 1, cudaReadModeElementType>  t, float x); 
# 477
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1D(texture< ushort4, 1, cudaReadModeElementType>  t, float x); 
# 485
__attribute((always_inline)) __attribute__((unused)) static inline int tex1D(texture< int, 1, cudaReadModeElementType>  t, float x); 
# 487
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1D(texture< unsigned, 1, cudaReadModeElementType>  t, float x); 
# 489
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1D(texture< int1, 1, cudaReadModeElementType>  t, float x); 
# 491
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1D(texture< uint1, 1, cudaReadModeElementType>  t, float x); 
# 493
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1D(texture< int2, 1, cudaReadModeElementType>  t, float x); 
# 495
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1D(texture< uint2, 1, cudaReadModeElementType>  t, float x); 
# 497
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1D(texture< int4, 1, cudaReadModeElementType>  t, float x); 
# 499
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1D(texture< uint4, 1, cudaReadModeElementType>  t, float x); 
# 539 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< float, 1, cudaReadModeElementType>  t, float x); 
# 541
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1D(texture< float1, 1, cudaReadModeElementType>  t, float x); 
# 543
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1D(texture< float2, 1, cudaReadModeElementType>  t, float x); 
# 545
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1D(texture< float4, 1, cudaReadModeElementType>  t, float x); 
# 553
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 555
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 557
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 559
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1D(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 561
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1D(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 563
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1D(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 565
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1D(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 567
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1D(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 569
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1D(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 577
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 579
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 581
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1D(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 583
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1D(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 585
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1D(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 587
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1D(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 589
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1D(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 591
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1D(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x); 
# 599
__attribute((always_inline)) __attribute__((unused)) static inline char tex2D(texture< char, 2, cudaReadModeElementType>  t, float x, float y); 
# 601
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2D(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y); 
# 603
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2D(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y); 
# 605
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2D(texture< char1, 2, cudaReadModeElementType>  t, float x, float y); 
# 607
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2D(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y); 
# 609
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2D(texture< char2, 2, cudaReadModeElementType>  t, float x, float y); 
# 611
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2D(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y); 
# 613
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2D(texture< char4, 2, cudaReadModeElementType>  t, float x, float y); 
# 615
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2D(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y); 
# 623
__attribute((always_inline)) __attribute__((unused)) static inline short tex2D(texture< short, 2, cudaReadModeElementType>  t, float x, float y); 
# 625
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2D(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y); 
# 627
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2D(texture< short1, 2, cudaReadModeElementType>  t, float x, float y); 
# 629
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2D(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y); 
# 631
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2D(texture< short2, 2, cudaReadModeElementType>  t, float x, float y); 
# 633
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2D(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y); 
# 635
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2D(texture< short4, 2, cudaReadModeElementType>  t, float x, float y); 
# 637
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2D(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y); 
# 645
__attribute((always_inline)) __attribute__((unused)) static inline int tex2D(texture< int, 2, cudaReadModeElementType>  t, float x, float y); 
# 647
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2D(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y); 
# 649
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2D(texture< int1, 2, cudaReadModeElementType>  t, float x, float y); 
# 651
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2D(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y); 
# 653
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2D(texture< int2, 2, cudaReadModeElementType>  t, float x, float y); 
# 655
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2D(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y); 
# 657
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2D(texture< int4, 2, cudaReadModeElementType>  t, float x, float y); 
# 659
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2D(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y); 
# 693 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< float, 2, cudaReadModeElementType>  t, float x, float y); 
# 695
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2D(texture< float1, 2, cudaReadModeElementType>  t, float x, float y); 
# 697
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2D(texture< float2, 2, cudaReadModeElementType>  t, float x, float y); 
# 699
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2D(texture< float4, 2, cudaReadModeElementType>  t, float x, float y); 
# 707
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 709
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 711
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 713
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2D(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 715
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2D(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 717
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2D(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 719
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2D(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 721
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2D(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 723
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2D(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 731
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 733
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 735
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2D(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 737
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2D(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 739
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2D(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 741
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2D(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 743
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2D(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 745
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2D(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
# 753
__attribute((always_inline)) __attribute__((unused)) static inline char tex1DLayered(texture< char, 241, cudaReadModeElementType>  t, float x, int layer); 
# 755
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1DLayered(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer); 
# 757
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1DLayered(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer); 
# 759
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1DLayered(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer); 
# 761
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1DLayered(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer); 
# 763
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1DLayered(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer); 
# 765
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1DLayered(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer); 
# 767
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1DLayered(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer); 
# 769
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1DLayered(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer); 
# 777
__attribute((always_inline)) __attribute__((unused)) static inline short tex1DLayered(texture< short, 241, cudaReadModeElementType>  t, float x, int layer); 
# 779
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1DLayered(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer); 
# 781
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1DLayered(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer); 
# 783
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1DLayered(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer); 
# 785
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1DLayered(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer); 
# 787
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1DLayered(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer); 
# 789
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1DLayered(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer); 
# 791
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1DLayered(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer); 
# 799
__attribute((always_inline)) __attribute__((unused)) static inline int tex1DLayered(texture< int, 241, cudaReadModeElementType>  t, float x, int layer); 
# 801
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1DLayered(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer); 
# 803
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1DLayered(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer); 
# 805
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1DLayered(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer); 
# 807
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1DLayered(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer); 
# 809
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1DLayered(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer); 
# 811
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1DLayered(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer); 
# 813
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1DLayered(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer); 
# 847 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< float, 241, cudaReadModeElementType>  t, float x, int layer); 
# 849
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayered(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer); 
# 851
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayered(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer); 
# 853
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayered(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer); 
# 861
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 863
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 865
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 867
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayered(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 869
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayered(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 871
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayered(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 873
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayered(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 875
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayered(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 877
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayered(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 885
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 887
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 889
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayered(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 891
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayered(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 893
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayered(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 895
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayered(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 897
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayered(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 899
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayered(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
# 907
__attribute((always_inline)) __attribute__((unused)) static inline char tex2DLayered(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 909
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2DLayered(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 911
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2DLayered(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 913
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2DLayered(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 915
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2DLayered(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 917
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2DLayered(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 919
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2DLayered(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 921
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2DLayered(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 923
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2DLayered(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 931
__attribute((always_inline)) __attribute__((unused)) static inline short tex2DLayered(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 933
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2DLayered(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 935
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2DLayered(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 937
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2DLayered(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 939
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2DLayered(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 941
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2DLayered(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 943
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2DLayered(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 945
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2DLayered(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 953
__attribute((always_inline)) __attribute__((unused)) static inline int tex2DLayered(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 955
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2DLayered(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 957
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2DLayered(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 959
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2DLayered(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 961
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2DLayered(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 963
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2DLayered(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 965
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2DLayered(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 967
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2DLayered(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 1001 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 1003
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayered(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 1005
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayered(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 1007
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayered(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
# 1015
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1017
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1019
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1021
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayered(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1023
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayered(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1025
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayered(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1027
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayered(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1029
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayered(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1031
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayered(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1039
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1041
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1043
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayered(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1045
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayered(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1047
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayered(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1049
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayered(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1051
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayered(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1053
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayered(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
# 1061
__attribute((always_inline)) __attribute__((unused)) static inline char tex3D(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1063
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex3D(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1065
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex3D(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1067
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex3D(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1069
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex3D(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1071
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex3D(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1073
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex3D(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1075
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex3D(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1077
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex3D(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1085
__attribute((always_inline)) __attribute__((unused)) static inline short tex3D(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1087
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex3D(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1089
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex3D(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1091
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex3D(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1093
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex3D(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1095
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex3D(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1097
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex3D(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1099
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex3D(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1107
__attribute((always_inline)) __attribute__((unused)) static inline int tex3D(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1109
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex3D(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1111
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex3D(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1113
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex3D(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1115
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex3D(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1117
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex3D(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1119
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex3D(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1121
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex3D(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1155 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1157
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3D(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1159
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3D(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1161
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3D(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
# 1169
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1171
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1173
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1175
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3D(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1177
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3D(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1179
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3D(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1181
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3D(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1183
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3D(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1185
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3D(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1193
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1195
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1197
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3D(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1199
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3D(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1201
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3D(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1203
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3D(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1205
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3D(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1207
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3D(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1215
__attribute((always_inline)) __attribute__((unused)) static inline char texCubemap(texture< char, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1217
__attribute((always_inline)) __attribute__((unused)) static inline signed char texCubemap(texture< signed char, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1219
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char texCubemap(texture< unsigned char, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1221
__attribute((always_inline)) __attribute__((unused)) static inline char1 texCubemap(texture< char1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1223
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 texCubemap(texture< uchar1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1225
__attribute((always_inline)) __attribute__((unused)) static inline char2 texCubemap(texture< char2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1227
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 texCubemap(texture< uchar2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1229
__attribute((always_inline)) __attribute__((unused)) static inline char4 texCubemap(texture< char4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1231
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 texCubemap(texture< uchar4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1239
__attribute((always_inline)) __attribute__((unused)) static inline short texCubemap(texture< short, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1241
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short texCubemap(texture< unsigned short, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1243
__attribute((always_inline)) __attribute__((unused)) static inline short1 texCubemap(texture< short1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1245
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 texCubemap(texture< ushort1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1247
__attribute((always_inline)) __attribute__((unused)) static inline short2 texCubemap(texture< short2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1249
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 texCubemap(texture< ushort2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1251
__attribute((always_inline)) __attribute__((unused)) static inline short4 texCubemap(texture< short4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1253
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 texCubemap(texture< ushort4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1261
__attribute((always_inline)) __attribute__((unused)) static inline int texCubemap(texture< int, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1263
__attribute((always_inline)) __attribute__((unused)) static inline unsigned texCubemap(texture< unsigned, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1265
__attribute((always_inline)) __attribute__((unused)) static inline int1 texCubemap(texture< int1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1267
__attribute((always_inline)) __attribute__((unused)) static inline uint1 texCubemap(texture< uint1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1269
__attribute((always_inline)) __attribute__((unused)) static inline int2 texCubemap(texture< int2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1271
__attribute((always_inline)) __attribute__((unused)) static inline uint2 texCubemap(texture< uint2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1273
__attribute((always_inline)) __attribute__((unused)) static inline int4 texCubemap(texture< int4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1275
__attribute((always_inline)) __attribute__((unused)) static inline uint4 texCubemap(texture< uint4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1309 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< float, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1311
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemap(texture< float1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1313
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemap(texture< float2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1315
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemap(texture< float4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
# 1323
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1325
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< signed char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1327
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< unsigned char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1329
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemap(texture< char1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1331
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemap(texture< uchar1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1333
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemap(texture< char2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1335
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemap(texture< uchar2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1337
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemap(texture< char4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1339
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemap(texture< uchar4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1347
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1349
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< unsigned short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1351
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemap(texture< short1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1353
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemap(texture< ushort1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1355
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemap(texture< short2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1357
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemap(texture< ushort2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1359
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemap(texture< short4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1361
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemap(texture< ushort4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
# 1369
__attribute((always_inline)) __attribute__((unused)) static inline char texCubemapLayered(texture< char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1371
__attribute((always_inline)) __attribute__((unused)) static inline signed char texCubemapLayered(texture< signed char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1373
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char texCubemapLayered(texture< unsigned char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1375
__attribute((always_inline)) __attribute__((unused)) static inline char1 texCubemapLayered(texture< char1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1377
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 texCubemapLayered(texture< uchar1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1379
__attribute((always_inline)) __attribute__((unused)) static inline char2 texCubemapLayered(texture< char2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1381
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 texCubemapLayered(texture< uchar2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1383
__attribute((always_inline)) __attribute__((unused)) static inline char4 texCubemapLayered(texture< char4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1385
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 texCubemapLayered(texture< uchar4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1393
__attribute((always_inline)) __attribute__((unused)) static inline short texCubemapLayered(texture< short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1395
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short texCubemapLayered(texture< unsigned short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1397
__attribute((always_inline)) __attribute__((unused)) static inline short1 texCubemapLayered(texture< short1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1399
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 texCubemapLayered(texture< ushort1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1401
__attribute((always_inline)) __attribute__((unused)) static inline short2 texCubemapLayered(texture< short2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1403
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 texCubemapLayered(texture< ushort2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1405
__attribute((always_inline)) __attribute__((unused)) static inline short4 texCubemapLayered(texture< short4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1407
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 texCubemapLayered(texture< ushort4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1415
__attribute((always_inline)) __attribute__((unused)) static inline int texCubemapLayered(texture< int, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1417
__attribute((always_inline)) __attribute__((unused)) static inline unsigned texCubemapLayered(texture< unsigned, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1419
__attribute((always_inline)) __attribute__((unused)) static inline int1 texCubemapLayered(texture< int1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1421
__attribute((always_inline)) __attribute__((unused)) static inline uint1 texCubemapLayered(texture< uint1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1423
__attribute((always_inline)) __attribute__((unused)) static inline int2 texCubemapLayered(texture< int2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1425
__attribute((always_inline)) __attribute__((unused)) static inline uint2 texCubemapLayered(texture< uint2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1427
__attribute((always_inline)) __attribute__((unused)) static inline int4 texCubemapLayered(texture< int4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1429
__attribute((always_inline)) __attribute__((unused)) static inline uint4 texCubemapLayered(texture< uint4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1463 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< float, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1465
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayered(texture< float1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1467
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayered(texture< float2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1469
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayered(texture< float4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
# 1477
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1479
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< signed char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1481
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< unsigned char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1483
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayered(texture< char1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1485
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayered(texture< uchar1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1487
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayered(texture< char2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1489
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayered(texture< uchar2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1491
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayered(texture< char4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1493
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayered(texture< uchar4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1501
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1503
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< unsigned short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1505
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayered(texture< short1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1507
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayered(texture< ushort1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1509
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayered(texture< short2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1511
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayered(texture< ushort2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1513
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayered(texture< short4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1515
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayered(texture< ushort4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
# 1586 "/usr/include/texture_fetch_functions.h" 3
template< int comp, class T, cudaTextureReadMode readMode> 
# 1587
__attribute((always_inline)) __attribute__((unused)) static inline int4 
# 1588
__itex2Dgather(texture< T, 2, readMode>  t, float2 i, int 
# 1589
c = comp) 
# 1590
{int volatile ___ = 1;(void)t;(void)i;(void)c;
# 1598
::exit(___);}
#if 0
# 1590
{ 
# 1591
switch (c) { 
# 1592
case 0:  return __itex2Dgather0(t, i); 
# 1593
case 1:  return __itex2Dgather1(t, i); 
# 1594
case 2:  return __itex2Dgather2(t, i); 
# 1596
default:  return __itex2Dgather3(t, i); 
# 1597
}  
# 1598
} 
#endif
# 1600 "/usr/include/texture_fetch_functions.h" 3
template< int comp, class T, cudaTextureReadMode readMode> 
# 1601
__attribute((always_inline)) __attribute__((unused)) static inline uint4 
# 1602
__utex2Dgather(texture< T, 2, readMode>  t, float2 i, int 
# 1603
c = comp) 
# 1604
{int volatile ___ = 1;(void)t;(void)i;(void)c;
# 1612
::exit(___);}
#if 0
# 1604
{ 
# 1605
switch (c) { 
# 1606
case 0:  return __utex2Dgather0(t, i); 
# 1607
case 1:  return __utex2Dgather1(t, i); 
# 1608
case 2:  return __utex2Dgather2(t, i); 
# 1610
default:  return __utex2Dgather3(t, i); 
# 1611
}  
# 1612
} 
#endif
# 1614 "/usr/include/texture_fetch_functions.h" 3
template< int comp, class T, cudaTextureReadMode readMode> 
# 1615
__attribute((always_inline)) __attribute__((unused)) static inline float4 
# 1616
__ftex2Dgather(texture< T, 2, readMode>  t, float2 i, int 
# 1617
c = comp) 
# 1618
{int volatile ___ = 1;(void)t;(void)i;(void)c;
# 1626
::exit(___);}
#if 0
# 1618
{ 
# 1619
switch (c) { 
# 1620
case 0:  return __ftex2Dgather0(t, i); 
# 1621
case 1:  return __ftex2Dgather1(t, i); 
# 1622
case 2:  return __ftex2Dgather2(t, i); 
# 1624
default:  return __ftex2Dgather3(t, i); 
# 1625
}  
# 1626
} 
#endif
# 1628 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< char, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1630
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1632
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2Dgather(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1634
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1636
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2Dgather(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1638
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1640
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2Dgather(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1642
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< char3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1644
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2Dgather(texture< uchar3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1646
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1648
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2Dgather(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1650
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2Dgather(texture< short, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1652
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2Dgather(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1654
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2Dgather(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1656
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2Dgather(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1658
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2Dgather(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1660
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2Dgather(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1662
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2Dgather(texture< short3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1664
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2Dgather(texture< ushort3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1666
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2Dgather(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1668
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2Dgather(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1670
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2Dgather(texture< int, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1672
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2Dgather(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1674
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2Dgather(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1676
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2Dgather(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1678
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2Dgather(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1680
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2Dgather(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1682
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2Dgather(texture< int3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1684
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2Dgather(texture< uint3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1686
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2Dgather(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1688
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2Dgather(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1690
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< float, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1692
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1694
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1696
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< float3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1698
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
# 1707 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1709
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1711
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1713
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1715
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1717
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1719
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1721
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< char3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1723
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< uchar3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1725
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1727
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1729
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1731
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1733
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1735
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1737
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1739
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1741
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< short3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1743
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< ushort3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1745
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1747
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
# 1839
template< class T, int texType, cudaTextureReadMode readMode> 
# 1840
__attribute((always_inline)) __attribute__((unused)) static inline uint4 
# 1841
__utexfetchlod(texture< T, texType, readMode>  t, float4 i, float level, int 
# 1842
d = texType) 
# 1843
{int volatile ___ = 1;(void)t;(void)i;(void)level;(void)d;
# 1850
::exit(___);}
#if 0
# 1843
{ 
# 1844
switch (d) { 
# 1845
case 1:  return __utexfetchlod1D(t, i, level); 
# 1846
case 2:  return __utexfetchlod2D(t, i, level); 
# 1848
default:  return __utexfetchlod3D(t, i, level); 
# 1849
}  
# 1850
} 
#endif
# 1852 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 1853
__attribute((always_inline)) __attribute__((unused)) static inline int4 
# 1854
__itexfetchlod(texture< T, texType, readMode>  t, float4 i, float level, int 
# 1855
d = texType) 
# 1856
{int volatile ___ = 1;(void)t;(void)i;(void)level;(void)d;
# 1863
::exit(___);}
#if 0
# 1856
{ 
# 1857
switch (d) { 
# 1858
case 1:  return __itexfetchlod1D(t, i, level); 
# 1859
case 2:  return __itexfetchlod2D(t, i, level); 
# 1861
default:  return __itexfetchlod3D(t, i, level); 
# 1862
}  
# 1863
} 
#endif
# 1865 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 1866
__attribute((always_inline)) __attribute__((unused)) static inline float4 
# 1867
__ftexfetchlod(texture< T, texType, readMode>  t, float4 i, float level, int 
# 1868
d = texType) 
# 1869
{int volatile ___ = 1;(void)t;(void)i;(void)level;(void)d;
# 1876
::exit(___);}
#if 0
# 1869
{ 
# 1870
switch (d) { 
# 1871
case 1:  return __ftexfetchlod1D(t, i, level); 
# 1872
case 2:  return __ftexfetchlod2D(t, i, level); 
# 1874
default:  return __ftexfetchlod3D(t, i, level); 
# 1875
}  
# 1876
} 
#endif
# 1879 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 1880
__attribute((always_inline)) __attribute__((unused)) static inline uint4 
# 1881
__utexfetchlodc(texture< T, texType, readMode>  t, float4 i, float level) 
# 1882
{int volatile ___ = 1;(void)t;(void)i;(void)level;
# 1884
::exit(___);}
#if 0
# 1882
{ 
# 1883
return __utexfetchlodcube(t, i, level); 
# 1884
} 
#endif
# 1886 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 1887
__attribute((always_inline)) __attribute__((unused)) static inline int4 
# 1888
__itexfetchlodc(texture< T, texType, readMode>  t, float4 i, float level) 
# 1889
{int volatile ___ = 1;(void)t;(void)i;(void)level;
# 1891
::exit(___);}
#if 0
# 1889
{ 
# 1890
return __itexfetchlodcube(t, i, level); 
# 1891
} 
#endif
# 1893 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 1894
__attribute((always_inline)) __attribute__((unused)) static inline float4 
# 1895
__ftexfetchlodc(texture< T, texType, readMode>  t, float4 i, float level) 
# 1896
{int volatile ___ = 1;(void)t;(void)i;(void)level;
# 1898
::exit(___);}
#if 0
# 1896
{ 
# 1897
return __ftexfetchlodcube(t, i, level); 
# 1898
} 
#endif
# 1900 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 1901
__attribute((always_inline)) __attribute__((unused)) static inline uint4 
# 1902
__utexfetchlodl(texture< T, texType, readMode>  t, float4 i, int l, float 
# 1903
level, int d = texType & 15) 
# 1904
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)level;(void)d;
# 1910
::exit(___);}
#if 0
# 1904
{ 
# 1905
switch (d) { 
# 1906
case 1:  return __utexfetchlodl1D(t, i, l, level); 
# 1908
default:  return __utexfetchlodl2D(t, i, l, level); 
# 1909
}  
# 1910
} 
#endif
# 1912 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 1913
__attribute((always_inline)) __attribute__((unused)) static inline int4 
# 1914
__itexfetchlodl(texture< T, texType, readMode>  t, float4 i, int l, float 
# 1915
level, int d = texType & 15) 
# 1916
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)level;(void)d;
# 1922
::exit(___);}
#if 0
# 1916
{ 
# 1917
switch (d) { 
# 1918
case 1:  return __itexfetchlodl1D(t, i, l, level); 
# 1920
default:  return __itexfetchlodl2D(t, i, l, level); 
# 1921
}  
# 1922
} 
#endif
# 1924 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 1925
__attribute((always_inline)) __attribute__((unused)) static inline float4 
# 1926
__ftexfetchlodl(texture< T, texType, readMode>  t, float4 i, int l, float 
# 1927
level, int d = texType & 15) 
# 1928
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)level;(void)d;
# 1934
::exit(___);}
#if 0
# 1928
{ 
# 1929
switch (d) { 
# 1930
case 1:  return __ftexfetchlodl1D(t, i, l, level); 
# 1932
default:  return __ftexfetchlodl2D(t, i, l, level); 
# 1933
}  
# 1934
} 
#endif
# 1937 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 1938
__attribute((always_inline)) __attribute__((unused)) static inline uint4 
# 1939
__utexfetchlodlc(texture< T, texType, readMode>  t, float4 i, int l, float 
# 1940
level) 
# 1941
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)level;
# 1943
::exit(___);}
#if 0
# 1941
{ 
# 1942
return __utexfetchlodlcube(t, i, l, level); 
# 1943
} 
#endif
# 1945 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 1946
__attribute((always_inline)) __attribute__((unused)) static inline int4 
# 1947
__itexfetchlodlc(texture< T, texType, readMode>  t, float4 i, int l, float 
# 1948
level) 
# 1949
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)level;
# 1951
::exit(___);}
#if 0
# 1949
{ 
# 1950
return __itexfetchlodlcube(t, i, l, level); 
# 1951
} 
#endif
# 1953 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 1954
__attribute((always_inline)) __attribute__((unused)) static inline float4 
# 1955
__ftexfetchlodlc(texture< T, texType, readMode>  t, float4 i, int l, float 
# 1956
level) 
# 1957
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)level;
# 1959
::exit(___);}
#if 0
# 1957
{ 
# 1958
return __ftexfetchlodlcube(t, i, l, level); 
# 1959
} 
#endif
# 1968 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex1DLod(texture< char, 1, cudaReadModeElementType>  t, float x, float level); 
# 1970
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1DLod(texture< signed char, 1, cudaReadModeElementType>  t, float x, float level); 
# 1972
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1DLod(texture< unsigned char, 1, cudaReadModeElementType>  t, float x, float level); 
# 1974
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1DLod(texture< char1, 1, cudaReadModeElementType>  t, float x, float level); 
# 1976
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1DLod(texture< uchar1, 1, cudaReadModeElementType>  t, float x, float level); 
# 1978
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1DLod(texture< char2, 1, cudaReadModeElementType>  t, float x, float level); 
# 1980
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1DLod(texture< uchar2, 1, cudaReadModeElementType>  t, float x, float level); 
# 1982
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1DLod(texture< char4, 1, cudaReadModeElementType>  t, float x, float level); 
# 1984
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1DLod(texture< uchar4, 1, cudaReadModeElementType>  t, float x, float level); 
# 1992
__attribute((always_inline)) __attribute__((unused)) static inline short tex1DLod(texture< short, 1, cudaReadModeElementType>  t, float x, float level); 
# 1994
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1DLod(texture< unsigned short, 1, cudaReadModeElementType>  t, float x, float level); 
# 1996
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1DLod(texture< short1, 1, cudaReadModeElementType>  t, float x, float level); 
# 1998
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1DLod(texture< ushort1, 1, cudaReadModeElementType>  t, float x, float level); 
# 2000
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1DLod(texture< short2, 1, cudaReadModeElementType>  t, float x, float level); 
# 2002
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1DLod(texture< ushort2, 1, cudaReadModeElementType>  t, float x, float level); 
# 2004
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1DLod(texture< short4, 1, cudaReadModeElementType>  t, float x, float level); 
# 2006
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1DLod(texture< ushort4, 1, cudaReadModeElementType>  t, float x, float level); 
# 2014
__attribute((always_inline)) __attribute__((unused)) static inline int tex1DLod(texture< int, 1, cudaReadModeElementType>  t, float x, float level); 
# 2016
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1DLod(texture< unsigned, 1, cudaReadModeElementType>  t, float x, float level); 
# 2018
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1DLod(texture< int1, 1, cudaReadModeElementType>  t, float x, float level); 
# 2020
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1DLod(texture< uint1, 1, cudaReadModeElementType>  t, float x, float level); 
# 2022
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1DLod(texture< int2, 1, cudaReadModeElementType>  t, float x, float level); 
# 2024
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1DLod(texture< uint2, 1, cudaReadModeElementType>  t, float x, float level); 
# 2026
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1DLod(texture< int4, 1, cudaReadModeElementType>  t, float x, float level); 
# 2028
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1DLod(texture< uint4, 1, cudaReadModeElementType>  t, float x, float level); 
# 2068 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< float, 1, cudaReadModeElementType>  t, float x, float level); 
# 2070
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLod(texture< float1, 1, cudaReadModeElementType>  t, float x, float level); 
# 2072
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLod(texture< float2, 1, cudaReadModeElementType>  t, float x, float level); 
# 2074
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLod(texture< float4, 1, cudaReadModeElementType>  t, float x, float level); 
# 2082
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2084
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2086
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2088
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLod(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2090
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLod(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2092
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLod(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2094
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLod(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2096
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLod(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2098
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLod(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2106
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2108
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2110
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLod(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2112
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLod(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2114
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLod(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2116
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLod(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2118
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLod(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2120
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLod(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
# 2128
__attribute((always_inline)) __attribute__((unused)) static inline char tex2DLod(texture< char, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2130
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2DLod(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2132
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2DLod(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2134
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2DLod(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2136
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2DLod(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2138
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2DLod(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2140
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2DLod(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2142
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2DLod(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2144
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2DLod(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2152
__attribute((always_inline)) __attribute__((unused)) static inline short tex2DLod(texture< short, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2154
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2DLod(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2156
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2DLod(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2158
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2DLod(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2160
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2DLod(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2162
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2DLod(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2164
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2DLod(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2166
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2DLod(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2174
__attribute((always_inline)) __attribute__((unused)) static inline int tex2DLod(texture< int, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2176
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2DLod(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2178
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2DLod(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2180
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2DLod(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2182
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2DLod(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2184
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2DLod(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2186
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2DLod(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2188
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2DLod(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2222 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< float, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2224
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLod(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2226
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLod(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2228
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLod(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
# 2236
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2238
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2240
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2242
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLod(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2244
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLod(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2246
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLod(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2248
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLod(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2250
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLod(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2252
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLod(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2260
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2262
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2264
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLod(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2266
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLod(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2268
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLod(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2270
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLod(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2272
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLod(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2274
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLod(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
# 2282
__attribute((always_inline)) __attribute__((unused)) static inline char tex1DLayeredLod(texture< char, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2284
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1DLayeredLod(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2286
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1DLayeredLod(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2288
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1DLayeredLod(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2290
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1DLayeredLod(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2292
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1DLayeredLod(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2294
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1DLayeredLod(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2296
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1DLayeredLod(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2298
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1DLayeredLod(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2306
__attribute((always_inline)) __attribute__((unused)) static inline short tex1DLayeredLod(texture< short, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2308
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1DLayeredLod(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2310
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1DLayeredLod(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2312
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1DLayeredLod(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2314
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1DLayeredLod(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2316
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1DLayeredLod(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2318
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1DLayeredLod(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2320
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1DLayeredLod(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2328
__attribute((always_inline)) __attribute__((unused)) static inline int tex1DLayeredLod(texture< int, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2330
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1DLayeredLod(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2332
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1DLayeredLod(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2334
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1DLayeredLod(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2336
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1DLayeredLod(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2338
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1DLayeredLod(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2340
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1DLayeredLod(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2342
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1DLayeredLod(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2376 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< float, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2378
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredLod(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2380
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredLod(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2382
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredLod(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
# 2390
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2392
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2394
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2396
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredLod(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2398
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredLod(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2400
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredLod(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2402
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredLod(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2404
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredLod(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2406
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredLod(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2414
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2416
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2418
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredLod(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2420
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredLod(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2422
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredLod(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2424
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredLod(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2426
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredLod(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2428
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredLod(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
# 2436
__attribute((always_inline)) __attribute__((unused)) static inline char tex2DLayeredLod(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2438
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2DLayeredLod(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2440
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2DLayeredLod(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2442
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2DLayeredLod(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2444
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2DLayeredLod(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2446
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2DLayeredLod(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2448
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2DLayeredLod(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2450
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2DLayeredLod(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2452
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2DLayeredLod(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2460
__attribute((always_inline)) __attribute__((unused)) static inline short tex2DLayeredLod(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2462
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2DLayeredLod(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2464
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2DLayeredLod(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2466
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2DLayeredLod(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2468
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2DLayeredLod(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2470
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2DLayeredLod(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2472
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2DLayeredLod(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2474
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2DLayeredLod(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2482
__attribute((always_inline)) __attribute__((unused)) static inline int tex2DLayeredLod(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2484
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2DLayeredLod(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2486
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2DLayeredLod(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2488
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2DLayeredLod(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2490
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2DLayeredLod(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2492
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2DLayeredLod(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2494
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2DLayeredLod(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2496
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2DLayeredLod(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2530 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2532
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredLod(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2534
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredLod(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2536
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredLod(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
# 2544
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2546
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2548
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2550
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredLod(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2552
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredLod(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2554
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredLod(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2556
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredLod(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2558
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredLod(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2560
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredLod(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2568
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2570
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2572
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredLod(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2574
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredLod(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2576
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredLod(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2578
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredLod(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2580
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredLod(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2582
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredLod(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
# 2590
__attribute((always_inline)) __attribute__((unused)) static inline char tex3DLod(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2592
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex3DLod(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2594
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex3DLod(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2596
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex3DLod(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2598
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex3DLod(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2600
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex3DLod(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2602
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex3DLod(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2604
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex3DLod(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2606
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex3DLod(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2614
__attribute((always_inline)) __attribute__((unused)) static inline short tex3DLod(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2616
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex3DLod(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2618
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex3DLod(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2620
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex3DLod(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2622
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex3DLod(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2624
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex3DLod(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2626
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex3DLod(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2628
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex3DLod(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2636
__attribute((always_inline)) __attribute__((unused)) static inline int tex3DLod(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2638
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex3DLod(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2640
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex3DLod(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2642
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex3DLod(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2644
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex3DLod(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2646
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex3DLod(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2648
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex3DLod(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2650
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex3DLod(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2684 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2686
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DLod(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2688
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DLod(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2690
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DLod(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2698
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2700
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2702
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2704
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DLod(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2706
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DLod(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2708
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DLod(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2710
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DLod(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2712
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DLod(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2714
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DLod(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2722
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2724
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2726
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DLod(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2728
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DLod(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2730
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DLod(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2732
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DLod(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2734
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DLod(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2736
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DLod(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2744
__attribute((always_inline)) __attribute__((unused)) static inline char texCubemapLod(texture< char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2746
__attribute((always_inline)) __attribute__((unused)) static inline signed char texCubemapLod(texture< signed char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2748
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char texCubemapLod(texture< unsigned char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2750
__attribute((always_inline)) __attribute__((unused)) static inline char1 texCubemapLod(texture< char1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2752
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 texCubemapLod(texture< uchar1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2754
__attribute((always_inline)) __attribute__((unused)) static inline char2 texCubemapLod(texture< char2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2756
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 texCubemapLod(texture< uchar2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2758
__attribute((always_inline)) __attribute__((unused)) static inline char4 texCubemapLod(texture< char4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2760
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 texCubemapLod(texture< uchar4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2768
__attribute((always_inline)) __attribute__((unused)) static inline short texCubemapLod(texture< short, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2770
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short texCubemapLod(texture< unsigned short, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2772
__attribute((always_inline)) __attribute__((unused)) static inline short1 texCubemapLod(texture< short1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2774
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 texCubemapLod(texture< ushort1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2776
__attribute((always_inline)) __attribute__((unused)) static inline short2 texCubemapLod(texture< short2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2778
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 texCubemapLod(texture< ushort2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2780
__attribute((always_inline)) __attribute__((unused)) static inline short4 texCubemapLod(texture< short4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2782
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 texCubemapLod(texture< ushort4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2790
__attribute((always_inline)) __attribute__((unused)) static inline int texCubemapLod(texture< int, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2792
__attribute((always_inline)) __attribute__((unused)) static inline unsigned texCubemapLod(texture< unsigned, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2794
__attribute((always_inline)) __attribute__((unused)) static inline int1 texCubemapLod(texture< int1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2796
__attribute((always_inline)) __attribute__((unused)) static inline uint1 texCubemapLod(texture< uint1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2798
__attribute((always_inline)) __attribute__((unused)) static inline int2 texCubemapLod(texture< int2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2800
__attribute((always_inline)) __attribute__((unused)) static inline uint2 texCubemapLod(texture< uint2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2802
__attribute((always_inline)) __attribute__((unused)) static inline int4 texCubemapLod(texture< int4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2804
__attribute((always_inline)) __attribute__((unused)) static inline uint4 texCubemapLod(texture< uint4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2838 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< float, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2840
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLod(texture< float1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2842
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLod(texture< float2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2844
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLod(texture< float4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
# 2852
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2854
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< signed char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2856
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< unsigned char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2858
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLod(texture< char1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2860
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLod(texture< uchar1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2862
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLod(texture< char2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2864
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLod(texture< uchar2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2866
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLod(texture< char4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2868
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLod(texture< uchar4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2876
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2878
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< unsigned short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2880
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLod(texture< short1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2882
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLod(texture< ushort1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2884
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLod(texture< short2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2886
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLod(texture< ushort2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2888
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLod(texture< short4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2890
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLod(texture< ushort4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
# 2898
__attribute((always_inline)) __attribute__((unused)) static inline char texCubemapLayeredLod(texture< char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2900
__attribute((always_inline)) __attribute__((unused)) static inline signed char texCubemapLayeredLod(texture< signed char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2902
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char texCubemapLayeredLod(texture< unsigned char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2904
__attribute((always_inline)) __attribute__((unused)) static inline char1 texCubemapLayeredLod(texture< char1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2906
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 texCubemapLayeredLod(texture< uchar1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2908
__attribute((always_inline)) __attribute__((unused)) static inline char2 texCubemapLayeredLod(texture< char2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2910
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 texCubemapLayeredLod(texture< uchar2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2912
__attribute((always_inline)) __attribute__((unused)) static inline char4 texCubemapLayeredLod(texture< char4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2914
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 texCubemapLayeredLod(texture< uchar4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2922
__attribute((always_inline)) __attribute__((unused)) static inline short texCubemapLayeredLod(texture< short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2924
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short texCubemapLayeredLod(texture< unsigned short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2926
__attribute((always_inline)) __attribute__((unused)) static inline short1 texCubemapLayeredLod(texture< short1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2928
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 texCubemapLayeredLod(texture< ushort1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2930
__attribute((always_inline)) __attribute__((unused)) static inline short2 texCubemapLayeredLod(texture< short2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2932
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 texCubemapLayeredLod(texture< ushort2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2934
__attribute((always_inline)) __attribute__((unused)) static inline short4 texCubemapLayeredLod(texture< short4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2936
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 texCubemapLayeredLod(texture< ushort4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2944
__attribute((always_inline)) __attribute__((unused)) static inline int texCubemapLayeredLod(texture< int, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2946
__attribute((always_inline)) __attribute__((unused)) static inline unsigned texCubemapLayeredLod(texture< unsigned, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2948
__attribute((always_inline)) __attribute__((unused)) static inline int1 texCubemapLayeredLod(texture< int1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2950
__attribute((always_inline)) __attribute__((unused)) static inline uint1 texCubemapLayeredLod(texture< uint1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2952
__attribute((always_inline)) __attribute__((unused)) static inline int2 texCubemapLayeredLod(texture< int2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2954
__attribute((always_inline)) __attribute__((unused)) static inline uint2 texCubemapLayeredLod(texture< uint2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2956
__attribute((always_inline)) __attribute__((unused)) static inline int4 texCubemapLayeredLod(texture< int4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2958
__attribute((always_inline)) __attribute__((unused)) static inline uint4 texCubemapLayeredLod(texture< uint4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2992 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< float, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2994
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayeredLod(texture< float1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2996
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayeredLod(texture< float2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 2998
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayeredLod(texture< float4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
# 3006
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3008
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< signed char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3010
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< unsigned char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3012
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayeredLod(texture< char1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3014
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayeredLod(texture< uchar1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3016
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayeredLod(texture< char2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3018
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayeredLod(texture< uchar2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3020
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayeredLod(texture< char4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3022
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayeredLod(texture< uchar4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3030
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3032
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< unsigned short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3034
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayeredLod(texture< short1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3036
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayeredLod(texture< ushort1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3038
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayeredLod(texture< short2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3040
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayeredLod(texture< ushort2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3042
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayeredLod(texture< short4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3044
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayeredLod(texture< ushort4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
# 3047
template< class T, int texType, cudaTextureReadMode readMode> 
# 3048
__attribute((always_inline)) __attribute__((unused)) static inline uint4 
# 3049
__utexfetchgrad(texture< T, texType, readMode>  t, float4 i, float4 dPdx, float4 dPdy, int d = texType) 
# 3050
{int volatile ___ = 1;(void)t;(void)i;(void)dPdx;(void)dPdy;(void)d;
# 3057
::exit(___);}
#if 0
# 3050
{ 
# 3051
switch (d) { 
# 3052
case 1:  return __utexfetchgrad1D(t, i, dPdx, dPdy); 
# 3053
case 2:  return __utexfetchgrad2D(t, i, dPdx, dPdy); 
# 3055
default:  return __utexfetchgrad3D(t, i, dPdx, dPdy); 
# 3056
}  
# 3057
} 
#endif
# 3059 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 3060
__attribute((always_inline)) __attribute__((unused)) static inline int4 
# 3061
__itexfetchgrad(texture< T, texType, readMode>  t, float4 i, float4 dPdx, float4 dPdy, int d = texType) 
# 3062
{int volatile ___ = 1;(void)t;(void)i;(void)dPdx;(void)dPdy;(void)d;
# 3069
::exit(___);}
#if 0
# 3062
{ 
# 3063
switch (d) { 
# 3064
case 1:  return __itexfetchgrad1D(t, i, dPdx, dPdy); 
# 3065
case 2:  return __itexfetchgrad2D(t, i, dPdx, dPdy); 
# 3067
default:  return __itexfetchgrad3D(t, i, dPdx, dPdy); 
# 3068
}  
# 3069
} 
#endif
# 3071 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 3072
__attribute((always_inline)) __attribute__((unused)) static inline float4 
# 3073
__ftexfetchgrad(texture< T, texType, readMode>  t, float4 i, float4 dPdx, float4 dPdy, int d = texType) 
# 3074
{int volatile ___ = 1;(void)t;(void)i;(void)dPdx;(void)dPdy;(void)d;
# 3081
::exit(___);}
#if 0
# 3074
{ 
# 3075
switch (d) { 
# 3076
case 1:  return __ftexfetchgrad1D(t, i, dPdx, dPdy); 
# 3077
case 2:  return __ftexfetchgrad2D(t, i, dPdx, dPdy); 
# 3079
default:  return __ftexfetchgrad3D(t, i, dPdx, dPdy); 
# 3080
}  
# 3081
} 
#endif
# 3083 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 3084
__attribute((always_inline)) __attribute__((unused)) static inline uint4 
# 3085
__utexfetchgradl(texture< T, texType, readMode>  t, float4 i, int l, float4 dPdx, float4 dPdy, int d = texType & 15) 
# 3086
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)dPdx;(void)dPdy;(void)d;
# 3092
::exit(___);}
#if 0
# 3086
{ 
# 3087
switch (d) { 
# 3088
case 1:  return __utexfetchgradl1D(t, i, l, dPdx, dPdy); 
# 3090
default:  return __utexfetchgradl2D(t, i, l, dPdx, dPdy); 
# 3091
}  
# 3092
} 
#endif
# 3094 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 3095
__attribute((always_inline)) __attribute__((unused)) static inline int4 
# 3096
__itexfetchgradl(texture< T, texType, readMode>  t, float4 i, int l, float4 dPdx, float4 dPdy, int d = texType & 15) 
# 3097
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)dPdx;(void)dPdy;(void)d;
# 3103
::exit(___);}
#if 0
# 3097
{ 
# 3098
switch (d) { 
# 3099
case 1:  return __itexfetchgradl1D(t, i, l, dPdx, dPdy); 
# 3101
default:  return __itexfetchgradl2D(t, i, l, dPdx, dPdy); 
# 3102
}  
# 3103
} 
#endif
# 3105 "/usr/include/texture_fetch_functions.h" 3
template< class T, int texType, cudaTextureReadMode readMode> 
# 3106
__attribute((always_inline)) __attribute__((unused)) static inline float4 
# 3107
__ftexfetchgradl(texture< T, texType, readMode>  t, float4 i, int l, float4 dPdx, float4 dPdy, int d = texType & 15) 
# 3108
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)dPdx;(void)dPdy;(void)d;
# 3114
::exit(___);}
#if 0
# 3108
{ 
# 3109
switch (d) { 
# 3110
case 1:  return __ftexfetchgradl1D(t, i, l, dPdx, dPdy); 
# 3112
default:  return __ftexfetchgradl2D(t, i, l, dPdx, dPdy); 
# 3113
}  
# 3114
} 
#endif
# 3123 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex1DGrad(texture< char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3125
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1DGrad(texture< signed char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3127
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1DGrad(texture< unsigned char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3129
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1DGrad(texture< char1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3131
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1DGrad(texture< uchar1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3133
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1DGrad(texture< char2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3135
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1DGrad(texture< uchar2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3137
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1DGrad(texture< char4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3139
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1DGrad(texture< uchar4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3147
__attribute((always_inline)) __attribute__((unused)) static inline short tex1DGrad(texture< short, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3149
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1DGrad(texture< unsigned short, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3151
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1DGrad(texture< short1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3153
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1DGrad(texture< ushort1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3155
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1DGrad(texture< short2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3157
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1DGrad(texture< ushort2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3159
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1DGrad(texture< short4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3161
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1DGrad(texture< ushort4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3169
__attribute((always_inline)) __attribute__((unused)) static inline int tex1DGrad(texture< int, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3171
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1DGrad(texture< unsigned, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3173
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1DGrad(texture< int1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3175
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1DGrad(texture< uint1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3177
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1DGrad(texture< int2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3179
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1DGrad(texture< uint2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3181
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1DGrad(texture< int4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3183
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1DGrad(texture< uint4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3223 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< float, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3225
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DGrad(texture< float1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3227
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DGrad(texture< float2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3229
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DGrad(texture< float4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
# 3237
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3239
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3241
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3243
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DGrad(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3245
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DGrad(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3247
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DGrad(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3249
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DGrad(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3251
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DGrad(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3253
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DGrad(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3261
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3263
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3265
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DGrad(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3267
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DGrad(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3269
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DGrad(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3271
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DGrad(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3273
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DGrad(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3275
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DGrad(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
# 3283
__attribute((always_inline)) __attribute__((unused)) static inline char tex2DGrad(texture< char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3285
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2DGrad(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3287
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2DGrad(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3289
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2DGrad(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3291
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2DGrad(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3293
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2DGrad(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3295
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2DGrad(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3297
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2DGrad(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3299
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2DGrad(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3307
__attribute((always_inline)) __attribute__((unused)) static inline short tex2DGrad(texture< short, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3309
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2DGrad(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3311
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2DGrad(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3313
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2DGrad(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3315
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2DGrad(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3317
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2DGrad(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3319
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2DGrad(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3321
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2DGrad(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3329
__attribute((always_inline)) __attribute__((unused)) static inline int tex2DGrad(texture< int, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3331
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2DGrad(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3333
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2DGrad(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3335
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2DGrad(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3337
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2DGrad(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3339
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2DGrad(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3341
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2DGrad(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3343
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2DGrad(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3377 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< float, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3379
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DGrad(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3381
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DGrad(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3383
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DGrad(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3391
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3393
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3395
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3397
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DGrad(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3399
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DGrad(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3401
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DGrad(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3403
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DGrad(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3405
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DGrad(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3407
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DGrad(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3415
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3417
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3419
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DGrad(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3421
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DGrad(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3423
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DGrad(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3425
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DGrad(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3427
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DGrad(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3429
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DGrad(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
# 3437
__attribute((always_inline)) __attribute__((unused)) static inline char tex1DLayeredGrad(texture< char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3439
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1DLayeredGrad(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3441
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1DLayeredGrad(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3443
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1DLayeredGrad(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3445
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1DLayeredGrad(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3447
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1DLayeredGrad(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3449
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1DLayeredGrad(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3451
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1DLayeredGrad(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3453
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1DLayeredGrad(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3461
__attribute((always_inline)) __attribute__((unused)) static inline short tex1DLayeredGrad(texture< short, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3463
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1DLayeredGrad(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3465
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1DLayeredGrad(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3467
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1DLayeredGrad(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3469
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1DLayeredGrad(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3471
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1DLayeredGrad(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3473
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1DLayeredGrad(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3475
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1DLayeredGrad(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3483
__attribute((always_inline)) __attribute__((unused)) static inline int tex1DLayeredGrad(texture< int, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3485
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1DLayeredGrad(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3487
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1DLayeredGrad(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3489
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1DLayeredGrad(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3491
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1DLayeredGrad(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3493
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1DLayeredGrad(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3495
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1DLayeredGrad(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3497
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1DLayeredGrad(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3531 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< float, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3533
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredGrad(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3535
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredGrad(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3537
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredGrad(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
# 3545
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3547
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3549
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3551
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredGrad(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3553
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredGrad(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3555
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredGrad(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3557
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredGrad(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3559
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredGrad(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3561
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredGrad(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3569
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3571
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3573
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredGrad(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3575
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredGrad(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3577
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredGrad(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3579
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredGrad(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3581
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredGrad(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3583
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredGrad(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
# 3591
__attribute((always_inline)) __attribute__((unused)) static inline char tex2DLayeredGrad(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3593
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2DLayeredGrad(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3595
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2DLayeredGrad(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3597
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2DLayeredGrad(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3599
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2DLayeredGrad(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3601
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2DLayeredGrad(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3603
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2DLayeredGrad(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3605
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2DLayeredGrad(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3607
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2DLayeredGrad(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3615
__attribute((always_inline)) __attribute__((unused)) static inline short tex2DLayeredGrad(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3617
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2DLayeredGrad(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3619
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2DLayeredGrad(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3621
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2DLayeredGrad(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3623
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2DLayeredGrad(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3625
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2DLayeredGrad(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3627
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2DLayeredGrad(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3629
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2DLayeredGrad(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3637
__attribute((always_inline)) __attribute__((unused)) static inline int tex2DLayeredGrad(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3639
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2DLayeredGrad(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3641
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2DLayeredGrad(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3643
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2DLayeredGrad(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3645
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2DLayeredGrad(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3647
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2DLayeredGrad(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3649
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2DLayeredGrad(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3651
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2DLayeredGrad(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3685 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3687
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredGrad(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3689
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredGrad(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3691
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredGrad(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3699
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3701
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3703
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3705
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredGrad(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3707
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredGrad(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3709
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredGrad(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3711
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredGrad(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3713
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredGrad(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3715
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredGrad(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3723
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3725
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3727
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredGrad(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3729
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredGrad(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3731
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredGrad(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3733
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredGrad(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3735
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredGrad(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3737
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredGrad(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 3745
__attribute((always_inline)) __attribute__((unused)) static inline char tex3DGrad(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3747
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex3DGrad(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3749
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex3DGrad(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3751
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex3DGrad(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3753
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex3DGrad(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3755
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex3DGrad(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3757
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex3DGrad(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3759
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex3DGrad(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3761
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex3DGrad(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3769
__attribute((always_inline)) __attribute__((unused)) static inline short tex3DGrad(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3771
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex3DGrad(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3773
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex3DGrad(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3775
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex3DGrad(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3777
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex3DGrad(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3779
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex3DGrad(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3781
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex3DGrad(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3783
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex3DGrad(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3791
__attribute((always_inline)) __attribute__((unused)) static inline int tex3DGrad(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3793
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex3DGrad(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3795
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex3DGrad(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3797
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex3DGrad(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3799
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex3DGrad(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3801
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex3DGrad(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3803
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex3DGrad(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3805
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex3DGrad(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3839 "/usr/include/texture_fetch_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3841
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DGrad(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3843
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DGrad(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3845
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DGrad(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3853
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3855
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3857
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3859
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DGrad(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3861
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DGrad(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3863
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DGrad(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3865
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DGrad(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3867
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DGrad(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3869
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DGrad(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3877
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3879
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3881
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DGrad(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3883
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DGrad(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3885
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DGrad(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3887
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DGrad(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3889
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DGrad(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 3891
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DGrad(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 80 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex1Dfetch(texture< char, 1, cudaReadModeElementType>  t, int x) 
# 81
{int volatile ___ = 1;(void)t;(void)x;
# 89
::exit(___);}
#if 0
# 81
{ 
# 85
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 88
return (char)(v.x); 
# 89
} 
#endif
# 91 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1Dfetch(texture< signed char, 1, cudaReadModeElementType>  t, int x) 
# 92
{int volatile ___ = 1;(void)t;(void)x;
# 96
::exit(___);}
#if 0
# 92
{ 
# 93
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 95
return (signed char)(v.x); 
# 96
} 
#endif
# 98 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1Dfetch(texture< unsigned char, 1, cudaReadModeElementType>  t, int x) 
# 99
{int volatile ___ = 1;(void)t;(void)x;
# 103
::exit(___);}
#if 0
# 99
{ 
# 100
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 102
return (unsigned char)(v.x); 
# 103
} 
#endif
# 105 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1Dfetch(texture< char1, 1, cudaReadModeElementType>  t, int x) 
# 106
{int volatile ___ = 1;(void)t;(void)x;
# 110
::exit(___);}
#if 0
# 106
{ 
# 107
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 109
return make_char1(v.x); 
# 110
} 
#endif
# 112 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1Dfetch(texture< uchar1, 1, cudaReadModeElementType>  t, int x) 
# 113
{int volatile ___ = 1;(void)t;(void)x;
# 117
::exit(___);}
#if 0
# 113
{ 
# 114
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 116
return make_uchar1(v.x); 
# 117
} 
#endif
# 119 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1Dfetch(texture< char2, 1, cudaReadModeElementType>  t, int x) 
# 120
{int volatile ___ = 1;(void)t;(void)x;
# 124
::exit(___);}
#if 0
# 120
{ 
# 121
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 123
return make_char2(v.x, v.y); 
# 124
} 
#endif
# 126 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1Dfetch(texture< uchar2, 1, cudaReadModeElementType>  t, int x) 
# 127
{int volatile ___ = 1;(void)t;(void)x;
# 131
::exit(___);}
#if 0
# 127
{ 
# 128
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 130
return make_uchar2(v.x, v.y); 
# 131
} 
#endif
# 133 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1Dfetch(texture< char4, 1, cudaReadModeElementType>  t, int x) 
# 134
{int volatile ___ = 1;(void)t;(void)x;
# 138
::exit(___);}
#if 0
# 134
{ 
# 135
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 137
return make_char4(v.x, v.y, v.z, v.w); 
# 138
} 
#endif
# 140 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1Dfetch(texture< uchar4, 1, cudaReadModeElementType>  t, int x) 
# 141
{int volatile ___ = 1;(void)t;(void)x;
# 145
::exit(___);}
#if 0
# 141
{ 
# 142
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 144
return make_uchar4(v.x, v.y, v.z, v.w); 
# 145
} 
#endif
# 153 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex1Dfetch(texture< short, 1, cudaReadModeElementType>  t, int x) 
# 154
{int volatile ___ = 1;(void)t;(void)x;
# 158
::exit(___);}
#if 0
# 154
{ 
# 155
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 157
return (short)(v.x); 
# 158
} 
#endif
# 160 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1Dfetch(texture< unsigned short, 1, cudaReadModeElementType>  t, int x) 
# 161
{int volatile ___ = 1;(void)t;(void)x;
# 165
::exit(___);}
#if 0
# 161
{ 
# 162
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 164
return (unsigned short)(v.x); 
# 165
} 
#endif
# 167 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1Dfetch(texture< short1, 1, cudaReadModeElementType>  t, int x) 
# 168
{int volatile ___ = 1;(void)t;(void)x;
# 172
::exit(___);}
#if 0
# 168
{ 
# 169
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 171
return make_short1(v.x); 
# 172
} 
#endif
# 174 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1Dfetch(texture< ushort1, 1, cudaReadModeElementType>  t, int x) 
# 175
{int volatile ___ = 1;(void)t;(void)x;
# 179
::exit(___);}
#if 0
# 175
{ 
# 176
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 178
return make_ushort1(v.x); 
# 179
} 
#endif
# 181 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1Dfetch(texture< short2, 1, cudaReadModeElementType>  t, int x) 
# 182
{int volatile ___ = 1;(void)t;(void)x;
# 186
::exit(___);}
#if 0
# 182
{ 
# 183
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 185
return make_short2(v.x, v.y); 
# 186
} 
#endif
# 188 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1Dfetch(texture< ushort2, 1, cudaReadModeElementType>  t, int x) 
# 189
{int volatile ___ = 1;(void)t;(void)x;
# 193
::exit(___);}
#if 0
# 189
{ 
# 190
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 192
return make_ushort2(v.x, v.y); 
# 193
} 
#endif
# 195 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1Dfetch(texture< short4, 1, cudaReadModeElementType>  t, int x) 
# 196
{int volatile ___ = 1;(void)t;(void)x;
# 200
::exit(___);}
#if 0
# 196
{ 
# 197
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 199
return make_short4(v.x, v.y, v.z, v.w); 
# 200
} 
#endif
# 202 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1Dfetch(texture< ushort4, 1, cudaReadModeElementType>  t, int x) 
# 203
{int volatile ___ = 1;(void)t;(void)x;
# 207
::exit(___);}
#if 0
# 203
{ 
# 204
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 206
return make_ushort4(v.x, v.y, v.z, v.w); 
# 207
} 
#endif
# 215 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex1Dfetch(texture< int, 1, cudaReadModeElementType>  t, int x) 
# 216
{int volatile ___ = 1;(void)t;(void)x;
# 220
::exit(___);}
#if 0
# 216
{ 
# 217
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 219
return (int)(v.x); 
# 220
} 
#endif
# 222 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1Dfetch(texture< unsigned, 1, cudaReadModeElementType>  t, int x) 
# 223
{int volatile ___ = 1;(void)t;(void)x;
# 227
::exit(___);}
#if 0
# 223
{ 
# 224
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 226
return (unsigned)(v.x); 
# 227
} 
#endif
# 229 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1Dfetch(texture< int1, 1, cudaReadModeElementType>  t, int x) 
# 230
{int volatile ___ = 1;(void)t;(void)x;
# 234
::exit(___);}
#if 0
# 230
{ 
# 231
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 233
return make_int1(v.x); 
# 234
} 
#endif
# 236 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1Dfetch(texture< uint1, 1, cudaReadModeElementType>  t, int x) 
# 237
{int volatile ___ = 1;(void)t;(void)x;
# 241
::exit(___);}
#if 0
# 237
{ 
# 238
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 240
return make_uint1(v.x); 
# 241
} 
#endif
# 243 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1Dfetch(texture< int2, 1, cudaReadModeElementType>  t, int x) 
# 244
{int volatile ___ = 1;(void)t;(void)x;
# 248
::exit(___);}
#if 0
# 244
{ 
# 245
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 247
return make_int2(v.x, v.y); 
# 248
} 
#endif
# 250 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1Dfetch(texture< uint2, 1, cudaReadModeElementType>  t, int x) 
# 251
{int volatile ___ = 1;(void)t;(void)x;
# 255
::exit(___);}
#if 0
# 251
{ 
# 252
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 254
return make_uint2(v.x, v.y); 
# 255
} 
#endif
# 257 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1Dfetch(texture< int4, 1, cudaReadModeElementType>  t, int x) 
# 258
{int volatile ___ = 1;(void)t;(void)x;
# 262
::exit(___);}
#if 0
# 258
{ 
# 259
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 261
return make_int4(v.x, v.y, v.z, v.w); 
# 262
} 
#endif
# 264 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1Dfetch(texture< uint4, 1, cudaReadModeElementType>  t, int x) 
# 265
{int volatile ___ = 1;(void)t;(void)x;
# 269
::exit(___);}
#if 0
# 265
{ 
# 266
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 268
return make_uint4(v.x, v.y, v.z, v.w); 
# 269
} 
#endif
# 343 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< float, 1, cudaReadModeElementType>  t, int x) 
# 344
{int volatile ___ = 1;(void)t;(void)x;
# 348
::exit(___);}
#if 0
# 344
{ 
# 345
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
# 347
return v.x; 
# 348
} 
#endif
# 350 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1Dfetch(texture< float1, 1, cudaReadModeElementType>  t, int x) 
# 351
{int volatile ___ = 1;(void)t;(void)x;
# 355
::exit(___);}
#if 0
# 351
{ 
# 352
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
# 354
return make_float1(v.x); 
# 355
} 
#endif
# 357 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1Dfetch(texture< float2, 1, cudaReadModeElementType>  t, int x) 
# 358
{int volatile ___ = 1;(void)t;(void)x;
# 362
::exit(___);}
#if 0
# 358
{ 
# 359
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
# 361
return make_float2(v.x, v.y); 
# 362
} 
#endif
# 364 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1Dfetch(texture< float4, 1, cudaReadModeElementType>  t, int x) 
# 365
{int volatile ___ = 1;(void)t;(void)x;
# 369
::exit(___);}
#if 0
# 365
{ 
# 366
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
# 368
return make_float4(v.x, v.y, v.z, v.w); 
# 369
} 
#endif
# 377 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< char, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 378
{int volatile ___ = 1;(void)t;(void)x;
# 387
::exit(___);}
#if 0
# 378
{ 
# 382
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 384
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 386
return w.x; 
# 387
} 
#endif
# 389 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 390
{int volatile ___ = 1;(void)t;(void)x;
# 395
::exit(___);}
#if 0
# 390
{ 
# 391
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 392
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 394
return w.x; 
# 395
} 
#endif
# 397 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 398
{int volatile ___ = 1;(void)t;(void)x;
# 403
::exit(___);}
#if 0
# 398
{ 
# 399
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 400
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 402
return w.x; 
# 403
} 
#endif
# 405 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1Dfetch(texture< char1, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 406
{int volatile ___ = 1;(void)t;(void)x;
# 411
::exit(___);}
#if 0
# 406
{ 
# 407
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 408
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 410
return make_float1(w.x); 
# 411
} 
#endif
# 413 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1Dfetch(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 414
{int volatile ___ = 1;(void)t;(void)x;
# 419
::exit(___);}
#if 0
# 414
{ 
# 415
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 416
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 418
return make_float1(w.x); 
# 419
} 
#endif
# 421 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1Dfetch(texture< char2, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 422
{int volatile ___ = 1;(void)t;(void)x;
# 427
::exit(___);}
#if 0
# 422
{ 
# 423
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 424
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 426
return make_float2(w.x, w.y); 
# 427
} 
#endif
# 429 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1Dfetch(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 430
{int volatile ___ = 1;(void)t;(void)x;
# 435
::exit(___);}
#if 0
# 430
{ 
# 431
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 432
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 434
return make_float2(w.x, w.y); 
# 435
} 
#endif
# 437 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1Dfetch(texture< char4, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 438
{int volatile ___ = 1;(void)t;(void)x;
# 443
::exit(___);}
#if 0
# 438
{ 
# 439
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 440
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 442
return make_float4(w.x, w.y, w.z, w.w); 
# 443
} 
#endif
# 445 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1Dfetch(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 446
{int volatile ___ = 1;(void)t;(void)x;
# 451
::exit(___);}
#if 0
# 446
{ 
# 447
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 448
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 450
return make_float4(w.x, w.y, w.z, w.w); 
# 451
} 
#endif
# 459 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< short, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 460
{int volatile ___ = 1;(void)t;(void)x;
# 465
::exit(___);}
#if 0
# 460
{ 
# 461
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 462
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 464
return w.x; 
# 465
} 
#endif
# 467 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 468
{int volatile ___ = 1;(void)t;(void)x;
# 473
::exit(___);}
#if 0
# 468
{ 
# 469
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 470
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 472
return w.x; 
# 473
} 
#endif
# 475 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1Dfetch(texture< short1, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 476
{int volatile ___ = 1;(void)t;(void)x;
# 481
::exit(___);}
#if 0
# 476
{ 
# 477
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 478
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 480
return make_float1(w.x); 
# 481
} 
#endif
# 483 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1Dfetch(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 484
{int volatile ___ = 1;(void)t;(void)x;
# 489
::exit(___);}
#if 0
# 484
{ 
# 485
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 486
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 488
return make_float1(w.x); 
# 489
} 
#endif
# 491 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1Dfetch(texture< short2, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 492
{int volatile ___ = 1;(void)t;(void)x;
# 497
::exit(___);}
#if 0
# 492
{ 
# 493
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 494
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 496
return make_float2(w.x, w.y); 
# 497
} 
#endif
# 499 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1Dfetch(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 500
{int volatile ___ = 1;(void)t;(void)x;
# 505
::exit(___);}
#if 0
# 500
{ 
# 501
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 502
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 504
return make_float2(w.x, w.y); 
# 505
} 
#endif
# 507 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1Dfetch(texture< short4, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 508
{int volatile ___ = 1;(void)t;(void)x;
# 513
::exit(___);}
#if 0
# 508
{ 
# 509
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 510
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 512
return make_float4(w.x, w.y, w.z, w.w); 
# 513
} 
#endif
# 515 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1Dfetch(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 516
{int volatile ___ = 1;(void)t;(void)x;
# 521
::exit(___);}
#if 0
# 516
{ 
# 517
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 518
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 520
return make_float4(w.x, w.y, w.z, w.w); 
# 521
} 
#endif
# 529 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex1D(texture< char, 1, cudaReadModeElementType>  t, float x) 
# 530
{int volatile ___ = 1;(void)t;(void)x;
# 538
::exit(___);}
#if 0
# 530
{ 
# 534
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 537
return (char)(v.x); 
# 538
} 
#endif
# 540 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1D(texture< signed char, 1, cudaReadModeElementType>  t, float x) 
# 541
{int volatile ___ = 1;(void)t;(void)x;
# 545
::exit(___);}
#if 0
# 541
{ 
# 542
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 544
return (signed char)(v.x); 
# 545
} 
#endif
# 547 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1D(texture< unsigned char, 1, cudaReadModeElementType>  t, float x) 
# 548
{int volatile ___ = 1;(void)t;(void)x;
# 552
::exit(___);}
#if 0
# 548
{ 
# 549
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 551
return (unsigned char)(v.x); 
# 552
} 
#endif
# 554 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1D(texture< char1, 1, cudaReadModeElementType>  t, float x) 
# 555
{int volatile ___ = 1;(void)t;(void)x;
# 559
::exit(___);}
#if 0
# 555
{ 
# 556
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 558
return make_char1(v.x); 
# 559
} 
#endif
# 561 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1D(texture< uchar1, 1, cudaReadModeElementType>  t, float x) 
# 562
{int volatile ___ = 1;(void)t;(void)x;
# 566
::exit(___);}
#if 0
# 562
{ 
# 563
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 565
return make_uchar1(v.x); 
# 566
} 
#endif
# 568 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1D(texture< char2, 1, cudaReadModeElementType>  t, float x) 
# 569
{int volatile ___ = 1;(void)t;(void)x;
# 573
::exit(___);}
#if 0
# 569
{ 
# 570
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 572
return make_char2(v.x, v.y); 
# 573
} 
#endif
# 575 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1D(texture< uchar2, 1, cudaReadModeElementType>  t, float x) 
# 576
{int volatile ___ = 1;(void)t;(void)x;
# 580
::exit(___);}
#if 0
# 576
{ 
# 577
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 579
return make_uchar2(v.x, v.y); 
# 580
} 
#endif
# 582 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1D(texture< char4, 1, cudaReadModeElementType>  t, float x) 
# 583
{int volatile ___ = 1;(void)t;(void)x;
# 587
::exit(___);}
#if 0
# 583
{ 
# 584
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 586
return make_char4(v.x, v.y, v.z, v.w); 
# 587
} 
#endif
# 589 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1D(texture< uchar4, 1, cudaReadModeElementType>  t, float x) 
# 590
{int volatile ___ = 1;(void)t;(void)x;
# 594
::exit(___);}
#if 0
# 590
{ 
# 591
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 593
return make_uchar4(v.x, v.y, v.z, v.w); 
# 594
} 
#endif
# 602 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex1D(texture< short, 1, cudaReadModeElementType>  t, float x) 
# 603
{int volatile ___ = 1;(void)t;(void)x;
# 607
::exit(___);}
#if 0
# 603
{ 
# 604
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 606
return (short)(v.x); 
# 607
} 
#endif
# 609 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1D(texture< unsigned short, 1, cudaReadModeElementType>  t, float x) 
# 610
{int volatile ___ = 1;(void)t;(void)x;
# 614
::exit(___);}
#if 0
# 610
{ 
# 611
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 613
return (unsigned short)(v.x); 
# 614
} 
#endif
# 616 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1D(texture< short1, 1, cudaReadModeElementType>  t, float x) 
# 617
{int volatile ___ = 1;(void)t;(void)x;
# 621
::exit(___);}
#if 0
# 617
{ 
# 618
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 620
return make_short1(v.x); 
# 621
} 
#endif
# 623 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1D(texture< ushort1, 1, cudaReadModeElementType>  t, float x) 
# 624
{int volatile ___ = 1;(void)t;(void)x;
# 628
::exit(___);}
#if 0
# 624
{ 
# 625
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 627
return make_ushort1(v.x); 
# 628
} 
#endif
# 630 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1D(texture< short2, 1, cudaReadModeElementType>  t, float x) 
# 631
{int volatile ___ = 1;(void)t;(void)x;
# 635
::exit(___);}
#if 0
# 631
{ 
# 632
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 634
return make_short2(v.x, v.y); 
# 635
} 
#endif
# 637 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1D(texture< ushort2, 1, cudaReadModeElementType>  t, float x) 
# 638
{int volatile ___ = 1;(void)t;(void)x;
# 642
::exit(___);}
#if 0
# 638
{ 
# 639
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 641
return make_ushort2(v.x, v.y); 
# 642
} 
#endif
# 644 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1D(texture< short4, 1, cudaReadModeElementType>  t, float x) 
# 645
{int volatile ___ = 1;(void)t;(void)x;
# 649
::exit(___);}
#if 0
# 645
{ 
# 646
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 648
return make_short4(v.x, v.y, v.z, v.w); 
# 649
} 
#endif
# 651 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1D(texture< ushort4, 1, cudaReadModeElementType>  t, float x) 
# 652
{int volatile ___ = 1;(void)t;(void)x;
# 656
::exit(___);}
#if 0
# 652
{ 
# 653
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 655
return make_ushort4(v.x, v.y, v.z, v.w); 
# 656
} 
#endif
# 664 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex1D(texture< int, 1, cudaReadModeElementType>  t, float x) 
# 665
{int volatile ___ = 1;(void)t;(void)x;
# 669
::exit(___);}
#if 0
# 665
{ 
# 666
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 668
return (int)(v.x); 
# 669
} 
#endif
# 671 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1D(texture< unsigned, 1, cudaReadModeElementType>  t, float x) 
# 672
{int volatile ___ = 1;(void)t;(void)x;
# 676
::exit(___);}
#if 0
# 672
{ 
# 673
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 675
return (unsigned)(v.x); 
# 676
} 
#endif
# 678 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1D(texture< int1, 1, cudaReadModeElementType>  t, float x) 
# 679
{int volatile ___ = 1;(void)t;(void)x;
# 683
::exit(___);}
#if 0
# 679
{ 
# 680
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 682
return make_int1(v.x); 
# 683
} 
#endif
# 685 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1D(texture< uint1, 1, cudaReadModeElementType>  t, float x) 
# 686
{int volatile ___ = 1;(void)t;(void)x;
# 690
::exit(___);}
#if 0
# 686
{ 
# 687
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 689
return make_uint1(v.x); 
# 690
} 
#endif
# 692 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1D(texture< int2, 1, cudaReadModeElementType>  t, float x) 
# 693
{int volatile ___ = 1;(void)t;(void)x;
# 697
::exit(___);}
#if 0
# 693
{ 
# 694
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 696
return make_int2(v.x, v.y); 
# 697
} 
#endif
# 699 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1D(texture< uint2, 1, cudaReadModeElementType>  t, float x) 
# 700
{int volatile ___ = 1;(void)t;(void)x;
# 704
::exit(___);}
#if 0
# 700
{ 
# 701
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 703
return make_uint2(v.x, v.y); 
# 704
} 
#endif
# 706 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1D(texture< int4, 1, cudaReadModeElementType>  t, float x) 
# 707
{int volatile ___ = 1;(void)t;(void)x;
# 711
::exit(___);}
#if 0
# 707
{ 
# 708
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 710
return make_int4(v.x, v.y, v.z, v.w); 
# 711
} 
#endif
# 713 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1D(texture< uint4, 1, cudaReadModeElementType>  t, float x) 
# 714
{int volatile ___ = 1;(void)t;(void)x;
# 718
::exit(___);}
#if 0
# 714
{ 
# 715
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 717
return make_uint4(v.x, v.y, v.z, v.w); 
# 718
} 
#endif
# 798 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< float, 1, cudaReadModeElementType>  t, float x) 
# 799
{int volatile ___ = 1;(void)t;(void)x;
# 803
::exit(___);}
#if 0
# 799
{ 
# 800
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
# 802
return v.x; 
# 803
} 
#endif
# 805 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1D(texture< float1, 1, cudaReadModeElementType>  t, float x) 
# 806
{int volatile ___ = 1;(void)t;(void)x;
# 810
::exit(___);}
#if 0
# 806
{ 
# 807
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
# 809
return make_float1(v.x); 
# 810
} 
#endif
# 812 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1D(texture< float2, 1, cudaReadModeElementType>  t, float x) 
# 813
{int volatile ___ = 1;(void)t;(void)x;
# 817
::exit(___);}
#if 0
# 813
{ 
# 814
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
# 816
return make_float2(v.x, v.y); 
# 817
} 
#endif
# 819 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1D(texture< float4, 1, cudaReadModeElementType>  t, float x) 
# 820
{int volatile ___ = 1;(void)t;(void)x;
# 824
::exit(___);}
#if 0
# 820
{ 
# 821
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
# 823
return make_float4(v.x, v.y, v.z, v.w); 
# 824
} 
#endif
# 832 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 833
{int volatile ___ = 1;(void)t;(void)x;
# 842
::exit(___);}
#if 0
# 833
{ 
# 837
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 839
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 841
return w.x; 
# 842
} 
#endif
# 844 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 845
{int volatile ___ = 1;(void)t;(void)x;
# 850
::exit(___);}
#if 0
# 845
{ 
# 846
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 847
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 849
return w.x; 
# 850
} 
#endif
# 852 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 853
{int volatile ___ = 1;(void)t;(void)x;
# 858
::exit(___);}
#if 0
# 853
{ 
# 854
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 855
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 857
return w.x; 
# 858
} 
#endif
# 860 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1D(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 861
{int volatile ___ = 1;(void)t;(void)x;
# 866
::exit(___);}
#if 0
# 861
{ 
# 862
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 863
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 865
return make_float1(w.x); 
# 866
} 
#endif
# 868 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1D(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 869
{int volatile ___ = 1;(void)t;(void)x;
# 874
::exit(___);}
#if 0
# 869
{ 
# 870
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 871
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 873
return make_float1(w.x); 
# 874
} 
#endif
# 876 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1D(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 877
{int volatile ___ = 1;(void)t;(void)x;
# 882
::exit(___);}
#if 0
# 877
{ 
# 878
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 879
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 881
return make_float2(w.x, w.y); 
# 882
} 
#endif
# 884 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1D(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 885
{int volatile ___ = 1;(void)t;(void)x;
# 890
::exit(___);}
#if 0
# 885
{ 
# 886
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 887
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 889
return make_float2(w.x, w.y); 
# 890
} 
#endif
# 892 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1D(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 893
{int volatile ___ = 1;(void)t;(void)x;
# 898
::exit(___);}
#if 0
# 893
{ 
# 894
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 895
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 897
return make_float4(w.x, w.y, w.z, w.w); 
# 898
} 
#endif
# 900 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1D(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 901
{int volatile ___ = 1;(void)t;(void)x;
# 906
::exit(___);}
#if 0
# 901
{ 
# 902
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 903
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 905
return make_float4(w.x, w.y, w.z, w.w); 
# 906
} 
#endif
# 914 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 915
{int volatile ___ = 1;(void)t;(void)x;
# 920
::exit(___);}
#if 0
# 915
{ 
# 916
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 917
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 919
return w.x; 
# 920
} 
#endif
# 922 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 923
{int volatile ___ = 1;(void)t;(void)x;
# 928
::exit(___);}
#if 0
# 923
{ 
# 924
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 925
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 927
return w.x; 
# 928
} 
#endif
# 930 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1D(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 931
{int volatile ___ = 1;(void)t;(void)x;
# 936
::exit(___);}
#if 0
# 931
{ 
# 932
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 933
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 935
return make_float1(w.x); 
# 936
} 
#endif
# 938 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1D(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 939
{int volatile ___ = 1;(void)t;(void)x;
# 944
::exit(___);}
#if 0
# 939
{ 
# 940
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 941
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 943
return make_float1(w.x); 
# 944
} 
#endif
# 946 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1D(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 947
{int volatile ___ = 1;(void)t;(void)x;
# 952
::exit(___);}
#if 0
# 947
{ 
# 948
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 949
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 951
return make_float2(w.x, w.y); 
# 952
} 
#endif
# 954 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1D(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 955
{int volatile ___ = 1;(void)t;(void)x;
# 960
::exit(___);}
#if 0
# 955
{ 
# 956
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 957
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 959
return make_float2(w.x, w.y); 
# 960
} 
#endif
# 962 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1D(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 963
{int volatile ___ = 1;(void)t;(void)x;
# 968
::exit(___);}
#if 0
# 963
{ 
# 964
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 965
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 967
return make_float4(w.x, w.y, w.z, w.w); 
# 968
} 
#endif
# 970 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1D(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 971
{int volatile ___ = 1;(void)t;(void)x;
# 976
::exit(___);}
#if 0
# 971
{ 
# 972
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 973
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 975
return make_float4(w.x, w.y, w.z, w.w); 
# 976
} 
#endif
# 984 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex2D(texture< char, 2, cudaReadModeElementType>  t, float x, float y) 
# 985
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 993
::exit(___);}
#if 0
# 985
{ 
# 989
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 992
return (char)(v.x); 
# 993
} 
#endif
# 995 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2D(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y) 
# 996
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1000
::exit(___);}
#if 0
# 996
{ 
# 997
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 999
return (signed char)(v.x); 
# 1000
} 
#endif
# 1002 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2D(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y) 
# 1003
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1007
::exit(___);}
#if 0
# 1003
{ 
# 1004
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1006
return (unsigned char)(v.x); 
# 1007
} 
#endif
# 1009 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2D(texture< char1, 2, cudaReadModeElementType>  t, float x, float y) 
# 1010
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1014
::exit(___);}
#if 0
# 1010
{ 
# 1011
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1013
return make_char1(v.x); 
# 1014
} 
#endif
# 1016 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2D(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y) 
# 1017
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1021
::exit(___);}
#if 0
# 1017
{ 
# 1018
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1020
return make_uchar1(v.x); 
# 1021
} 
#endif
# 1023 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2D(texture< char2, 2, cudaReadModeElementType>  t, float x, float y) 
# 1024
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1028
::exit(___);}
#if 0
# 1024
{ 
# 1025
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1027
return make_char2(v.x, v.y); 
# 1028
} 
#endif
# 1030 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2D(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y) 
# 1031
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1035
::exit(___);}
#if 0
# 1031
{ 
# 1032
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1034
return make_uchar2(v.x, v.y); 
# 1035
} 
#endif
# 1037 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2D(texture< char4, 2, cudaReadModeElementType>  t, float x, float y) 
# 1038
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1042
::exit(___);}
#if 0
# 1038
{ 
# 1039
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1041
return make_char4(v.x, v.y, v.z, v.w); 
# 1042
} 
#endif
# 1044 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2D(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y) 
# 1045
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1049
::exit(___);}
#if 0
# 1045
{ 
# 1046
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1048
return make_uchar4(v.x, v.y, v.z, v.w); 
# 1049
} 
#endif
# 1057 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex2D(texture< short, 2, cudaReadModeElementType>  t, float x, float y) 
# 1058
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1062
::exit(___);}
#if 0
# 1058
{ 
# 1059
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1061
return (short)(v.x); 
# 1062
} 
#endif
# 1064 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2D(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y) 
# 1065
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1069
::exit(___);}
#if 0
# 1065
{ 
# 1066
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1068
return (unsigned short)(v.x); 
# 1069
} 
#endif
# 1071 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2D(texture< short1, 2, cudaReadModeElementType>  t, float x, float y) 
# 1072
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1076
::exit(___);}
#if 0
# 1072
{ 
# 1073
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1075
return make_short1(v.x); 
# 1076
} 
#endif
# 1078 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2D(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y) 
# 1079
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1083
::exit(___);}
#if 0
# 1079
{ 
# 1080
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1082
return make_ushort1(v.x); 
# 1083
} 
#endif
# 1085 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2D(texture< short2, 2, cudaReadModeElementType>  t, float x, float y) 
# 1086
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1090
::exit(___);}
#if 0
# 1086
{ 
# 1087
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1089
return make_short2(v.x, v.y); 
# 1090
} 
#endif
# 1092 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2D(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y) 
# 1093
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1097
::exit(___);}
#if 0
# 1093
{ 
# 1094
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1096
return make_ushort2(v.x, v.y); 
# 1097
} 
#endif
# 1099 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2D(texture< short4, 2, cudaReadModeElementType>  t, float x, float y) 
# 1100
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1104
::exit(___);}
#if 0
# 1100
{ 
# 1101
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1103
return make_short4(v.x, v.y, v.z, v.w); 
# 1104
} 
#endif
# 1106 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2D(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y) 
# 1107
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1111
::exit(___);}
#if 0
# 1107
{ 
# 1108
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1110
return make_ushort4(v.x, v.y, v.z, v.w); 
# 1111
} 
#endif
# 1119 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex2D(texture< int, 2, cudaReadModeElementType>  t, float x, float y) 
# 1120
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1124
::exit(___);}
#if 0
# 1120
{ 
# 1121
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1123
return (int)(v.x); 
# 1124
} 
#endif
# 1126 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2D(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y) 
# 1127
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1131
::exit(___);}
#if 0
# 1127
{ 
# 1128
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1130
return (unsigned)(v.x); 
# 1131
} 
#endif
# 1133 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2D(texture< int1, 2, cudaReadModeElementType>  t, float x, float y) 
# 1134
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1138
::exit(___);}
#if 0
# 1134
{ 
# 1135
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1137
return make_int1(v.x); 
# 1138
} 
#endif
# 1140 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2D(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y) 
# 1141
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1145
::exit(___);}
#if 0
# 1141
{ 
# 1142
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1144
return make_uint1(v.x); 
# 1145
} 
#endif
# 1147 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2D(texture< int2, 2, cudaReadModeElementType>  t, float x, float y) 
# 1148
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1152
::exit(___);}
#if 0
# 1148
{ 
# 1149
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1151
return make_int2(v.x, v.y); 
# 1152
} 
#endif
# 1154 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2D(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y) 
# 1155
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1159
::exit(___);}
#if 0
# 1155
{ 
# 1156
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1158
return make_uint2(v.x, v.y); 
# 1159
} 
#endif
# 1161 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2D(texture< int4, 2, cudaReadModeElementType>  t, float x, float y) 
# 1162
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1166
::exit(___);}
#if 0
# 1162
{ 
# 1163
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1165
return make_int4(v.x, v.y, v.z, v.w); 
# 1166
} 
#endif
# 1168 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2D(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y) 
# 1169
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1173
::exit(___);}
#if 0
# 1169
{ 
# 1170
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1172
return make_uint4(v.x, v.y, v.z, v.w); 
# 1173
} 
#endif
# 1247 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< float, 2, cudaReadModeElementType>  t, float x, float y) 
# 1248
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1252
::exit(___);}
#if 0
# 1248
{ 
# 1249
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
# 1251
return v.x; 
# 1252
} 
#endif
# 1254 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2D(texture< float1, 2, cudaReadModeElementType>  t, float x, float y) 
# 1255
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1259
::exit(___);}
#if 0
# 1255
{ 
# 1256
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
# 1258
return make_float1(v.x); 
# 1259
} 
#endif
# 1261 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2D(texture< float2, 2, cudaReadModeElementType>  t, float x, float y) 
# 1262
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1266
::exit(___);}
#if 0
# 1262
{ 
# 1263
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
# 1265
return make_float2(v.x, v.y); 
# 1266
} 
#endif
# 1268 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2D(texture< float4, 2, cudaReadModeElementType>  t, float x, float y) 
# 1269
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1273
::exit(___);}
#if 0
# 1269
{ 
# 1270
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
# 1272
return make_float4(v.x, v.y, v.z, v.w); 
# 1273
} 
#endif
# 1281 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1282
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1291
::exit(___);}
#if 0
# 1282
{ 
# 1286
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1288
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1290
return w.x; 
# 1291
} 
#endif
# 1293 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1294
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1299
::exit(___);}
#if 0
# 1294
{ 
# 1295
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1296
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1298
return w.x; 
# 1299
} 
#endif
# 1301 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1302
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1307
::exit(___);}
#if 0
# 1302
{ 
# 1303
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1304
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1306
return w.x; 
# 1307
} 
#endif
# 1309 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2D(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1310
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1315
::exit(___);}
#if 0
# 1310
{ 
# 1311
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1312
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1314
return make_float1(w.x); 
# 1315
} 
#endif
# 1317 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2D(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1318
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1323
::exit(___);}
#if 0
# 1318
{ 
# 1319
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1320
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1322
return make_float1(w.x); 
# 1323
} 
#endif
# 1325 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2D(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1326
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1331
::exit(___);}
#if 0
# 1326
{ 
# 1327
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1328
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1330
return make_float2(w.x, w.y); 
# 1331
} 
#endif
# 1333 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2D(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1334
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1339
::exit(___);}
#if 0
# 1334
{ 
# 1335
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1336
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1338
return make_float2(w.x, w.y); 
# 1339
} 
#endif
# 1341 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2D(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1342
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1347
::exit(___);}
#if 0
# 1342
{ 
# 1343
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1344
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1346
return make_float4(w.x, w.y, w.z, w.w); 
# 1347
} 
#endif
# 1349 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2D(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1350
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1355
::exit(___);}
#if 0
# 1350
{ 
# 1351
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1352
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1354
return make_float4(w.x, w.y, w.z, w.w); 
# 1355
} 
#endif
# 1363 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1364
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1369
::exit(___);}
#if 0
# 1364
{ 
# 1365
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1366
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1368
return w.x; 
# 1369
} 
#endif
# 1371 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1372
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1377
::exit(___);}
#if 0
# 1372
{ 
# 1373
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1374
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1376
return w.x; 
# 1377
} 
#endif
# 1379 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2D(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1380
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1385
::exit(___);}
#if 0
# 1380
{ 
# 1381
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1382
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1384
return make_float1(w.x); 
# 1385
} 
#endif
# 1387 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2D(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1388
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1393
::exit(___);}
#if 0
# 1388
{ 
# 1389
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1390
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1392
return make_float1(w.x); 
# 1393
} 
#endif
# 1395 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2D(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1396
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1401
::exit(___);}
#if 0
# 1396
{ 
# 1397
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1398
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1400
return make_float2(w.x, w.y); 
# 1401
} 
#endif
# 1403 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2D(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1404
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1409
::exit(___);}
#if 0
# 1404
{ 
# 1405
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1406
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1408
return make_float2(w.x, w.y); 
# 1409
} 
#endif
# 1411 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2D(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1412
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1417
::exit(___);}
#if 0
# 1412
{ 
# 1413
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1414
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1416
return make_float4(w.x, w.y, w.z, w.w); 
# 1417
} 
#endif
# 1419 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2D(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1420
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1425
::exit(___);}
#if 0
# 1420
{ 
# 1421
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1422
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1424
return make_float4(w.x, w.y, w.z, w.w); 
# 1425
} 
#endif
# 1433 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex1DLayered(texture< char, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1434
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1442
::exit(___);}
#if 0
# 1434
{ 
# 1438
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1441
return (char)(v.x); 
# 1442
} 
#endif
# 1444 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1DLayered(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1445
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1449
::exit(___);}
#if 0
# 1445
{ 
# 1446
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1448
return (signed char)(v.x); 
# 1449
} 
#endif
# 1451 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1DLayered(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1452
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1456
::exit(___);}
#if 0
# 1452
{ 
# 1453
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1455
return (unsigned char)(v.x); 
# 1456
} 
#endif
# 1458 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1DLayered(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1459
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1463
::exit(___);}
#if 0
# 1459
{ 
# 1460
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1462
return make_char1(v.x); 
# 1463
} 
#endif
# 1465 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1DLayered(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1466
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1470
::exit(___);}
#if 0
# 1466
{ 
# 1467
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1469
return make_uchar1(v.x); 
# 1470
} 
#endif
# 1472 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1DLayered(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1473
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1477
::exit(___);}
#if 0
# 1473
{ 
# 1474
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1476
return make_char2(v.x, v.y); 
# 1477
} 
#endif
# 1479 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1DLayered(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1480
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1484
::exit(___);}
#if 0
# 1480
{ 
# 1481
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1483
return make_uchar2(v.x, v.y); 
# 1484
} 
#endif
# 1486 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1DLayered(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1487
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1491
::exit(___);}
#if 0
# 1487
{ 
# 1488
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1490
return make_char4(v.x, v.y, v.z, v.w); 
# 1491
} 
#endif
# 1493 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1DLayered(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1494
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1498
::exit(___);}
#if 0
# 1494
{ 
# 1495
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1497
return make_uchar4(v.x, v.y, v.z, v.w); 
# 1498
} 
#endif
# 1506 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex1DLayered(texture< short, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1507
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1511
::exit(___);}
#if 0
# 1507
{ 
# 1508
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1510
return (short)(v.x); 
# 1511
} 
#endif
# 1513 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1DLayered(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1514
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1518
::exit(___);}
#if 0
# 1514
{ 
# 1515
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1517
return (unsigned short)(v.x); 
# 1518
} 
#endif
# 1520 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1DLayered(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1521
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1525
::exit(___);}
#if 0
# 1521
{ 
# 1522
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1524
return make_short1(v.x); 
# 1525
} 
#endif
# 1527 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1DLayered(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1528
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1532
::exit(___);}
#if 0
# 1528
{ 
# 1529
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1531
return make_ushort1(v.x); 
# 1532
} 
#endif
# 1534 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1DLayered(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1535
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1539
::exit(___);}
#if 0
# 1535
{ 
# 1536
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1538
return make_short2(v.x, v.y); 
# 1539
} 
#endif
# 1541 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1DLayered(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1542
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1546
::exit(___);}
#if 0
# 1542
{ 
# 1543
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1545
return make_ushort2(v.x, v.y); 
# 1546
} 
#endif
# 1548 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1DLayered(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1549
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1553
::exit(___);}
#if 0
# 1549
{ 
# 1550
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1552
return make_short4(v.x, v.y, v.z, v.w); 
# 1553
} 
#endif
# 1555 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1DLayered(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1556
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1560
::exit(___);}
#if 0
# 1556
{ 
# 1557
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1559
return make_ushort4(v.x, v.y, v.z, v.w); 
# 1560
} 
#endif
# 1568 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex1DLayered(texture< int, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1569
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1573
::exit(___);}
#if 0
# 1569
{ 
# 1570
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1572
return (int)(v.x); 
# 1573
} 
#endif
# 1575 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1DLayered(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1576
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1580
::exit(___);}
#if 0
# 1576
{ 
# 1577
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1579
return (unsigned)(v.x); 
# 1580
} 
#endif
# 1582 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1DLayered(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1583
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1587
::exit(___);}
#if 0
# 1583
{ 
# 1584
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1586
return make_int1(v.x); 
# 1587
} 
#endif
# 1589 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1DLayered(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1590
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1594
::exit(___);}
#if 0
# 1590
{ 
# 1591
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1593
return make_uint1(v.x); 
# 1594
} 
#endif
# 1596 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1DLayered(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1597
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1601
::exit(___);}
#if 0
# 1597
{ 
# 1598
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1600
return make_int2(v.x, v.y); 
# 1601
} 
#endif
# 1603 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1DLayered(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1604
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1608
::exit(___);}
#if 0
# 1604
{ 
# 1605
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1607
return make_uint2(v.x, v.y); 
# 1608
} 
#endif
# 1610 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1DLayered(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1611
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1615
::exit(___);}
#if 0
# 1611
{ 
# 1612
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1614
return make_int4(v.x, v.y, v.z, v.w); 
# 1615
} 
#endif
# 1617 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1DLayered(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1618
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1622
::exit(___);}
#if 0
# 1618
{ 
# 1619
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1621
return make_uint4(v.x, v.y, v.z, v.w); 
# 1622
} 
#endif
# 1696 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< float, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1697
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1701
::exit(___);}
#if 0
# 1697
{ 
# 1698
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1700
return v.x; 
# 1701
} 
#endif
# 1703 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayered(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1704
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1708
::exit(___);}
#if 0
# 1704
{ 
# 1705
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1707
return make_float1(v.x); 
# 1708
} 
#endif
# 1710 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayered(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1711
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1715
::exit(___);}
#if 0
# 1711
{ 
# 1712
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1714
return make_float2(v.x, v.y); 
# 1715
} 
#endif
# 1717 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayered(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1718
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1722
::exit(___);}
#if 0
# 1718
{ 
# 1719
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1721
return make_float4(v.x, v.y, v.z, v.w); 
# 1722
} 
#endif
# 1730 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1731
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1740
::exit(___);}
#if 0
# 1731
{ 
# 1735
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1737
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1739
return w.x; 
# 1740
} 
#endif
# 1742 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1743
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1748
::exit(___);}
#if 0
# 1743
{ 
# 1744
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1745
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1747
return w.x; 
# 1748
} 
#endif
# 1750 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1751
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1756
::exit(___);}
#if 0
# 1751
{ 
# 1752
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1753
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1755
return w.x; 
# 1756
} 
#endif
# 1758 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayered(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1759
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1764
::exit(___);}
#if 0
# 1759
{ 
# 1760
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1761
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1763
return make_float1(w.x); 
# 1764
} 
#endif
# 1766 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayered(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1767
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1772
::exit(___);}
#if 0
# 1767
{ 
# 1768
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1769
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1771
return make_float1(w.x); 
# 1772
} 
#endif
# 1774 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayered(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1775
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1780
::exit(___);}
#if 0
# 1775
{ 
# 1776
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1777
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1779
return make_float2(w.x, w.y); 
# 1780
} 
#endif
# 1782 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayered(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1783
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1788
::exit(___);}
#if 0
# 1783
{ 
# 1784
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1785
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1787
return make_float2(w.x, w.y); 
# 1788
} 
#endif
# 1790 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayered(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1791
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1796
::exit(___);}
#if 0
# 1791
{ 
# 1792
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1793
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1795
return make_float4(w.x, w.y, w.z, w.w); 
# 1796
} 
#endif
# 1798 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayered(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1799
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1804
::exit(___);}
#if 0
# 1799
{ 
# 1800
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1801
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1803
return make_float4(w.x, w.y, w.z, w.w); 
# 1804
} 
#endif
# 1812 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1813
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1818
::exit(___);}
#if 0
# 1813
{ 
# 1814
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1815
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1817
return w.x; 
# 1818
} 
#endif
# 1820 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1821
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1826
::exit(___);}
#if 0
# 1821
{ 
# 1822
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1823
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1825
return w.x; 
# 1826
} 
#endif
# 1828 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayered(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1829
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1834
::exit(___);}
#if 0
# 1829
{ 
# 1830
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1831
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1833
return make_float1(w.x); 
# 1834
} 
#endif
# 1836 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayered(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1837
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1842
::exit(___);}
#if 0
# 1837
{ 
# 1838
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1839
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1841
return make_float1(w.x); 
# 1842
} 
#endif
# 1844 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayered(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1845
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1850
::exit(___);}
#if 0
# 1845
{ 
# 1846
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1847
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1849
return make_float2(w.x, w.y); 
# 1850
} 
#endif
# 1852 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayered(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1853
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1858
::exit(___);}
#if 0
# 1853
{ 
# 1854
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1855
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1857
return make_float2(w.x, w.y); 
# 1858
} 
#endif
# 1860 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayered(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1861
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1866
::exit(___);}
#if 0
# 1861
{ 
# 1862
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1863
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1865
return make_float4(w.x, w.y, w.z, w.w); 
# 1866
} 
#endif
# 1868 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayered(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1869
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1874
::exit(___);}
#if 0
# 1869
{ 
# 1870
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1871
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1873
return make_float4(w.x, w.y, w.z, w.w); 
# 1874
} 
#endif
# 1882 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex2DLayered(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1883
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1891
::exit(___);}
#if 0
# 1883
{ 
# 1887
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1890
return (char)(v.x); 
# 1891
} 
#endif
# 1893 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2DLayered(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1894
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1898
::exit(___);}
#if 0
# 1894
{ 
# 1895
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1897
return (signed char)(v.x); 
# 1898
} 
#endif
# 1900 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2DLayered(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1901
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1905
::exit(___);}
#if 0
# 1901
{ 
# 1902
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1904
return (unsigned char)(v.x); 
# 1905
} 
#endif
# 1907 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2DLayered(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1908
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1912
::exit(___);}
#if 0
# 1908
{ 
# 1909
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1911
return make_char1(v.x); 
# 1912
} 
#endif
# 1914 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2DLayered(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1915
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1919
::exit(___);}
#if 0
# 1915
{ 
# 1916
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1918
return make_uchar1(v.x); 
# 1919
} 
#endif
# 1921 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2DLayered(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1922
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1926
::exit(___);}
#if 0
# 1922
{ 
# 1923
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1925
return make_char2(v.x, v.y); 
# 1926
} 
#endif
# 1928 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2DLayered(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1929
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1933
::exit(___);}
#if 0
# 1929
{ 
# 1930
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1932
return make_uchar2(v.x, v.y); 
# 1933
} 
#endif
# 1935 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2DLayered(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1936
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1940
::exit(___);}
#if 0
# 1936
{ 
# 1937
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1939
return make_char4(v.x, v.y, v.z, v.w); 
# 1940
} 
#endif
# 1942 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2DLayered(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1943
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1947
::exit(___);}
#if 0
# 1943
{ 
# 1944
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1946
return make_uchar4(v.x, v.y, v.z, v.w); 
# 1947
} 
#endif
# 1955 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex2DLayered(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1956
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1960
::exit(___);}
#if 0
# 1956
{ 
# 1957
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1959
return (short)(v.x); 
# 1960
} 
#endif
# 1962 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2DLayered(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1963
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1967
::exit(___);}
#if 0
# 1963
{ 
# 1964
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1966
return (unsigned short)(v.x); 
# 1967
} 
#endif
# 1969 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2DLayered(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1970
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1974
::exit(___);}
#if 0
# 1970
{ 
# 1971
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1973
return make_short1(v.x); 
# 1974
} 
#endif
# 1976 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2DLayered(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1977
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1981
::exit(___);}
#if 0
# 1977
{ 
# 1978
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1980
return make_ushort1(v.x); 
# 1981
} 
#endif
# 1983 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2DLayered(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1984
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1988
::exit(___);}
#if 0
# 1984
{ 
# 1985
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1987
return make_short2(v.x, v.y); 
# 1988
} 
#endif
# 1990 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2DLayered(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1991
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1995
::exit(___);}
#if 0
# 1991
{ 
# 1992
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1994
return make_ushort2(v.x, v.y); 
# 1995
} 
#endif
# 1997 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2DLayered(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1998
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2002
::exit(___);}
#if 0
# 1998
{ 
# 1999
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2001
return make_short4(v.x, v.y, v.z, v.w); 
# 2002
} 
#endif
# 2004 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2DLayered(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2005
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2009
::exit(___);}
#if 0
# 2005
{ 
# 2006
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2008
return make_ushort4(v.x, v.y, v.z, v.w); 
# 2009
} 
#endif
# 2017 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex2DLayered(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2018
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2022
::exit(___);}
#if 0
# 2018
{ 
# 2019
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2021
return (int)(v.x); 
# 2022
} 
#endif
# 2024 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2DLayered(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2025
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2029
::exit(___);}
#if 0
# 2025
{ 
# 2026
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2028
return (unsigned)(v.x); 
# 2029
} 
#endif
# 2031 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2DLayered(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2032
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2036
::exit(___);}
#if 0
# 2032
{ 
# 2033
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2035
return make_int1(v.x); 
# 2036
} 
#endif
# 2038 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2DLayered(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2039
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2043
::exit(___);}
#if 0
# 2039
{ 
# 2040
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2042
return make_uint1(v.x); 
# 2043
} 
#endif
# 2045 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2DLayered(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2046
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2050
::exit(___);}
#if 0
# 2046
{ 
# 2047
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2049
return make_int2(v.x, v.y); 
# 2050
} 
#endif
# 2052 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2DLayered(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2053
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2057
::exit(___);}
#if 0
# 2053
{ 
# 2054
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2056
return make_uint2(v.x, v.y); 
# 2057
} 
#endif
# 2059 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2DLayered(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2060
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2064
::exit(___);}
#if 0
# 2060
{ 
# 2061
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2063
return make_int4(v.x, v.y, v.z, v.w); 
# 2064
} 
#endif
# 2066 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2DLayered(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2067
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2071
::exit(___);}
#if 0
# 2067
{ 
# 2068
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2070
return make_uint4(v.x, v.y, v.z, v.w); 
# 2071
} 
#endif
# 2145 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2146
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2150
::exit(___);}
#if 0
# 2146
{ 
# 2147
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2149
return v.x; 
# 2150
} 
#endif
# 2152 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayered(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2153
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2157
::exit(___);}
#if 0
# 2153
{ 
# 2154
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2156
return make_float1(v.x); 
# 2157
} 
#endif
# 2159 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayered(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2160
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2164
::exit(___);}
#if 0
# 2160
{ 
# 2161
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2163
return make_float2(v.x, v.y); 
# 2164
} 
#endif
# 2166 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayered(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2167
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2171
::exit(___);}
#if 0
# 2167
{ 
# 2168
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2170
return make_float4(v.x, v.y, v.z, v.w); 
# 2171
} 
#endif
# 2179 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2180
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2189
::exit(___);}
#if 0
# 2180
{ 
# 2184
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2186
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2188
return w.x; 
# 2189
} 
#endif
# 2191 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2192
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2197
::exit(___);}
#if 0
# 2192
{ 
# 2193
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2194
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2196
return w.x; 
# 2197
} 
#endif
# 2199 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2200
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2205
::exit(___);}
#if 0
# 2200
{ 
# 2201
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2202
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2204
return w.x; 
# 2205
} 
#endif
# 2207 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayered(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2208
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2213
::exit(___);}
#if 0
# 2208
{ 
# 2209
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2210
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2212
return make_float1(w.x); 
# 2213
} 
#endif
# 2215 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayered(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2216
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2221
::exit(___);}
#if 0
# 2216
{ 
# 2217
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2218
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2220
return make_float1(w.x); 
# 2221
} 
#endif
# 2223 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayered(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2224
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2229
::exit(___);}
#if 0
# 2224
{ 
# 2225
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2226
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2228
return make_float2(w.x, w.y); 
# 2229
} 
#endif
# 2231 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayered(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2232
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2237
::exit(___);}
#if 0
# 2232
{ 
# 2233
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2234
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2236
return make_float2(w.x, w.y); 
# 2237
} 
#endif
# 2239 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayered(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2240
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2245
::exit(___);}
#if 0
# 2240
{ 
# 2241
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2242
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2244
return make_float4(w.x, w.y, w.z, w.w); 
# 2245
} 
#endif
# 2247 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayered(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2248
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2253
::exit(___);}
#if 0
# 2248
{ 
# 2249
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2250
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2252
return make_float4(w.x, w.y, w.z, w.w); 
# 2253
} 
#endif
# 2261 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2262
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2267
::exit(___);}
#if 0
# 2262
{ 
# 2263
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2264
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2266
return w.x; 
# 2267
} 
#endif
# 2269 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2270
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2275
::exit(___);}
#if 0
# 2270
{ 
# 2271
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2272
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2274
return w.x; 
# 2275
} 
#endif
# 2277 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayered(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2278
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2283
::exit(___);}
#if 0
# 2278
{ 
# 2279
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2280
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2282
return make_float1(w.x); 
# 2283
} 
#endif
# 2285 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayered(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2286
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2291
::exit(___);}
#if 0
# 2286
{ 
# 2287
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2288
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2290
return make_float1(w.x); 
# 2291
} 
#endif
# 2293 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayered(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2294
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2299
::exit(___);}
#if 0
# 2294
{ 
# 2295
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2296
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2298
return make_float2(w.x, w.y); 
# 2299
} 
#endif
# 2301 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayered(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2302
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2307
::exit(___);}
#if 0
# 2302
{ 
# 2303
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2304
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2306
return make_float2(w.x, w.y); 
# 2307
} 
#endif
# 2309 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayered(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2310
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2315
::exit(___);}
#if 0
# 2310
{ 
# 2311
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2312
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2314
return make_float4(w.x, w.y, w.z, w.w); 
# 2315
} 
#endif
# 2317 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayered(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2318
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2323
::exit(___);}
#if 0
# 2318
{ 
# 2319
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2320
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2322
return make_float4(w.x, w.y, w.z, w.w); 
# 2323
} 
#endif
# 2331 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex3D(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2332
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2340
::exit(___);}
#if 0
# 2332
{ 
# 2336
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2339
return (char)(v.x); 
# 2340
} 
#endif
# 2342 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex3D(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2343
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2347
::exit(___);}
#if 0
# 2343
{ 
# 2344
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2346
return (signed char)(v.x); 
# 2347
} 
#endif
# 2349 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex3D(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2350
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2354
::exit(___);}
#if 0
# 2350
{ 
# 2351
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2353
return (unsigned char)(v.x); 
# 2354
} 
#endif
# 2356 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex3D(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2357
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2361
::exit(___);}
#if 0
# 2357
{ 
# 2358
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2360
return make_char1(v.x); 
# 2361
} 
#endif
# 2363 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex3D(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2364
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2368
::exit(___);}
#if 0
# 2364
{ 
# 2365
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2367
return make_uchar1(v.x); 
# 2368
} 
#endif
# 2370 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex3D(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2371
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2375
::exit(___);}
#if 0
# 2371
{ 
# 2372
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2374
return make_char2(v.x, v.y); 
# 2375
} 
#endif
# 2377 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex3D(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2378
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2382
::exit(___);}
#if 0
# 2378
{ 
# 2379
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2381
return make_uchar2(v.x, v.y); 
# 2382
} 
#endif
# 2384 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex3D(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2385
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2389
::exit(___);}
#if 0
# 2385
{ 
# 2386
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2388
return make_char4(v.x, v.y, v.z, v.w); 
# 2389
} 
#endif
# 2391 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex3D(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2392
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2396
::exit(___);}
#if 0
# 2392
{ 
# 2393
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2395
return make_uchar4(v.x, v.y, v.z, v.w); 
# 2396
} 
#endif
# 2404 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex3D(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2405
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2409
::exit(___);}
#if 0
# 2405
{ 
# 2406
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2408
return (short)(v.x); 
# 2409
} 
#endif
# 2411 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex3D(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2412
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2416
::exit(___);}
#if 0
# 2412
{ 
# 2413
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2415
return (unsigned short)(v.x); 
# 2416
} 
#endif
# 2418 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex3D(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2419
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2423
::exit(___);}
#if 0
# 2419
{ 
# 2420
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2422
return make_short1(v.x); 
# 2423
} 
#endif
# 2425 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex3D(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2426
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2430
::exit(___);}
#if 0
# 2426
{ 
# 2427
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2429
return make_ushort1(v.x); 
# 2430
} 
#endif
# 2432 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex3D(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2433
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2437
::exit(___);}
#if 0
# 2433
{ 
# 2434
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2436
return make_short2(v.x, v.y); 
# 2437
} 
#endif
# 2439 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex3D(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2440
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2444
::exit(___);}
#if 0
# 2440
{ 
# 2441
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2443
return make_ushort2(v.x, v.y); 
# 2444
} 
#endif
# 2446 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex3D(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2447
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2451
::exit(___);}
#if 0
# 2447
{ 
# 2448
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2450
return make_short4(v.x, v.y, v.z, v.w); 
# 2451
} 
#endif
# 2453 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex3D(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2454
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2458
::exit(___);}
#if 0
# 2454
{ 
# 2455
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2457
return make_ushort4(v.x, v.y, v.z, v.w); 
# 2458
} 
#endif
# 2466 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex3D(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2467
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2471
::exit(___);}
#if 0
# 2467
{ 
# 2468
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2470
return (int)(v.x); 
# 2471
} 
#endif
# 2473 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex3D(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2474
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2478
::exit(___);}
#if 0
# 2474
{ 
# 2475
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2477
return (unsigned)(v.x); 
# 2478
} 
#endif
# 2480 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex3D(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2481
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2485
::exit(___);}
#if 0
# 2481
{ 
# 2482
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2484
return make_int1(v.x); 
# 2485
} 
#endif
# 2487 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex3D(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2488
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2492
::exit(___);}
#if 0
# 2488
{ 
# 2489
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2491
return make_uint1(v.x); 
# 2492
} 
#endif
# 2494 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex3D(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2495
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2499
::exit(___);}
#if 0
# 2495
{ 
# 2496
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2498
return make_int2(v.x, v.y); 
# 2499
} 
#endif
# 2501 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex3D(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2502
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2506
::exit(___);}
#if 0
# 2502
{ 
# 2503
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2505
return make_uint2(v.x, v.y); 
# 2506
} 
#endif
# 2508 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex3D(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2509
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2513
::exit(___);}
#if 0
# 2509
{ 
# 2510
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2512
return make_int4(v.x, v.y, v.z, v.w); 
# 2513
} 
#endif
# 2515 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex3D(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2516
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2520
::exit(___);}
#if 0
# 2516
{ 
# 2517
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2519
return make_uint4(v.x, v.y, v.z, v.w); 
# 2520
} 
#endif
# 2594 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2595
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2599
::exit(___);}
#if 0
# 2595
{ 
# 2596
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
# 2598
return v.x; 
# 2599
} 
#endif
# 2601 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3D(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2602
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2606
::exit(___);}
#if 0
# 2602
{ 
# 2603
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
# 2605
return make_float1(v.x); 
# 2606
} 
#endif
# 2608 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3D(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2609
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2613
::exit(___);}
#if 0
# 2609
{ 
# 2610
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
# 2612
return make_float2(v.x, v.y); 
# 2613
} 
#endif
# 2615 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3D(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2616
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2620
::exit(___);}
#if 0
# 2616
{ 
# 2617
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
# 2619
return make_float4(v.x, v.y, v.z, v.w); 
# 2620
} 
#endif
# 2628 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2629
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2638
::exit(___);}
#if 0
# 2629
{ 
# 2633
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2635
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2637
return w.x; 
# 2638
} 
#endif
# 2640 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2641
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2646
::exit(___);}
#if 0
# 2641
{ 
# 2642
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2643
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2645
return w.x; 
# 2646
} 
#endif
# 2648 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2649
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2654
::exit(___);}
#if 0
# 2649
{ 
# 2650
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2651
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2653
return w.x; 
# 2654
} 
#endif
# 2656 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3D(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2657
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2662
::exit(___);}
#if 0
# 2657
{ 
# 2658
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2659
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2661
return make_float1(w.x); 
# 2662
} 
#endif
# 2664 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3D(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2665
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2670
::exit(___);}
#if 0
# 2665
{ 
# 2666
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2667
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2669
return make_float1(w.x); 
# 2670
} 
#endif
# 2672 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3D(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2673
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2678
::exit(___);}
#if 0
# 2673
{ 
# 2674
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2675
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2677
return make_float2(w.x, w.y); 
# 2678
} 
#endif
# 2680 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3D(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2686
::exit(___);}
#if 0
# 2681
{ 
# 2682
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2683
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2685
return make_float2(w.x, w.y); 
# 2686
} 
#endif
# 2688 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3D(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2689
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2694
::exit(___);}
#if 0
# 2689
{ 
# 2690
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2691
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2693
return make_float4(w.x, w.y, w.z, w.w); 
# 2694
} 
#endif
# 2696 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3D(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2697
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2702
::exit(___);}
#if 0
# 2697
{ 
# 2698
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2699
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2701
return make_float4(w.x, w.y, w.z, w.w); 
# 2702
} 
#endif
# 2710 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2711
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2716
::exit(___);}
#if 0
# 2711
{ 
# 2712
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2713
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2715
return w.x; 
# 2716
} 
#endif
# 2718 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2719
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2724
::exit(___);}
#if 0
# 2719
{ 
# 2720
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2721
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2723
return w.x; 
# 2724
} 
#endif
# 2726 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3D(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2727
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2732
::exit(___);}
#if 0
# 2727
{ 
# 2728
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2729
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2731
return make_float1(w.x); 
# 2732
} 
#endif
# 2734 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3D(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2735
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2740
::exit(___);}
#if 0
# 2735
{ 
# 2736
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2737
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2739
return make_float1(w.x); 
# 2740
} 
#endif
# 2742 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3D(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2743
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2748
::exit(___);}
#if 0
# 2743
{ 
# 2744
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2745
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2747
return make_float2(w.x, w.y); 
# 2748
} 
#endif
# 2750 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3D(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2751
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2756
::exit(___);}
#if 0
# 2751
{ 
# 2752
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2753
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2755
return make_float2(w.x, w.y); 
# 2756
} 
#endif
# 2758 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3D(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2759
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2764
::exit(___);}
#if 0
# 2759
{ 
# 2760
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2761
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2763
return make_float4(w.x, w.y, w.z, w.w); 
# 2764
} 
#endif
# 2766 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3D(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2767
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2772
::exit(___);}
#if 0
# 2767
{ 
# 2768
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2769
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2771
return make_float4(w.x, w.y, w.z, w.w); 
# 2772
} 
#endif
# 2780 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char texCubemap(texture< char, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2781
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2789
::exit(___);}
#if 0
# 2781
{ 
# 2785
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2788
return (char)(v.x); 
# 2789
} 
#endif
# 2791 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char texCubemap(texture< signed char, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2792
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2796
::exit(___);}
#if 0
# 2792
{ 
# 2793
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2795
return (signed char)(v.x); 
# 2796
} 
#endif
# 2798 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char texCubemap(texture< unsigned char, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2799
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2803
::exit(___);}
#if 0
# 2799
{ 
# 2800
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2802
return (unsigned char)(v.x); 
# 2803
} 
#endif
# 2805 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 texCubemap(texture< char1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2806
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2810
::exit(___);}
#if 0
# 2806
{ 
# 2807
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2809
return make_char1(v.x); 
# 2810
} 
#endif
# 2812 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 texCubemap(texture< uchar1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2813
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2817
::exit(___);}
#if 0
# 2813
{ 
# 2814
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2816
return make_uchar1(v.x); 
# 2817
} 
#endif
# 2819 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 texCubemap(texture< char2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2820
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2824
::exit(___);}
#if 0
# 2820
{ 
# 2821
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2823
return make_char2(v.x, v.y); 
# 2824
} 
#endif
# 2826 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 texCubemap(texture< uchar2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2827
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2831
::exit(___);}
#if 0
# 2827
{ 
# 2828
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2830
return make_uchar2(v.x, v.y); 
# 2831
} 
#endif
# 2833 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 texCubemap(texture< char4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2834
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2838
::exit(___);}
#if 0
# 2834
{ 
# 2835
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2837
return make_char4(v.x, v.y, v.z, v.w); 
# 2838
} 
#endif
# 2840 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 texCubemap(texture< uchar4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2841
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2845
::exit(___);}
#if 0
# 2841
{ 
# 2842
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2844
return make_uchar4(v.x, v.y, v.z, v.w); 
# 2845
} 
#endif
# 2853 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short texCubemap(texture< short, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2854
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2858
::exit(___);}
#if 0
# 2854
{ 
# 2855
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2857
return (short)(v.x); 
# 2858
} 
#endif
# 2860 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short texCubemap(texture< unsigned short, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2861
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2865
::exit(___);}
#if 0
# 2861
{ 
# 2862
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2864
return (unsigned short)(v.x); 
# 2865
} 
#endif
# 2867 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 texCubemap(texture< short1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2868
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2872
::exit(___);}
#if 0
# 2868
{ 
# 2869
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2871
return make_short1(v.x); 
# 2872
} 
#endif
# 2874 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 texCubemap(texture< ushort1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2875
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2879
::exit(___);}
#if 0
# 2875
{ 
# 2876
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2878
return make_ushort1(v.x); 
# 2879
} 
#endif
# 2881 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 texCubemap(texture< short2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2882
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2886
::exit(___);}
#if 0
# 2882
{ 
# 2883
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2885
return make_short2(v.x, v.y); 
# 2886
} 
#endif
# 2888 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 texCubemap(texture< ushort2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2889
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2893
::exit(___);}
#if 0
# 2889
{ 
# 2890
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2892
return make_ushort2(v.x, v.y); 
# 2893
} 
#endif
# 2895 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 texCubemap(texture< short4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2896
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2900
::exit(___);}
#if 0
# 2896
{ 
# 2897
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2899
return make_short4(v.x, v.y, v.z, v.w); 
# 2900
} 
#endif
# 2902 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 texCubemap(texture< ushort4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2903
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2907
::exit(___);}
#if 0
# 2903
{ 
# 2904
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2906
return make_ushort4(v.x, v.y, v.z, v.w); 
# 2907
} 
#endif
# 2915 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int texCubemap(texture< int, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2916
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2920
::exit(___);}
#if 0
# 2916
{ 
# 2917
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2919
return (int)(v.x); 
# 2920
} 
#endif
# 2922 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned texCubemap(texture< unsigned, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2923
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2927
::exit(___);}
#if 0
# 2923
{ 
# 2924
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2926
return (unsigned)(v.x); 
# 2927
} 
#endif
# 2929 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 texCubemap(texture< int1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2930
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2934
::exit(___);}
#if 0
# 2930
{ 
# 2931
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2933
return make_int1(v.x); 
# 2934
} 
#endif
# 2936 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 texCubemap(texture< uint1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2937
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2941
::exit(___);}
#if 0
# 2937
{ 
# 2938
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2940
return make_uint1(v.x); 
# 2941
} 
#endif
# 2943 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 texCubemap(texture< int2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2944
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2948
::exit(___);}
#if 0
# 2944
{ 
# 2945
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2947
return make_int2(v.x, v.y); 
# 2948
} 
#endif
# 2950 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 texCubemap(texture< uint2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2951
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2955
::exit(___);}
#if 0
# 2951
{ 
# 2952
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2954
return make_uint2(v.x, v.y); 
# 2955
} 
#endif
# 2957 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 texCubemap(texture< int4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2958
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2962
::exit(___);}
#if 0
# 2958
{ 
# 2959
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2961
return make_int4(v.x, v.y, v.z, v.w); 
# 2962
} 
#endif
# 2964 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 texCubemap(texture< uint4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2965
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2969
::exit(___);}
#if 0
# 2965
{ 
# 2966
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2968
return make_uint4(v.x, v.y, v.z, v.w); 
# 2969
} 
#endif
# 3043 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< float, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 3044
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3048
::exit(___);}
#if 0
# 3044
{ 
# 3045
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
# 3047
return v.x; 
# 3048
} 
#endif
# 3050 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemap(texture< float1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 3051
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3055
::exit(___);}
#if 0
# 3051
{ 
# 3052
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
# 3054
return make_float1(v.x); 
# 3055
} 
#endif
# 3057 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemap(texture< float2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 3058
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3062
::exit(___);}
#if 0
# 3058
{ 
# 3059
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
# 3061
return make_float2(v.x, v.y); 
# 3062
} 
#endif
# 3064 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemap(texture< float4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 3065
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3069
::exit(___);}
#if 0
# 3065
{ 
# 3066
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
# 3068
return make_float4(v.x, v.y, v.z, v.w); 
# 3069
} 
#endif
# 3077 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3078
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3087
::exit(___);}
#if 0
# 3078
{ 
# 3082
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3084
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3086
return w.x; 
# 3087
} 
#endif
# 3089 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< signed char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3090
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3095
::exit(___);}
#if 0
# 3090
{ 
# 3091
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3092
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3094
return w.x; 
# 3095
} 
#endif
# 3097 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< unsigned char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3098
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3103
::exit(___);}
#if 0
# 3098
{ 
# 3099
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3100
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3102
return w.x; 
# 3103
} 
#endif
# 3105 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemap(texture< char1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3106
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3111
::exit(___);}
#if 0
# 3106
{ 
# 3107
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3108
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3110
return make_float1(w.x); 
# 3111
} 
#endif
# 3113 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemap(texture< uchar1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3114
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3119
::exit(___);}
#if 0
# 3114
{ 
# 3115
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3116
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3118
return make_float1(w.x); 
# 3119
} 
#endif
# 3121 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemap(texture< char2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3122
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3127
::exit(___);}
#if 0
# 3122
{ 
# 3123
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3124
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3126
return make_float2(w.x, w.y); 
# 3127
} 
#endif
# 3129 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemap(texture< uchar2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3130
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3135
::exit(___);}
#if 0
# 3130
{ 
# 3131
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3132
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3134
return make_float2(w.x, w.y); 
# 3135
} 
#endif
# 3137 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemap(texture< char4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3138
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3143
::exit(___);}
#if 0
# 3138
{ 
# 3139
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3140
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3142
return make_float4(w.x, w.y, w.z, w.w); 
# 3143
} 
#endif
# 3145 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemap(texture< uchar4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3146
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3151
::exit(___);}
#if 0
# 3146
{ 
# 3147
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3148
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3150
return make_float4(w.x, w.y, w.z, w.w); 
# 3151
} 
#endif
# 3159 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3160
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3165
::exit(___);}
#if 0
# 3160
{ 
# 3161
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3162
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3164
return w.x; 
# 3165
} 
#endif
# 3167 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< unsigned short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3168
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3173
::exit(___);}
#if 0
# 3168
{ 
# 3169
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3170
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3172
return w.x; 
# 3173
} 
#endif
# 3175 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemap(texture< short1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3176
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3181
::exit(___);}
#if 0
# 3176
{ 
# 3177
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3178
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3180
return make_float1(w.x); 
# 3181
} 
#endif
# 3183 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemap(texture< ushort1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3184
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3189
::exit(___);}
#if 0
# 3184
{ 
# 3185
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3186
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3188
return make_float1(w.x); 
# 3189
} 
#endif
# 3191 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemap(texture< short2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3192
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3197
::exit(___);}
#if 0
# 3192
{ 
# 3193
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3194
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3196
return make_float2(w.x, w.y); 
# 3197
} 
#endif
# 3199 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemap(texture< ushort2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3200
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3205
::exit(___);}
#if 0
# 3200
{ 
# 3201
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3202
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3204
return make_float2(w.x, w.y); 
# 3205
} 
#endif
# 3207 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemap(texture< short4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3208
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3213
::exit(___);}
#if 0
# 3208
{ 
# 3209
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3210
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3212
return make_float4(w.x, w.y, w.z, w.w); 
# 3213
} 
#endif
# 3215 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemap(texture< ushort4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3216
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3221
::exit(___);}
#if 0
# 3216
{ 
# 3217
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3218
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3220
return make_float4(w.x, w.y, w.z, w.w); 
# 3221
} 
#endif
# 3229 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char texCubemapLayered(texture< char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3230
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3238
::exit(___);}
#if 0
# 3230
{ 
# 3234
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3237
return (char)(v.x); 
# 3238
} 
#endif
# 3240 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char texCubemapLayered(texture< signed char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3241
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3245
::exit(___);}
#if 0
# 3241
{ 
# 3242
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3244
return (signed char)(v.x); 
# 3245
} 
#endif
# 3247 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char texCubemapLayered(texture< unsigned char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3248
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3252
::exit(___);}
#if 0
# 3248
{ 
# 3249
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3251
return (unsigned char)(v.x); 
# 3252
} 
#endif
# 3254 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 texCubemapLayered(texture< char1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3255
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3259
::exit(___);}
#if 0
# 3255
{ 
# 3256
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3258
return make_char1(v.x); 
# 3259
} 
#endif
# 3261 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 texCubemapLayered(texture< uchar1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3262
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3266
::exit(___);}
#if 0
# 3262
{ 
# 3263
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3265
return make_uchar1(v.x); 
# 3266
} 
#endif
# 3268 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 texCubemapLayered(texture< char2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3269
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3273
::exit(___);}
#if 0
# 3269
{ 
# 3270
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3272
return make_char2(v.x, v.y); 
# 3273
} 
#endif
# 3275 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 texCubemapLayered(texture< uchar2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3276
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3280
::exit(___);}
#if 0
# 3276
{ 
# 3277
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3279
return make_uchar2(v.x, v.y); 
# 3280
} 
#endif
# 3282 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 texCubemapLayered(texture< char4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3283
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3287
::exit(___);}
#if 0
# 3283
{ 
# 3284
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3286
return make_char4(v.x, v.y, v.z, v.w); 
# 3287
} 
#endif
# 3289 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 texCubemapLayered(texture< uchar4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3290
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3294
::exit(___);}
#if 0
# 3290
{ 
# 3291
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3293
return make_uchar4(v.x, v.y, v.z, v.w); 
# 3294
} 
#endif
# 3302 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short texCubemapLayered(texture< short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3303
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3307
::exit(___);}
#if 0
# 3303
{ 
# 3304
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3306
return (short)(v.x); 
# 3307
} 
#endif
# 3309 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short texCubemapLayered(texture< unsigned short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3310
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3314
::exit(___);}
#if 0
# 3310
{ 
# 3311
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3313
return (unsigned short)(v.x); 
# 3314
} 
#endif
# 3316 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 texCubemapLayered(texture< short1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3317
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3321
::exit(___);}
#if 0
# 3317
{ 
# 3318
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3320
return make_short1(v.x); 
# 3321
} 
#endif
# 3323 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 texCubemapLayered(texture< ushort1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3324
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3328
::exit(___);}
#if 0
# 3324
{ 
# 3325
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3327
return make_ushort1(v.x); 
# 3328
} 
#endif
# 3330 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 texCubemapLayered(texture< short2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3331
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3335
::exit(___);}
#if 0
# 3331
{ 
# 3332
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3334
return make_short2(v.x, v.y); 
# 3335
} 
#endif
# 3337 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 texCubemapLayered(texture< ushort2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3338
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3342
::exit(___);}
#if 0
# 3338
{ 
# 3339
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3341
return make_ushort2(v.x, v.y); 
# 3342
} 
#endif
# 3344 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 texCubemapLayered(texture< short4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3345
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3349
::exit(___);}
#if 0
# 3345
{ 
# 3346
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3348
return make_short4(v.x, v.y, v.z, v.w); 
# 3349
} 
#endif
# 3351 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 texCubemapLayered(texture< ushort4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3352
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3356
::exit(___);}
#if 0
# 3352
{ 
# 3353
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3355
return make_ushort4(v.x, v.y, v.z, v.w); 
# 3356
} 
#endif
# 3364 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int texCubemapLayered(texture< int, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3365
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3369
::exit(___);}
#if 0
# 3365
{ 
# 3366
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3368
return (int)(v.x); 
# 3369
} 
#endif
# 3371 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned texCubemapLayered(texture< unsigned, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3372
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3376
::exit(___);}
#if 0
# 3372
{ 
# 3373
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3375
return (unsigned)(v.x); 
# 3376
} 
#endif
# 3378 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 texCubemapLayered(texture< int1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3379
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3383
::exit(___);}
#if 0
# 3379
{ 
# 3380
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3382
return make_int1(v.x); 
# 3383
} 
#endif
# 3385 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 texCubemapLayered(texture< uint1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3386
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3390
::exit(___);}
#if 0
# 3386
{ 
# 3387
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3389
return make_uint1(v.x); 
# 3390
} 
#endif
# 3392 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 texCubemapLayered(texture< int2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3393
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3397
::exit(___);}
#if 0
# 3393
{ 
# 3394
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3396
return make_int2(v.x, v.y); 
# 3397
} 
#endif
# 3399 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 texCubemapLayered(texture< uint2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3400
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3404
::exit(___);}
#if 0
# 3400
{ 
# 3401
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3403
return make_uint2(v.x, v.y); 
# 3404
} 
#endif
# 3406 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 texCubemapLayered(texture< int4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3407
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3411
::exit(___);}
#if 0
# 3407
{ 
# 3408
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3410
return make_int4(v.x, v.y, v.z, v.w); 
# 3411
} 
#endif
# 3413 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 texCubemapLayered(texture< uint4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3414
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3418
::exit(___);}
#if 0
# 3414
{ 
# 3415
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3417
return make_uint4(v.x, v.y, v.z, v.w); 
# 3418
} 
#endif
# 3492 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< float, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3493
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3497
::exit(___);}
#if 0
# 3493
{ 
# 3494
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3496
return v.x; 
# 3497
} 
#endif
# 3499 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayered(texture< float1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3500
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3504
::exit(___);}
#if 0
# 3500
{ 
# 3501
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3503
return make_float1(v.x); 
# 3504
} 
#endif
# 3506 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayered(texture< float2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3507
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3511
::exit(___);}
#if 0
# 3507
{ 
# 3508
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3510
return make_float2(v.x, v.y); 
# 3511
} 
#endif
# 3513 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayered(texture< float4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3514
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3518
::exit(___);}
#if 0
# 3514
{ 
# 3515
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3517
return make_float4(v.x, v.y, v.z, v.w); 
# 3518
} 
#endif
# 3526 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3527
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3536
::exit(___);}
#if 0
# 3527
{ 
# 3531
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3533
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3535
return w.x; 
# 3536
} 
#endif
# 3538 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< signed char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3539
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3544
::exit(___);}
#if 0
# 3539
{ 
# 3540
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3541
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3543
return w.x; 
# 3544
} 
#endif
# 3546 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< unsigned char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3547
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3552
::exit(___);}
#if 0
# 3547
{ 
# 3548
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3549
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3551
return w.x; 
# 3552
} 
#endif
# 3554 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayered(texture< char1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3555
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3560
::exit(___);}
#if 0
# 3555
{ 
# 3556
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3557
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3559
return make_float1(w.x); 
# 3560
} 
#endif
# 3562 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayered(texture< uchar1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3563
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3568
::exit(___);}
#if 0
# 3563
{ 
# 3564
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3565
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3567
return make_float1(w.x); 
# 3568
} 
#endif
# 3570 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayered(texture< char2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3571
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3576
::exit(___);}
#if 0
# 3571
{ 
# 3572
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3573
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3575
return make_float2(w.x, w.y); 
# 3576
} 
#endif
# 3578 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayered(texture< uchar2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3579
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3584
::exit(___);}
#if 0
# 3579
{ 
# 3580
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3581
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3583
return make_float2(w.x, w.y); 
# 3584
} 
#endif
# 3586 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayered(texture< char4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3587
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3592
::exit(___);}
#if 0
# 3587
{ 
# 3588
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3589
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3591
return make_float4(w.x, w.y, w.z, w.w); 
# 3592
} 
#endif
# 3594 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayered(texture< uchar4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3595
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3600
::exit(___);}
#if 0
# 3595
{ 
# 3596
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3597
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3599
return make_float4(w.x, w.y, w.z, w.w); 
# 3600
} 
#endif
# 3608 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3609
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3614
::exit(___);}
#if 0
# 3609
{ 
# 3610
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3611
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3613
return w.x; 
# 3614
} 
#endif
# 3616 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< unsigned short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3617
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3622
::exit(___);}
#if 0
# 3617
{ 
# 3618
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3619
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3621
return w.x; 
# 3622
} 
#endif
# 3624 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayered(texture< short1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3625
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3630
::exit(___);}
#if 0
# 3625
{ 
# 3626
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3627
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3629
return make_float1(w.x); 
# 3630
} 
#endif
# 3632 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayered(texture< ushort1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3633
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3638
::exit(___);}
#if 0
# 3633
{ 
# 3634
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3635
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3637
return make_float1(w.x); 
# 3638
} 
#endif
# 3640 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayered(texture< short2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3641
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3646
::exit(___);}
#if 0
# 3641
{ 
# 3642
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3643
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3645
return make_float2(w.x, w.y); 
# 3646
} 
#endif
# 3648 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayered(texture< ushort2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3649
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3654
::exit(___);}
#if 0
# 3649
{ 
# 3650
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3651
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3653
return make_float2(w.x, w.y); 
# 3654
} 
#endif
# 3656 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayered(texture< short4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3657
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3662
::exit(___);}
#if 0
# 3657
{ 
# 3658
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3659
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3661
return make_float4(w.x, w.y, w.z, w.w); 
# 3662
} 
#endif
# 3664 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayered(texture< ushort4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3665
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3670
::exit(___);}
#if 0
# 3665
{ 
# 3666
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3667
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3669
return make_float4(w.x, w.y, w.z, w.w); 
# 3670
} 
#endif
# 3703 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< char, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3704
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3706
::exit(___);}
#if 0
# 3704
{ 
# 3705
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } ; 
# 3706
} 
#endif
# 3708 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3709
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3711
::exit(___);}
#if 0
# 3709
{ 
# 3710
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } ; 
# 3711
} 
#endif
# 3713 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2Dgather(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3714
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3716
::exit(___);}
#if 0
# 3714
{ 
# 3715
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } ; 
# 3716
} 
#endif
# 3718 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3719
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3721
::exit(___);}
#if 0
# 3719
{ 
# 3720
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } ; 
# 3721
} 
#endif
# 3723 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2Dgather(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3724
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3726
::exit(___);}
#if 0
# 3724
{ 
# 3725
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } ; 
# 3726
} 
#endif
# 3728 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3729
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3731
::exit(___);}
#if 0
# 3729
{ 
# 3730
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); }  ; 
# 3731
} 
#endif
# 3733 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2Dgather(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3734
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3736
::exit(___);}
#if 0
# 3734
{ 
# 3735
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); }  ; 
# 3736
} 
#endif
# 3738 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< char3, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3739
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3741
::exit(___);}
#if 0
# 3739
{ 
# 3740
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); }  }  ; 
# 3741
} 
#endif
# 3743 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2Dgather(texture< uchar3, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3744
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3746
::exit(___);}
#if 0
# 3744
{ 
# 3745
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); }  }  ; 
# 3746
} 
#endif
# 3748 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3749
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3751
::exit(___);}
#if 0
# 3749
{ 
# 3750
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); }  }  }  ; 
# 3751
} 
#endif
# 3753 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2Dgather(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3754
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3756
::exit(___);}
#if 0
# 3754
{ 
# 3755
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); }  }  }  ; 
# 3756
} 
#endif
# 3758 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2Dgather(texture< short, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3759
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3761
::exit(___);}
#if 0
# 3759
{ 
# 3760
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } ; 
# 3761
} 
#endif
# 3763 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2Dgather(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3764
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3766
::exit(___);}
#if 0
# 3764
{ 
# 3765
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } ; 
# 3766
} 
#endif
# 3768 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2Dgather(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3769
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3771
::exit(___);}
#if 0
# 3769
{ 
# 3770
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } ; 
# 3771
} 
#endif
# 3773 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2Dgather(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3774
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3776
::exit(___);}
#if 0
# 3774
{ 
# 3775
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } ; 
# 3776
} 
#endif
# 3778 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2Dgather(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3779
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3781
::exit(___);}
#if 0
# 3779
{ 
# 3780
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); }  ; 
# 3781
} 
#endif
# 3783 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2Dgather(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3784
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3786
::exit(___);}
#if 0
# 3784
{ 
# 3785
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); }  ; 
# 3786
} 
#endif
# 3788 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2Dgather(texture< short3, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3789
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3791
::exit(___);}
#if 0
# 3789
{ 
# 3790
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); }  }  ; 
# 3791
} 
#endif
# 3793 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2Dgather(texture< ushort3, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3794
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3796
::exit(___);}
#if 0
# 3794
{ 
# 3795
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); }  }  ; 
# 3796
} 
#endif
# 3798 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2Dgather(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3799
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3801
::exit(___);}
#if 0
# 3799
{ 
# 3800
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); }  }  }  ; 
# 3801
} 
#endif
# 3803 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2Dgather(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3804
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3806
::exit(___);}
#if 0
# 3804
{ 
# 3805
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); }  }  }  ; 
# 3806
} 
#endif
# 3808 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2Dgather(texture< int, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3809
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3811
::exit(___);}
#if 0
# 3809
{ 
# 3810
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
# 3811
} 
#endif
# 3813 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2Dgather(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3814
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3816
::exit(___);}
#if 0
# 3814
{ 
# 3815
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
# 3816
} 
#endif
# 3818 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2Dgather(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3819
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3821
::exit(___);}
#if 0
# 3819
{ 
# 3820
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
# 3821
} 
#endif
# 3823 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2Dgather(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3824
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3826
::exit(___);}
#if 0
# 3824
{ 
# 3825
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
# 3826
} 
#endif
# 3828 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2Dgather(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3829
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3831
::exit(___);}
#if 0
# 3829
{ 
# 3830
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; }  ; 
# 3831
} 
#endif
# 3833 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2Dgather(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3834
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3836
::exit(___);}
#if 0
# 3834
{ 
# 3835
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; }  ; 
# 3836
} 
#endif
# 3838 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2Dgather(texture< int3, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3839
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3841
::exit(___);}
#if 0
# 3839
{ 
# 3840
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  ; 
# 3841
} 
#endif
# 3843 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2Dgather(texture< uint3, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3844
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3846
::exit(___);}
#if 0
# 3844
{ 
# 3845
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  ; 
# 3846
} 
#endif
# 3848 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2Dgather(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3849
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3851
::exit(___);}
#if 0
# 3849
{ 
# 3850
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return v; } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  }  ; 
# 3851
} 
#endif
# 3853 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2Dgather(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3854
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3856
::exit(___);}
#if 0
# 3854
{ 
# 3855
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return v; } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  }  ; 
# 3856
} 
#endif
# 3858 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< float, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3859
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3861
::exit(___);}
#if 0
# 3859
{ 
# 3860
{ float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
# 3861
} 
#endif
# 3863 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3864
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3866
::exit(___);}
#if 0
# 3864
{ 
# 3865
{ float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
# 3866
} 
#endif
# 3868 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3869
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3871
::exit(___);}
#if 0
# 3869
{ 
# 3870
if (comp == 1) { float4 v = __ftex2Dgather< 1> (t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; }  ; 
# 3871
} 
#endif
# 3873 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< float3, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3874
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3876
::exit(___);}
#if 0
# 3874
{ 
# 3875
if (comp == 2) { float4 v = __ftex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { float4 v = __ftex2Dgather< 1> (t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  ; 
# 3876
} 
#endif
# 3878 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
# 3879
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3881
::exit(___);}
#if 0
# 3879
{ 
# 3880
if (comp == 3) { float4 v = __ftex2Dgather< 3> (t, make_float2(x, y)); return v; } else { if (comp == 2) { float4 v = __ftex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { float4 v = __ftex2Dgather< 1> (t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  }  ; 
# 3881
} 
#endif
# 3890 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3891
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3893
::exit(___);}
#if 0
# 3891
{ 
# 3892
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 3893
} 
#endif
# 3895 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3896
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3898
::exit(___);}
#if 0
# 3896
{ 
# 3897
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 3898
} 
#endif
# 3900 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3901
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3903
::exit(___);}
#if 0
# 3901
{ 
# 3902
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 3903
} 
#endif
# 3905 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3906
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3908
::exit(___);}
#if 0
# 3906
{ 
# 3907
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 3908
} 
#endif
# 3910 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3911
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3913
::exit(___);}
#if 0
# 3911
{ 
# 3912
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 3913
} 
#endif
# 3915 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3916
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3918
::exit(___);}
#if 0
# 3916
{ 
# 3917
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
# 3918
} 
#endif
# 3920 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3921
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3923
::exit(___);}
#if 0
# 3921
{ 
# 3922
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
# 3923
} 
#endif
# 3925 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< char3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3926
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3928
::exit(___);}
#if 0
# 3926
{ 
# 3927
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
# 3928
} 
#endif
# 3930 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< uchar3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3931
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3933
::exit(___);}
#if 0
# 3931
{ 
# 3932
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
# 3933
} 
#endif
# 3935 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3936
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3938
::exit(___);}
#if 0
# 3936
{ 
# 3937
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
# 3938
} 
#endif
# 3940 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3941
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3943
::exit(___);}
#if 0
# 3941
{ 
# 3942
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
# 3943
} 
#endif
# 3945 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3946
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3948
::exit(___);}
#if 0
# 3946
{ 
# 3947
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 3948
} 
#endif
# 3950 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3951
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3953
::exit(___);}
#if 0
# 3951
{ 
# 3952
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 3953
} 
#endif
# 3955 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3956
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3958
::exit(___);}
#if 0
# 3956
{ 
# 3957
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 3958
} 
#endif
# 3960 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3961
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3963
::exit(___);}
#if 0
# 3961
{ 
# 3962
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 3963
} 
#endif
# 3965 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3966
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3968
::exit(___);}
#if 0
# 3966
{ 
# 3967
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
# 3968
} 
#endif
# 3970 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3971
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3973
::exit(___);}
#if 0
# 3971
{ 
# 3972
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
# 3973
} 
#endif
# 3975 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< short3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3976
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3978
::exit(___);}
#if 0
# 3976
{ 
# 3977
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
# 3978
} 
#endif
# 3980 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< ushort3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3981
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3983
::exit(___);}
#if 0
# 3981
{ 
# 3982
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
# 3983
} 
#endif
# 3985 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3986
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3988
::exit(___);}
#if 0
# 3986
{ 
# 3987
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
# 3988
} 
#endif
# 3990 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
# 3991
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3993
::exit(___);}
#if 0
# 3991
{ 
# 3992
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
# 3993
} 
#endif
# 4007 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex1DLod(texture< char, 1, cudaReadModeElementType>  t, float x, float level) 
# 4008
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4016
::exit(___);}
#if 0
# 4008
{ 
# 4012
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4015
return (char)(v.x); 
# 4016
} 
#endif
# 4018 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1DLod(texture< signed char, 1, cudaReadModeElementType>  t, float x, float level) 
# 4019
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4023
::exit(___);}
#if 0
# 4019
{ 
# 4020
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4022
return (signed char)(v.x); 
# 4023
} 
#endif
# 4025 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1DLod(texture< unsigned char, 1, cudaReadModeElementType>  t, float x, float level) 
# 4026
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4030
::exit(___);}
#if 0
# 4026
{ 
# 4027
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4029
return (unsigned char)(v.x); 
# 4030
} 
#endif
# 4032 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1DLod(texture< char1, 1, cudaReadModeElementType>  t, float x, float level) 
# 4033
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4037
::exit(___);}
#if 0
# 4033
{ 
# 4034
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4036
return make_char1(v.x); 
# 4037
} 
#endif
# 4039 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1DLod(texture< uchar1, 1, cudaReadModeElementType>  t, float x, float level) 
# 4040
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4044
::exit(___);}
#if 0
# 4040
{ 
# 4041
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4043
return make_uchar1(v.x); 
# 4044
} 
#endif
# 4046 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1DLod(texture< char2, 1, cudaReadModeElementType>  t, float x, float level) 
# 4047
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4051
::exit(___);}
#if 0
# 4047
{ 
# 4048
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4050
return make_char2(v.x, v.y); 
# 4051
} 
#endif
# 4053 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1DLod(texture< uchar2, 1, cudaReadModeElementType>  t, float x, float level) 
# 4054
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4058
::exit(___);}
#if 0
# 4054
{ 
# 4055
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4057
return make_uchar2(v.x, v.y); 
# 4058
} 
#endif
# 4060 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1DLod(texture< char4, 1, cudaReadModeElementType>  t, float x, float level) 
# 4061
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4065
::exit(___);}
#if 0
# 4061
{ 
# 4062
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4064
return make_char4(v.x, v.y, v.z, v.w); 
# 4065
} 
#endif
# 4067 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1DLod(texture< uchar4, 1, cudaReadModeElementType>  t, float x, float level) 
# 4068
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4072
::exit(___);}
#if 0
# 4068
{ 
# 4069
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4071
return make_uchar4(v.x, v.y, v.z, v.w); 
# 4072
} 
#endif
# 4080 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex1DLod(texture< short, 1, cudaReadModeElementType>  t, float x, float level) 
# 4081
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4085
::exit(___);}
#if 0
# 4081
{ 
# 4082
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4084
return (short)(v.x); 
# 4085
} 
#endif
# 4087 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1DLod(texture< unsigned short, 1, cudaReadModeElementType>  t, float x, float level) 
# 4088
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4092
::exit(___);}
#if 0
# 4088
{ 
# 4089
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4091
return (unsigned short)(v.x); 
# 4092
} 
#endif
# 4094 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1DLod(texture< short1, 1, cudaReadModeElementType>  t, float x, float level) 
# 4095
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4099
::exit(___);}
#if 0
# 4095
{ 
# 4096
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4098
return make_short1(v.x); 
# 4099
} 
#endif
# 4101 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1DLod(texture< ushort1, 1, cudaReadModeElementType>  t, float x, float level) 
# 4102
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4106
::exit(___);}
#if 0
# 4102
{ 
# 4103
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4105
return make_ushort1(v.x); 
# 4106
} 
#endif
# 4108 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1DLod(texture< short2, 1, cudaReadModeElementType>  t, float x, float level) 
# 4109
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4113
::exit(___);}
#if 0
# 4109
{ 
# 4110
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4112
return make_short2(v.x, v.y); 
# 4113
} 
#endif
# 4115 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1DLod(texture< ushort2, 1, cudaReadModeElementType>  t, float x, float level) 
# 4116
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4120
::exit(___);}
#if 0
# 4116
{ 
# 4117
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4119
return make_ushort2(v.x, v.y); 
# 4120
} 
#endif
# 4122 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1DLod(texture< short4, 1, cudaReadModeElementType>  t, float x, float level) 
# 4123
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4127
::exit(___);}
#if 0
# 4123
{ 
# 4124
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4126
return make_short4(v.x, v.y, v.z, v.w); 
# 4127
} 
#endif
# 4129 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1DLod(texture< ushort4, 1, cudaReadModeElementType>  t, float x, float level) 
# 4130
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4134
::exit(___);}
#if 0
# 4130
{ 
# 4131
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4133
return make_ushort4(v.x, v.y, v.z, v.w); 
# 4134
} 
#endif
# 4142 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex1DLod(texture< int, 1, cudaReadModeElementType>  t, float x, float level) 
# 4143
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4147
::exit(___);}
#if 0
# 4143
{ 
# 4144
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4146
return (int)(v.x); 
# 4147
} 
#endif
# 4149 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1DLod(texture< unsigned, 1, cudaReadModeElementType>  t, float x, float level) 
# 4150
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4154
::exit(___);}
#if 0
# 4150
{ 
# 4151
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4153
return (unsigned)(v.x); 
# 4154
} 
#endif
# 4156 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1DLod(texture< int1, 1, cudaReadModeElementType>  t, float x, float level) 
# 4157
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4161
::exit(___);}
#if 0
# 4157
{ 
# 4158
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4160
return make_int1(v.x); 
# 4161
} 
#endif
# 4163 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1DLod(texture< uint1, 1, cudaReadModeElementType>  t, float x, float level) 
# 4164
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4168
::exit(___);}
#if 0
# 4164
{ 
# 4165
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4167
return make_uint1(v.x); 
# 4168
} 
#endif
# 4170 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1DLod(texture< int2, 1, cudaReadModeElementType>  t, float x, float level) 
# 4171
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4175
::exit(___);}
#if 0
# 4171
{ 
# 4172
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4174
return make_int2(v.x, v.y); 
# 4175
} 
#endif
# 4177 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1DLod(texture< uint2, 1, cudaReadModeElementType>  t, float x, float level) 
# 4178
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4182
::exit(___);}
#if 0
# 4178
{ 
# 4179
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4181
return make_uint2(v.x, v.y); 
# 4182
} 
#endif
# 4184 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1DLod(texture< int4, 1, cudaReadModeElementType>  t, float x, float level) 
# 4185
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4189
::exit(___);}
#if 0
# 4185
{ 
# 4186
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4188
return make_int4(v.x, v.y, v.z, v.w); 
# 4189
} 
#endif
# 4191 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1DLod(texture< uint4, 1, cudaReadModeElementType>  t, float x, float level) 
# 4192
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4196
::exit(___);}
#if 0
# 4192
{ 
# 4193
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4195
return make_uint4(v.x, v.y, v.z, v.w); 
# 4196
} 
#endif
# 4276 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< float, 1, cudaReadModeElementType>  t, float x, float level) 
# 4277
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4281
::exit(___);}
#if 0
# 4277
{ 
# 4278
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4280
return v.x; 
# 4281
} 
#endif
# 4283 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLod(texture< float1, 1, cudaReadModeElementType>  t, float x, float level) 
# 4284
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4288
::exit(___);}
#if 0
# 4284
{ 
# 4285
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4287
return make_float1(v.x); 
# 4288
} 
#endif
# 4290 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLod(texture< float2, 1, cudaReadModeElementType>  t, float x, float level) 
# 4291
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4295
::exit(___);}
#if 0
# 4291
{ 
# 4292
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4294
return make_float2(v.x, v.y); 
# 4295
} 
#endif
# 4297 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLod(texture< float4, 1, cudaReadModeElementType>  t, float x, float level) 
# 4298
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4302
::exit(___);}
#if 0
# 4298
{ 
# 4299
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4301
return make_float4(v.x, v.y, v.z, v.w); 
# 4302
} 
#endif
# 4310 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4311
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4320
::exit(___);}
#if 0
# 4311
{ 
# 4315
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4317
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4319
return w.x; 
# 4320
} 
#endif
# 4322 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4323
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4328
::exit(___);}
#if 0
# 4323
{ 
# 4324
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4325
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4327
return w.x; 
# 4328
} 
#endif
# 4330 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4331
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4336
::exit(___);}
#if 0
# 4331
{ 
# 4332
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4333
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4335
return w.x; 
# 4336
} 
#endif
# 4338 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLod(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4339
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4344
::exit(___);}
#if 0
# 4339
{ 
# 4340
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4341
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4343
return make_float1(w.x); 
# 4344
} 
#endif
# 4346 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLod(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4347
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4352
::exit(___);}
#if 0
# 4347
{ 
# 4348
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4349
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4351
return make_float1(w.x); 
# 4352
} 
#endif
# 4354 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLod(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4355
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4360
::exit(___);}
#if 0
# 4355
{ 
# 4356
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4357
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4359
return make_float2(w.x, w.y); 
# 4360
} 
#endif
# 4362 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLod(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4363
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4368
::exit(___);}
#if 0
# 4363
{ 
# 4364
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4365
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4367
return make_float2(w.x, w.y); 
# 4368
} 
#endif
# 4370 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLod(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4371
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4376
::exit(___);}
#if 0
# 4371
{ 
# 4372
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4373
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4375
return make_float4(w.x, w.y, w.z, w.w); 
# 4376
} 
#endif
# 4378 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLod(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4379
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4384
::exit(___);}
#if 0
# 4379
{ 
# 4380
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4381
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4383
return make_float4(w.x, w.y, w.z, w.w); 
# 4384
} 
#endif
# 4392 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4393
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4398
::exit(___);}
#if 0
# 4393
{ 
# 4394
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4395
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4397
return w.x; 
# 4398
} 
#endif
# 4400 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4401
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4406
::exit(___);}
#if 0
# 4401
{ 
# 4402
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4403
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4405
return w.x; 
# 4406
} 
#endif
# 4408 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLod(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4409
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4414
::exit(___);}
#if 0
# 4409
{ 
# 4410
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4411
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4413
return make_float1(w.x); 
# 4414
} 
#endif
# 4416 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLod(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4417
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4422
::exit(___);}
#if 0
# 4417
{ 
# 4418
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4419
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4421
return make_float1(w.x); 
# 4422
} 
#endif
# 4424 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLod(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4425
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4430
::exit(___);}
#if 0
# 4425
{ 
# 4426
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4427
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4429
return make_float2(w.x, w.y); 
# 4430
} 
#endif
# 4432 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLod(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4433
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4438
::exit(___);}
#if 0
# 4433
{ 
# 4434
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4435
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4437
return make_float2(w.x, w.y); 
# 4438
} 
#endif
# 4440 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLod(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4441
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4446
::exit(___);}
#if 0
# 4441
{ 
# 4442
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4443
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4445
return make_float4(w.x, w.y, w.z, w.w); 
# 4446
} 
#endif
# 4448 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLod(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4449
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4454
::exit(___);}
#if 0
# 4449
{ 
# 4450
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4451
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4453
return make_float4(w.x, w.y, w.z, w.w); 
# 4454
} 
#endif
# 4462 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex2DLod(texture< char, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4463
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4471
::exit(___);}
#if 0
# 4463
{ 
# 4467
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4470
return (char)(v.x); 
# 4471
} 
#endif
# 4473 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2DLod(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4474
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4478
::exit(___);}
#if 0
# 4474
{ 
# 4475
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4477
return (signed char)(v.x); 
# 4478
} 
#endif
# 4480 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2DLod(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4481
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4485
::exit(___);}
#if 0
# 4481
{ 
# 4482
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4484
return (unsigned char)(v.x); 
# 4485
} 
#endif
# 4487 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2DLod(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4488
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4492
::exit(___);}
#if 0
# 4488
{ 
# 4489
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4491
return make_char1(v.x); 
# 4492
} 
#endif
# 4494 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2DLod(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4495
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4499
::exit(___);}
#if 0
# 4495
{ 
# 4496
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4498
return make_uchar1(v.x); 
# 4499
} 
#endif
# 4501 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2DLod(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4502
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4506
::exit(___);}
#if 0
# 4502
{ 
# 4503
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4505
return make_char2(v.x, v.y); 
# 4506
} 
#endif
# 4508 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2DLod(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4509
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4513
::exit(___);}
#if 0
# 4509
{ 
# 4510
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4512
return make_uchar2(v.x, v.y); 
# 4513
} 
#endif
# 4515 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2DLod(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4516
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4520
::exit(___);}
#if 0
# 4516
{ 
# 4517
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4519
return make_char4(v.x, v.y, v.z, v.w); 
# 4520
} 
#endif
# 4522 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2DLod(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4523
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4527
::exit(___);}
#if 0
# 4523
{ 
# 4524
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4526
return make_uchar4(v.x, v.y, v.z, v.w); 
# 4527
} 
#endif
# 4535 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex2DLod(texture< short, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4536
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4540
::exit(___);}
#if 0
# 4536
{ 
# 4537
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4539
return (short)(v.x); 
# 4540
} 
#endif
# 4542 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2DLod(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4543
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4547
::exit(___);}
#if 0
# 4543
{ 
# 4544
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4546
return (unsigned short)(v.x); 
# 4547
} 
#endif
# 4549 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2DLod(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4550
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4554
::exit(___);}
#if 0
# 4550
{ 
# 4551
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4553
return make_short1(v.x); 
# 4554
} 
#endif
# 4556 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2DLod(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4557
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4561
::exit(___);}
#if 0
# 4557
{ 
# 4558
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4560
return make_ushort1(v.x); 
# 4561
} 
#endif
# 4563 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2DLod(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4564
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4568
::exit(___);}
#if 0
# 4564
{ 
# 4565
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4567
return make_short2(v.x, v.y); 
# 4568
} 
#endif
# 4570 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2DLod(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4571
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4575
::exit(___);}
#if 0
# 4571
{ 
# 4572
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4574
return make_ushort2(v.x, v.y); 
# 4575
} 
#endif
# 4577 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2DLod(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4578
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4582
::exit(___);}
#if 0
# 4578
{ 
# 4579
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4581
return make_short4(v.x, v.y, v.z, v.w); 
# 4582
} 
#endif
# 4584 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2DLod(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4585
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4589
::exit(___);}
#if 0
# 4585
{ 
# 4586
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4588
return make_ushort4(v.x, v.y, v.z, v.w); 
# 4589
} 
#endif
# 4597 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex2DLod(texture< int, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4598
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4602
::exit(___);}
#if 0
# 4598
{ 
# 4599
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4601
return (int)(v.x); 
# 4602
} 
#endif
# 4604 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2DLod(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4605
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4609
::exit(___);}
#if 0
# 4605
{ 
# 4606
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4608
return (unsigned)(v.x); 
# 4609
} 
#endif
# 4611 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2DLod(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4612
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4616
::exit(___);}
#if 0
# 4612
{ 
# 4613
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4615
return make_int1(v.x); 
# 4616
} 
#endif
# 4618 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2DLod(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4619
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4623
::exit(___);}
#if 0
# 4619
{ 
# 4620
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4622
return make_uint1(v.x); 
# 4623
} 
#endif
# 4625 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2DLod(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4626
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4630
::exit(___);}
#if 0
# 4626
{ 
# 4627
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4629
return make_int2(v.x, v.y); 
# 4630
} 
#endif
# 4632 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2DLod(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4633
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4637
::exit(___);}
#if 0
# 4633
{ 
# 4634
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4636
return make_uint2(v.x, v.y); 
# 4637
} 
#endif
# 4639 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2DLod(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4640
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4644
::exit(___);}
#if 0
# 4640
{ 
# 4641
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4643
return make_int4(v.x, v.y, v.z, v.w); 
# 4644
} 
#endif
# 4646 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2DLod(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4647
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4651
::exit(___);}
#if 0
# 4647
{ 
# 4648
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4650
return make_uint4(v.x, v.y, v.z, v.w); 
# 4651
} 
#endif
# 4725 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< float, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4726
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4730
::exit(___);}
#if 0
# 4726
{ 
# 4727
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4729
return v.x; 
# 4730
} 
#endif
# 4732 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLod(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4733
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4737
::exit(___);}
#if 0
# 4733
{ 
# 4734
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4736
return make_float1(v.x); 
# 4737
} 
#endif
# 4739 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLod(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4740
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4744
::exit(___);}
#if 0
# 4740
{ 
# 4741
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4743
return make_float2(v.x, v.y); 
# 4744
} 
#endif
# 4746 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLod(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4747
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4751
::exit(___);}
#if 0
# 4747
{ 
# 4748
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4750
return make_float4(v.x, v.y, v.z, v.w); 
# 4751
} 
#endif
# 4759 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4760
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4769
::exit(___);}
#if 0
# 4760
{ 
# 4764
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4766
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4768
return w.x; 
# 4769
} 
#endif
# 4771 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4772
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4777
::exit(___);}
#if 0
# 4772
{ 
# 4773
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4774
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4776
return w.x; 
# 4777
} 
#endif
# 4779 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4780
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4785
::exit(___);}
#if 0
# 4780
{ 
# 4781
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4782
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4784
return w.x; 
# 4785
} 
#endif
# 4787 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLod(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4788
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4793
::exit(___);}
#if 0
# 4788
{ 
# 4789
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4790
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4792
return make_float1(w.x); 
# 4793
} 
#endif
# 4795 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLod(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4796
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4801
::exit(___);}
#if 0
# 4796
{ 
# 4797
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4798
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4800
return make_float1(w.x); 
# 4801
} 
#endif
# 4803 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLod(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4804
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4809
::exit(___);}
#if 0
# 4804
{ 
# 4805
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4806
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4808
return make_float2(w.x, w.y); 
# 4809
} 
#endif
# 4811 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLod(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4812
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4817
::exit(___);}
#if 0
# 4812
{ 
# 4813
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4814
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4816
return make_float2(w.x, w.y); 
# 4817
} 
#endif
# 4819 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLod(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4820
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4825
::exit(___);}
#if 0
# 4820
{ 
# 4821
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4822
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4824
return make_float4(w.x, w.y, w.z, w.w); 
# 4825
} 
#endif
# 4827 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLod(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4828
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4833
::exit(___);}
#if 0
# 4828
{ 
# 4829
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4830
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4832
return make_float4(w.x, w.y, w.z, w.w); 
# 4833
} 
#endif
# 4841 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4842
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4847
::exit(___);}
#if 0
# 4842
{ 
# 4843
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4844
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4846
return w.x; 
# 4847
} 
#endif
# 4849 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4850
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4855
::exit(___);}
#if 0
# 4850
{ 
# 4851
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4852
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4854
return w.x; 
# 4855
} 
#endif
# 4857 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLod(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4858
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4863
::exit(___);}
#if 0
# 4858
{ 
# 4859
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4860
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4862
return make_float1(w.x); 
# 4863
} 
#endif
# 4865 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLod(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4866
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4871
::exit(___);}
#if 0
# 4866
{ 
# 4867
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4868
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4870
return make_float1(w.x); 
# 4871
} 
#endif
# 4873 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLod(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4874
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4879
::exit(___);}
#if 0
# 4874
{ 
# 4875
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4876
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4878
return make_float2(w.x, w.y); 
# 4879
} 
#endif
# 4881 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLod(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4882
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4887
::exit(___);}
#if 0
# 4882
{ 
# 4883
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4884
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4886
return make_float2(w.x, w.y); 
# 4887
} 
#endif
# 4889 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLod(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4890
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4895
::exit(___);}
#if 0
# 4890
{ 
# 4891
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4892
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4894
return make_float4(w.x, w.y, w.z, w.w); 
# 4895
} 
#endif
# 4897 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLod(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4903
::exit(___);}
#if 0
# 4898
{ 
# 4899
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4900
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4902
return make_float4(w.x, w.y, w.z, w.w); 
# 4903
} 
#endif
# 4911 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex1DLayeredLod(texture< char, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 4912
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 4920
::exit(___);}
#if 0
# 4912
{ 
# 4916
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 4919
return (char)(v.x); 
# 4920
} 
#endif
# 4922 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1DLayeredLod(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 4923
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 4927
::exit(___);}
#if 0
# 4923
{ 
# 4924
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 4926
return (signed char)(v.x); 
# 4927
} 
#endif
# 4929 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1DLayeredLod(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 4930
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 4934
::exit(___);}
#if 0
# 4930
{ 
# 4931
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 4933
return (unsigned char)(v.x); 
# 4934
} 
#endif
# 4936 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1DLayeredLod(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 4937
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 4941
::exit(___);}
#if 0
# 4937
{ 
# 4938
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 4940
return make_char1(v.x); 
# 4941
} 
#endif
# 4943 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1DLayeredLod(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 4944
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 4948
::exit(___);}
#if 0
# 4944
{ 
# 4945
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 4947
return make_uchar1(v.x); 
# 4948
} 
#endif
# 4950 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1DLayeredLod(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 4951
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 4955
::exit(___);}
#if 0
# 4951
{ 
# 4952
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 4954
return make_char2(v.x, v.y); 
# 4955
} 
#endif
# 4957 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1DLayeredLod(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 4958
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 4962
::exit(___);}
#if 0
# 4958
{ 
# 4959
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 4961
return make_uchar2(v.x, v.y); 
# 4962
} 
#endif
# 4964 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1DLayeredLod(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 4965
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 4969
::exit(___);}
#if 0
# 4965
{ 
# 4966
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 4968
return make_char4(v.x, v.y, v.z, v.w); 
# 4969
} 
#endif
# 4971 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1DLayeredLod(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 4972
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 4976
::exit(___);}
#if 0
# 4972
{ 
# 4973
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 4975
return make_uchar4(v.x, v.y, v.z, v.w); 
# 4976
} 
#endif
# 4984 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex1DLayeredLod(texture< short, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 4985
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 4989
::exit(___);}
#if 0
# 4985
{ 
# 4986
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 4988
return (short)(v.x); 
# 4989
} 
#endif
# 4991 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1DLayeredLod(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 4992
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 4996
::exit(___);}
#if 0
# 4992
{ 
# 4993
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 4995
return (unsigned short)(v.x); 
# 4996
} 
#endif
# 4998 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1DLayeredLod(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 4999
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5003
::exit(___);}
#if 0
# 4999
{ 
# 5000
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5002
return make_short1(v.x); 
# 5003
} 
#endif
# 5005 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1DLayeredLod(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5006
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5010
::exit(___);}
#if 0
# 5006
{ 
# 5007
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5009
return make_ushort1(v.x); 
# 5010
} 
#endif
# 5012 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1DLayeredLod(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5013
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5017
::exit(___);}
#if 0
# 5013
{ 
# 5014
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5016
return make_short2(v.x, v.y); 
# 5017
} 
#endif
# 5019 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1DLayeredLod(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5020
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5024
::exit(___);}
#if 0
# 5020
{ 
# 5021
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5023
return make_ushort2(v.x, v.y); 
# 5024
} 
#endif
# 5026 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1DLayeredLod(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5027
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5031
::exit(___);}
#if 0
# 5027
{ 
# 5028
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5030
return make_short4(v.x, v.y, v.z, v.w); 
# 5031
} 
#endif
# 5033 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1DLayeredLod(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5034
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5038
::exit(___);}
#if 0
# 5034
{ 
# 5035
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5037
return make_ushort4(v.x, v.y, v.z, v.w); 
# 5038
} 
#endif
# 5046 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex1DLayeredLod(texture< int, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5047
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5051
::exit(___);}
#if 0
# 5047
{ 
# 5048
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5050
return (int)(v.x); 
# 5051
} 
#endif
# 5053 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1DLayeredLod(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5054
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5058
::exit(___);}
#if 0
# 5054
{ 
# 5055
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5057
return (unsigned)(v.x); 
# 5058
} 
#endif
# 5060 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1DLayeredLod(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5061
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5065
::exit(___);}
#if 0
# 5061
{ 
# 5062
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5064
return make_int1(v.x); 
# 5065
} 
#endif
# 5067 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1DLayeredLod(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5068
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5072
::exit(___);}
#if 0
# 5068
{ 
# 5069
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5071
return make_uint1(v.x); 
# 5072
} 
#endif
# 5074 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1DLayeredLod(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5075
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5079
::exit(___);}
#if 0
# 5075
{ 
# 5076
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5078
return make_int2(v.x, v.y); 
# 5079
} 
#endif
# 5081 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1DLayeredLod(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5082
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5086
::exit(___);}
#if 0
# 5082
{ 
# 5083
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5085
return make_uint2(v.x, v.y); 
# 5086
} 
#endif
# 5088 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1DLayeredLod(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5089
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5093
::exit(___);}
#if 0
# 5089
{ 
# 5090
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5092
return make_int4(v.x, v.y, v.z, v.w); 
# 5093
} 
#endif
# 5095 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1DLayeredLod(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5096
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5100
::exit(___);}
#if 0
# 5096
{ 
# 5097
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5099
return make_uint4(v.x, v.y, v.z, v.w); 
# 5100
} 
#endif
# 5174 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< float, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5175
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5179
::exit(___);}
#if 0
# 5175
{ 
# 5176
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5178
return v.x; 
# 5179
} 
#endif
# 5181 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredLod(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5182
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5186
::exit(___);}
#if 0
# 5182
{ 
# 5183
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5185
return make_float1(v.x); 
# 5186
} 
#endif
# 5188 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredLod(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5189
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5193
::exit(___);}
#if 0
# 5189
{ 
# 5190
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5192
return make_float2(v.x, v.y); 
# 5193
} 
#endif
# 5195 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredLod(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5196
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5200
::exit(___);}
#if 0
# 5196
{ 
# 5197
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5199
return make_float4(v.x, v.y, v.z, v.w); 
# 5200
} 
#endif
# 5208 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5209
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5218
::exit(___);}
#if 0
# 5209
{ 
# 5213
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5215
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5217
return w.x; 
# 5218
} 
#endif
# 5220 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5221
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5226
::exit(___);}
#if 0
# 5221
{ 
# 5222
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5223
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5225
return w.x; 
# 5226
} 
#endif
# 5228 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5229
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5234
::exit(___);}
#if 0
# 5229
{ 
# 5230
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5231
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5233
return w.x; 
# 5234
} 
#endif
# 5236 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredLod(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5237
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5242
::exit(___);}
#if 0
# 5237
{ 
# 5238
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5239
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5241
return make_float1(w.x); 
# 5242
} 
#endif
# 5244 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredLod(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5245
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5250
::exit(___);}
#if 0
# 5245
{ 
# 5246
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5247
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5249
return make_float1(w.x); 
# 5250
} 
#endif
# 5252 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredLod(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5253
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5258
::exit(___);}
#if 0
# 5253
{ 
# 5254
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5255
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5257
return make_float2(w.x, w.y); 
# 5258
} 
#endif
# 5260 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredLod(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5261
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5266
::exit(___);}
#if 0
# 5261
{ 
# 5262
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5263
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5265
return make_float2(w.x, w.y); 
# 5266
} 
#endif
# 5268 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredLod(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5269
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5274
::exit(___);}
#if 0
# 5269
{ 
# 5270
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5271
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5273
return make_float4(w.x, w.y, w.z, w.w); 
# 5274
} 
#endif
# 5276 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredLod(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5277
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5282
::exit(___);}
#if 0
# 5277
{ 
# 5278
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5279
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5281
return make_float4(w.x, w.y, w.z, w.w); 
# 5282
} 
#endif
# 5290 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5291
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5296
::exit(___);}
#if 0
# 5291
{ 
# 5292
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5293
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5295
return w.x; 
# 5296
} 
#endif
# 5298 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5299
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5304
::exit(___);}
#if 0
# 5299
{ 
# 5300
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5301
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5303
return w.x; 
# 5304
} 
#endif
# 5306 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredLod(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5307
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5312
::exit(___);}
#if 0
# 5307
{ 
# 5308
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5309
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5311
return make_float1(w.x); 
# 5312
} 
#endif
# 5314 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredLod(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5315
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5320
::exit(___);}
#if 0
# 5315
{ 
# 5316
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5317
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5319
return make_float1(w.x); 
# 5320
} 
#endif
# 5322 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredLod(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5323
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5328
::exit(___);}
#if 0
# 5323
{ 
# 5324
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5325
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5327
return make_float2(w.x, w.y); 
# 5328
} 
#endif
# 5330 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredLod(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5331
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5336
::exit(___);}
#if 0
# 5331
{ 
# 5332
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5333
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5335
return make_float2(w.x, w.y); 
# 5336
} 
#endif
# 5338 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredLod(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5339
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5344
::exit(___);}
#if 0
# 5339
{ 
# 5340
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5341
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5343
return make_float4(w.x, w.y, w.z, w.w); 
# 5344
} 
#endif
# 5346 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredLod(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5347
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5352
::exit(___);}
#if 0
# 5347
{ 
# 5348
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5349
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5351
return make_float4(w.x, w.y, w.z, w.w); 
# 5352
} 
#endif
# 5360 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex2DLayeredLod(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5361
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5369
::exit(___);}
#if 0
# 5361
{ 
# 5365
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5368
return (char)(v.x); 
# 5369
} 
#endif
# 5371 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2DLayeredLod(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5372
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5376
::exit(___);}
#if 0
# 5372
{ 
# 5373
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5375
return (signed char)(v.x); 
# 5376
} 
#endif
# 5378 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2DLayeredLod(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5379
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5383
::exit(___);}
#if 0
# 5379
{ 
# 5380
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5382
return (unsigned char)(v.x); 
# 5383
} 
#endif
# 5385 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2DLayeredLod(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5386
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5390
::exit(___);}
#if 0
# 5386
{ 
# 5387
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5389
return make_char1(v.x); 
# 5390
} 
#endif
# 5392 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2DLayeredLod(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5393
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5397
::exit(___);}
#if 0
# 5393
{ 
# 5394
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5396
return make_uchar1(v.x); 
# 5397
} 
#endif
# 5399 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2DLayeredLod(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5400
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5404
::exit(___);}
#if 0
# 5400
{ 
# 5401
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5403
return make_char2(v.x, v.y); 
# 5404
} 
#endif
# 5406 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2DLayeredLod(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5407
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5411
::exit(___);}
#if 0
# 5407
{ 
# 5408
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5410
return make_uchar2(v.x, v.y); 
# 5411
} 
#endif
# 5413 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2DLayeredLod(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5414
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5418
::exit(___);}
#if 0
# 5414
{ 
# 5415
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5417
return make_char4(v.x, v.y, v.z, v.w); 
# 5418
} 
#endif
# 5420 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2DLayeredLod(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5421
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5425
::exit(___);}
#if 0
# 5421
{ 
# 5422
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5424
return make_uchar4(v.x, v.y, v.z, v.w); 
# 5425
} 
#endif
# 5433 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex2DLayeredLod(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5434
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5438
::exit(___);}
#if 0
# 5434
{ 
# 5435
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5437
return (short)(v.x); 
# 5438
} 
#endif
# 5440 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2DLayeredLod(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5441
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5445
::exit(___);}
#if 0
# 5441
{ 
# 5442
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5444
return (unsigned short)(v.x); 
# 5445
} 
#endif
# 5447 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2DLayeredLod(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5448
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5452
::exit(___);}
#if 0
# 5448
{ 
# 5449
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5451
return make_short1(v.x); 
# 5452
} 
#endif
# 5454 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2DLayeredLod(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5455
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5459
::exit(___);}
#if 0
# 5455
{ 
# 5456
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5458
return make_ushort1(v.x); 
# 5459
} 
#endif
# 5461 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2DLayeredLod(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5462
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5466
::exit(___);}
#if 0
# 5462
{ 
# 5463
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5465
return make_short2(v.x, v.y); 
# 5466
} 
#endif
# 5468 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2DLayeredLod(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5469
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5473
::exit(___);}
#if 0
# 5469
{ 
# 5470
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5472
return make_ushort2(v.x, v.y); 
# 5473
} 
#endif
# 5475 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2DLayeredLod(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5476
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5480
::exit(___);}
#if 0
# 5476
{ 
# 5477
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5479
return make_short4(v.x, v.y, v.z, v.w); 
# 5480
} 
#endif
# 5482 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2DLayeredLod(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5483
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5487
::exit(___);}
#if 0
# 5483
{ 
# 5484
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5486
return make_ushort4(v.x, v.y, v.z, v.w); 
# 5487
} 
#endif
# 5495 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex2DLayeredLod(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5496
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5500
::exit(___);}
#if 0
# 5496
{ 
# 5497
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5499
return (int)(v.x); 
# 5500
} 
#endif
# 5502 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2DLayeredLod(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5503
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5507
::exit(___);}
#if 0
# 5503
{ 
# 5504
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5506
return (unsigned)(v.x); 
# 5507
} 
#endif
# 5509 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2DLayeredLod(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5510
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5514
::exit(___);}
#if 0
# 5510
{ 
# 5511
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5513
return make_int1(v.x); 
# 5514
} 
#endif
# 5516 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2DLayeredLod(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5517
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5521
::exit(___);}
#if 0
# 5517
{ 
# 5518
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5520
return make_uint1(v.x); 
# 5521
} 
#endif
# 5523 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2DLayeredLod(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5524
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5528
::exit(___);}
#if 0
# 5524
{ 
# 5525
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5527
return make_int2(v.x, v.y); 
# 5528
} 
#endif
# 5530 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2DLayeredLod(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5531
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5535
::exit(___);}
#if 0
# 5531
{ 
# 5532
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5534
return make_uint2(v.x, v.y); 
# 5535
} 
#endif
# 5537 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2DLayeredLod(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5538
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5542
::exit(___);}
#if 0
# 5538
{ 
# 5539
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5541
return make_int4(v.x, v.y, v.z, v.w); 
# 5542
} 
#endif
# 5544 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2DLayeredLod(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5545
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5549
::exit(___);}
#if 0
# 5545
{ 
# 5546
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5548
return make_uint4(v.x, v.y, v.z, v.w); 
# 5549
} 
#endif
# 5623 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5624
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5628
::exit(___);}
#if 0
# 5624
{ 
# 5625
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5627
return v.x; 
# 5628
} 
#endif
# 5630 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredLod(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5631
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5635
::exit(___);}
#if 0
# 5631
{ 
# 5632
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5634
return make_float1(v.x); 
# 5635
} 
#endif
# 5637 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredLod(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5638
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5642
::exit(___);}
#if 0
# 5638
{ 
# 5639
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5641
return make_float2(v.x, v.y); 
# 5642
} 
#endif
# 5644 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredLod(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5645
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5649
::exit(___);}
#if 0
# 5645
{ 
# 5646
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5648
return make_float4(v.x, v.y, v.z, v.w); 
# 5649
} 
#endif
# 5657 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5658
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5667
::exit(___);}
#if 0
# 5658
{ 
# 5662
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5664
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5666
return w.x; 
# 5667
} 
#endif
# 5669 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5670
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5675
::exit(___);}
#if 0
# 5670
{ 
# 5671
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5672
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5674
return w.x; 
# 5675
} 
#endif
# 5677 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5678
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5683
::exit(___);}
#if 0
# 5678
{ 
# 5679
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5680
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5682
return w.x; 
# 5683
} 
#endif
# 5685 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredLod(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5686
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5691
::exit(___);}
#if 0
# 5686
{ 
# 5687
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5688
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5690
return make_float1(w.x); 
# 5691
} 
#endif
# 5693 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredLod(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5694
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5699
::exit(___);}
#if 0
# 5694
{ 
# 5695
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5696
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5698
return make_float1(w.x); 
# 5699
} 
#endif
# 5701 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredLod(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5702
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5707
::exit(___);}
#if 0
# 5702
{ 
# 5703
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5704
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5706
return make_float2(w.x, w.y); 
# 5707
} 
#endif
# 5709 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredLod(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5710
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5715
::exit(___);}
#if 0
# 5710
{ 
# 5711
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5712
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5714
return make_float2(w.x, w.y); 
# 5715
} 
#endif
# 5717 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredLod(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5718
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5723
::exit(___);}
#if 0
# 5718
{ 
# 5719
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5720
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5722
return make_float4(w.x, w.y, w.z, w.w); 
# 5723
} 
#endif
# 5725 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredLod(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5726
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5731
::exit(___);}
#if 0
# 5726
{ 
# 5727
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5728
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5730
return make_float4(w.x, w.y, w.z, w.w); 
# 5731
} 
#endif
# 5739 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5740
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5745
::exit(___);}
#if 0
# 5740
{ 
# 5741
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5742
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5744
return w.x; 
# 5745
} 
#endif
# 5747 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5748
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5753
::exit(___);}
#if 0
# 5748
{ 
# 5749
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5750
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5752
return w.x; 
# 5753
} 
#endif
# 5755 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredLod(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5756
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5761
::exit(___);}
#if 0
# 5756
{ 
# 5757
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5758
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5760
return make_float1(w.x); 
# 5761
} 
#endif
# 5763 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredLod(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5764
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5769
::exit(___);}
#if 0
# 5764
{ 
# 5765
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5766
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5768
return make_float1(w.x); 
# 5769
} 
#endif
# 5771 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredLod(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5772
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5777
::exit(___);}
#if 0
# 5772
{ 
# 5773
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5774
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5776
return make_float2(w.x, w.y); 
# 5777
} 
#endif
# 5779 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredLod(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5780
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5785
::exit(___);}
#if 0
# 5780
{ 
# 5781
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5782
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5784
return make_float2(w.x, w.y); 
# 5785
} 
#endif
# 5787 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredLod(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5788
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5793
::exit(___);}
#if 0
# 5788
{ 
# 5789
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5790
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5792
return make_float4(w.x, w.y, w.z, w.w); 
# 5793
} 
#endif
# 5795 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredLod(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5796
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5801
::exit(___);}
#if 0
# 5796
{ 
# 5797
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5798
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5800
return make_float4(w.x, w.y, w.z, w.w); 
# 5801
} 
#endif
# 5809 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex3DLod(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5810
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5818
::exit(___);}
#if 0
# 5810
{ 
# 5814
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5817
return (char)(v.x); 
# 5818
} 
#endif
# 5820 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex3DLod(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5821
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5825
::exit(___);}
#if 0
# 5821
{ 
# 5822
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5824
return (signed char)(v.x); 
# 5825
} 
#endif
# 5827 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex3DLod(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5828
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5832
::exit(___);}
#if 0
# 5828
{ 
# 5829
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5831
return (unsigned char)(v.x); 
# 5832
} 
#endif
# 5834 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex3DLod(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5835
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5839
::exit(___);}
#if 0
# 5835
{ 
# 5836
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5838
return make_char1(v.x); 
# 5839
} 
#endif
# 5841 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex3DLod(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5842
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5846
::exit(___);}
#if 0
# 5842
{ 
# 5843
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5845
return make_uchar1(v.x); 
# 5846
} 
#endif
# 5848 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex3DLod(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5849
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5853
::exit(___);}
#if 0
# 5849
{ 
# 5850
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5852
return make_char2(v.x, v.y); 
# 5853
} 
#endif
# 5855 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex3DLod(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5856
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5860
::exit(___);}
#if 0
# 5856
{ 
# 5857
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5859
return make_uchar2(v.x, v.y); 
# 5860
} 
#endif
# 5862 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex3DLod(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5863
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5867
::exit(___);}
#if 0
# 5863
{ 
# 5864
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5866
return make_char4(v.x, v.y, v.z, v.w); 
# 5867
} 
#endif
# 5869 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex3DLod(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5870
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5874
::exit(___);}
#if 0
# 5870
{ 
# 5871
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5873
return make_uchar4(v.x, v.y, v.z, v.w); 
# 5874
} 
#endif
# 5882 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex3DLod(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5883
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5887
::exit(___);}
#if 0
# 5883
{ 
# 5884
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5886
return (short)(v.x); 
# 5887
} 
#endif
# 5889 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex3DLod(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5890
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5894
::exit(___);}
#if 0
# 5890
{ 
# 5891
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5893
return (unsigned short)(v.x); 
# 5894
} 
#endif
# 5896 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex3DLod(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5897
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5901
::exit(___);}
#if 0
# 5897
{ 
# 5898
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5900
return make_short1(v.x); 
# 5901
} 
#endif
# 5903 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex3DLod(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5904
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5908
::exit(___);}
#if 0
# 5904
{ 
# 5905
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5907
return make_ushort1(v.x); 
# 5908
} 
#endif
# 5910 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex3DLod(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5911
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5915
::exit(___);}
#if 0
# 5911
{ 
# 5912
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5914
return make_short2(v.x, v.y); 
# 5915
} 
#endif
# 5917 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex3DLod(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5918
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5922
::exit(___);}
#if 0
# 5918
{ 
# 5919
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5921
return make_ushort2(v.x, v.y); 
# 5922
} 
#endif
# 5924 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex3DLod(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5925
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5929
::exit(___);}
#if 0
# 5925
{ 
# 5926
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5928
return make_short4(v.x, v.y, v.z, v.w); 
# 5929
} 
#endif
# 5931 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex3DLod(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5932
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5936
::exit(___);}
#if 0
# 5932
{ 
# 5933
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5935
return make_ushort4(v.x, v.y, v.z, v.w); 
# 5936
} 
#endif
# 5944 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex3DLod(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5945
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5949
::exit(___);}
#if 0
# 5945
{ 
# 5946
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5948
return (int)(v.x); 
# 5949
} 
#endif
# 5951 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex3DLod(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5952
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5956
::exit(___);}
#if 0
# 5952
{ 
# 5953
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5955
return (unsigned)(v.x); 
# 5956
} 
#endif
# 5958 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex3DLod(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5959
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5963
::exit(___);}
#if 0
# 5959
{ 
# 5960
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5962
return make_int1(v.x); 
# 5963
} 
#endif
# 5965 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex3DLod(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5966
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5970
::exit(___);}
#if 0
# 5966
{ 
# 5967
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5969
return make_uint1(v.x); 
# 5970
} 
#endif
# 5972 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex3DLod(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5973
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5977
::exit(___);}
#if 0
# 5973
{ 
# 5974
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5976
return make_int2(v.x, v.y); 
# 5977
} 
#endif
# 5979 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex3DLod(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5980
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5984
::exit(___);}
#if 0
# 5980
{ 
# 5981
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5983
return make_uint2(v.x, v.y); 
# 5984
} 
#endif
# 5986 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex3DLod(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5987
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5991
::exit(___);}
#if 0
# 5987
{ 
# 5988
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5990
return make_int4(v.x, v.y, v.z, v.w); 
# 5991
} 
#endif
# 5993 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex3DLod(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5994
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5998
::exit(___);}
#if 0
# 5994
{ 
# 5995
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5997
return make_uint4(v.x, v.y, v.z, v.w); 
# 5998
} 
#endif
# 6072 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6073
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6077
::exit(___);}
#if 0
# 6073
{ 
# 6074
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6076
return v.x; 
# 6077
} 
#endif
# 6079 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DLod(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6080
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6084
::exit(___);}
#if 0
# 6080
{ 
# 6081
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6083
return make_float1(v.x); 
# 6084
} 
#endif
# 6086 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DLod(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6087
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6091
::exit(___);}
#if 0
# 6087
{ 
# 6088
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6090
return make_float2(v.x, v.y); 
# 6091
} 
#endif
# 6093 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DLod(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6094
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6098
::exit(___);}
#if 0
# 6094
{ 
# 6095
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6097
return make_float4(v.x, v.y, v.z, v.w); 
# 6098
} 
#endif
# 6106 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6107
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6116
::exit(___);}
#if 0
# 6107
{ 
# 6111
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6113
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6115
return w.x; 
# 6116
} 
#endif
# 6118 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6119
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6124
::exit(___);}
#if 0
# 6119
{ 
# 6120
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6121
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6123
return w.x; 
# 6124
} 
#endif
# 6126 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6127
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6132
::exit(___);}
#if 0
# 6127
{ 
# 6128
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6129
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6131
return w.x; 
# 6132
} 
#endif
# 6134 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DLod(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6135
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6140
::exit(___);}
#if 0
# 6135
{ 
# 6136
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6137
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6139
return make_float1(w.x); 
# 6140
} 
#endif
# 6142 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DLod(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6143
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6148
::exit(___);}
#if 0
# 6143
{ 
# 6144
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6145
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6147
return make_float1(w.x); 
# 6148
} 
#endif
# 6150 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DLod(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6151
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6156
::exit(___);}
#if 0
# 6151
{ 
# 6152
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6153
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6155
return make_float2(w.x, w.y); 
# 6156
} 
#endif
# 6158 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DLod(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6159
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6164
::exit(___);}
#if 0
# 6159
{ 
# 6160
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6161
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6163
return make_float2(w.x, w.y); 
# 6164
} 
#endif
# 6166 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DLod(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6167
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6172
::exit(___);}
#if 0
# 6167
{ 
# 6168
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6169
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6171
return make_float4(w.x, w.y, w.z, w.w); 
# 6172
} 
#endif
# 6174 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DLod(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6175
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6180
::exit(___);}
#if 0
# 6175
{ 
# 6176
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6177
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6179
return make_float4(w.x, w.y, w.z, w.w); 
# 6180
} 
#endif
# 6188 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6189
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6194
::exit(___);}
#if 0
# 6189
{ 
# 6190
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6191
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6193
return w.x; 
# 6194
} 
#endif
# 6196 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6197
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6202
::exit(___);}
#if 0
# 6197
{ 
# 6198
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6199
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6201
return w.x; 
# 6202
} 
#endif
# 6204 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DLod(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6205
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6210
::exit(___);}
#if 0
# 6205
{ 
# 6206
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6207
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6209
return make_float1(w.x); 
# 6210
} 
#endif
# 6212 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DLod(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6213
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6218
::exit(___);}
#if 0
# 6213
{ 
# 6214
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6215
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6217
return make_float1(w.x); 
# 6218
} 
#endif
# 6220 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DLod(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6221
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6226
::exit(___);}
#if 0
# 6221
{ 
# 6222
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6223
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6225
return make_float2(w.x, w.y); 
# 6226
} 
#endif
# 6228 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DLod(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6229
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6234
::exit(___);}
#if 0
# 6229
{ 
# 6230
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6231
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6233
return make_float2(w.x, w.y); 
# 6234
} 
#endif
# 6236 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DLod(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6237
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6242
::exit(___);}
#if 0
# 6237
{ 
# 6238
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6239
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6241
return make_float4(w.x, w.y, w.z, w.w); 
# 6242
} 
#endif
# 6244 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DLod(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6245
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6250
::exit(___);}
#if 0
# 6245
{ 
# 6246
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6247
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6249
return make_float4(w.x, w.y, w.z, w.w); 
# 6250
} 
#endif
# 6258 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char texCubemapLod(texture< char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6259
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6267
::exit(___);}
#if 0
# 6259
{ 
# 6263
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6266
return (char)(v.x); 
# 6267
} 
#endif
# 6269 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char texCubemapLod(texture< signed char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6270
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6274
::exit(___);}
#if 0
# 6270
{ 
# 6271
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6273
return (signed char)(v.x); 
# 6274
} 
#endif
# 6276 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char texCubemapLod(texture< unsigned char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6277
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6281
::exit(___);}
#if 0
# 6277
{ 
# 6278
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6280
return (unsigned char)(v.x); 
# 6281
} 
#endif
# 6283 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 texCubemapLod(texture< char1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6284
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6288
::exit(___);}
#if 0
# 6284
{ 
# 6285
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6287
return make_char1(v.x); 
# 6288
} 
#endif
# 6290 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 texCubemapLod(texture< uchar1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6291
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6295
::exit(___);}
#if 0
# 6291
{ 
# 6292
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6294
return make_uchar1(v.x); 
# 6295
} 
#endif
# 6297 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 texCubemapLod(texture< char2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6298
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6302
::exit(___);}
#if 0
# 6298
{ 
# 6299
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6301
return make_char2(v.x, v.y); 
# 6302
} 
#endif
# 6304 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 texCubemapLod(texture< uchar2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6305
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6309
::exit(___);}
#if 0
# 6305
{ 
# 6306
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6308
return make_uchar2(v.x, v.y); 
# 6309
} 
#endif
# 6311 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 texCubemapLod(texture< char4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6312
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6316
::exit(___);}
#if 0
# 6312
{ 
# 6313
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6315
return make_char4(v.x, v.y, v.z, v.w); 
# 6316
} 
#endif
# 6318 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 texCubemapLod(texture< uchar4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6319
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6323
::exit(___);}
#if 0
# 6319
{ 
# 6320
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6322
return make_uchar4(v.x, v.y, v.z, v.w); 
# 6323
} 
#endif
# 6331 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short texCubemapLod(texture< short, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6332
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6336
::exit(___);}
#if 0
# 6332
{ 
# 6333
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6335
return (short)(v.x); 
# 6336
} 
#endif
# 6338 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short texCubemapLod(texture< unsigned short, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6339
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6343
::exit(___);}
#if 0
# 6339
{ 
# 6340
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6342
return (unsigned short)(v.x); 
# 6343
} 
#endif
# 6345 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 texCubemapLod(texture< short1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6346
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6350
::exit(___);}
#if 0
# 6346
{ 
# 6347
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6349
return make_short1(v.x); 
# 6350
} 
#endif
# 6352 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 texCubemapLod(texture< ushort1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6353
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6357
::exit(___);}
#if 0
# 6353
{ 
# 6354
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6356
return make_ushort1(v.x); 
# 6357
} 
#endif
# 6359 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 texCubemapLod(texture< short2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6360
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6364
::exit(___);}
#if 0
# 6360
{ 
# 6361
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6363
return make_short2(v.x, v.y); 
# 6364
} 
#endif
# 6366 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 texCubemapLod(texture< ushort2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6367
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6371
::exit(___);}
#if 0
# 6367
{ 
# 6368
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6370
return make_ushort2(v.x, v.y); 
# 6371
} 
#endif
# 6373 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 texCubemapLod(texture< short4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6374
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6378
::exit(___);}
#if 0
# 6374
{ 
# 6375
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6377
return make_short4(v.x, v.y, v.z, v.w); 
# 6378
} 
#endif
# 6380 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 texCubemapLod(texture< ushort4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6381
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6385
::exit(___);}
#if 0
# 6381
{ 
# 6382
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6384
return make_ushort4(v.x, v.y, v.z, v.w); 
# 6385
} 
#endif
# 6393 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int texCubemapLod(texture< int, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6394
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6398
::exit(___);}
#if 0
# 6394
{ 
# 6395
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6397
return (int)(v.x); 
# 6398
} 
#endif
# 6400 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned texCubemapLod(texture< unsigned, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6401
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6405
::exit(___);}
#if 0
# 6401
{ 
# 6402
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6404
return (unsigned)(v.x); 
# 6405
} 
#endif
# 6407 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 texCubemapLod(texture< int1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6408
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6412
::exit(___);}
#if 0
# 6408
{ 
# 6409
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6411
return make_int1(v.x); 
# 6412
} 
#endif
# 6414 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 texCubemapLod(texture< uint1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6415
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6419
::exit(___);}
#if 0
# 6415
{ 
# 6416
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6418
return make_uint1(v.x); 
# 6419
} 
#endif
# 6421 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 texCubemapLod(texture< int2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6422
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6426
::exit(___);}
#if 0
# 6422
{ 
# 6423
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6425
return make_int2(v.x, v.y); 
# 6426
} 
#endif
# 6428 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 texCubemapLod(texture< uint2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6429
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6433
::exit(___);}
#if 0
# 6429
{ 
# 6430
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6432
return make_uint2(v.x, v.y); 
# 6433
} 
#endif
# 6435 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 texCubemapLod(texture< int4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6436
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6440
::exit(___);}
#if 0
# 6436
{ 
# 6437
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6439
return make_int4(v.x, v.y, v.z, v.w); 
# 6440
} 
#endif
# 6442 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 texCubemapLod(texture< uint4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6443
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6447
::exit(___);}
#if 0
# 6443
{ 
# 6444
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6446
return make_uint4(v.x, v.y, v.z, v.w); 
# 6447
} 
#endif
# 6521 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< float, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6522
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6526
::exit(___);}
#if 0
# 6522
{ 
# 6523
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6525
return v.x; 
# 6526
} 
#endif
# 6528 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLod(texture< float1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6529
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6533
::exit(___);}
#if 0
# 6529
{ 
# 6530
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6532
return make_float1(v.x); 
# 6533
} 
#endif
# 6535 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLod(texture< float2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6536
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6540
::exit(___);}
#if 0
# 6536
{ 
# 6537
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6539
return make_float2(v.x, v.y); 
# 6540
} 
#endif
# 6542 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLod(texture< float4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6543
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6547
::exit(___);}
#if 0
# 6543
{ 
# 6544
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6546
return make_float4(v.x, v.y, v.z, v.w); 
# 6547
} 
#endif
# 6555 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6556
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6565
::exit(___);}
#if 0
# 6556
{ 
# 6560
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6562
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6564
return w.x; 
# 6565
} 
#endif
# 6567 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< signed char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6568
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6573
::exit(___);}
#if 0
# 6568
{ 
# 6569
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6570
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6572
return w.x; 
# 6573
} 
#endif
# 6575 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< unsigned char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6576
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6581
::exit(___);}
#if 0
# 6576
{ 
# 6577
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6578
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6580
return w.x; 
# 6581
} 
#endif
# 6583 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLod(texture< char1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6584
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6589
::exit(___);}
#if 0
# 6584
{ 
# 6585
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6586
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6588
return make_float1(w.x); 
# 6589
} 
#endif
# 6591 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLod(texture< uchar1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6592
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6597
::exit(___);}
#if 0
# 6592
{ 
# 6593
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6594
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6596
return make_float1(w.x); 
# 6597
} 
#endif
# 6599 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLod(texture< char2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6600
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6605
::exit(___);}
#if 0
# 6600
{ 
# 6601
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6602
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6604
return make_float2(w.x, w.y); 
# 6605
} 
#endif
# 6607 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLod(texture< uchar2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6608
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6613
::exit(___);}
#if 0
# 6608
{ 
# 6609
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6610
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6612
return make_float2(w.x, w.y); 
# 6613
} 
#endif
# 6615 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLod(texture< char4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6616
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6621
::exit(___);}
#if 0
# 6616
{ 
# 6617
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6618
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6620
return make_float4(w.x, w.y, w.z, w.w); 
# 6621
} 
#endif
# 6623 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLod(texture< uchar4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6624
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6629
::exit(___);}
#if 0
# 6624
{ 
# 6625
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6626
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6628
return make_float4(w.x, w.y, w.z, w.w); 
# 6629
} 
#endif
# 6637 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6638
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6643
::exit(___);}
#if 0
# 6638
{ 
# 6639
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6640
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6642
return w.x; 
# 6643
} 
#endif
# 6645 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< unsigned short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6646
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6651
::exit(___);}
#if 0
# 6646
{ 
# 6647
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6648
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6650
return w.x; 
# 6651
} 
#endif
# 6653 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLod(texture< short1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6654
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6659
::exit(___);}
#if 0
# 6654
{ 
# 6655
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6656
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6658
return make_float1(w.x); 
# 6659
} 
#endif
# 6661 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLod(texture< ushort1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6662
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6667
::exit(___);}
#if 0
# 6662
{ 
# 6663
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6664
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6666
return make_float1(w.x); 
# 6667
} 
#endif
# 6669 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLod(texture< short2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6670
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6675
::exit(___);}
#if 0
# 6670
{ 
# 6671
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6672
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6674
return make_float2(w.x, w.y); 
# 6675
} 
#endif
# 6677 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLod(texture< ushort2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6678
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6683
::exit(___);}
#if 0
# 6678
{ 
# 6679
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6680
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6682
return make_float2(w.x, w.y); 
# 6683
} 
#endif
# 6685 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLod(texture< short4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6686
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6691
::exit(___);}
#if 0
# 6686
{ 
# 6687
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6688
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6690
return make_float4(w.x, w.y, w.z, w.w); 
# 6691
} 
#endif
# 6693 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLod(texture< ushort4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6694
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6699
::exit(___);}
#if 0
# 6694
{ 
# 6695
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6696
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6698
return make_float4(w.x, w.y, w.z, w.w); 
# 6699
} 
#endif
# 6707 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char texCubemapLayeredLod(texture< char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6708
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6716
::exit(___);}
#if 0
# 6708
{ 
# 6712
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6715
return (char)(v.x); 
# 6716
} 
#endif
# 6718 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char texCubemapLayeredLod(texture< signed char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6719
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6723
::exit(___);}
#if 0
# 6719
{ 
# 6720
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6722
return (signed char)(v.x); 
# 6723
} 
#endif
# 6725 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char texCubemapLayeredLod(texture< unsigned char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6726
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6730
::exit(___);}
#if 0
# 6726
{ 
# 6727
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6729
return (unsigned char)(v.x); 
# 6730
} 
#endif
# 6732 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 texCubemapLayeredLod(texture< char1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6733
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6737
::exit(___);}
#if 0
# 6733
{ 
# 6734
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6736
return make_char1(v.x); 
# 6737
} 
#endif
# 6739 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 texCubemapLayeredLod(texture< uchar1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6740
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6744
::exit(___);}
#if 0
# 6740
{ 
# 6741
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6743
return make_uchar1(v.x); 
# 6744
} 
#endif
# 6746 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 texCubemapLayeredLod(texture< char2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6747
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6751
::exit(___);}
#if 0
# 6747
{ 
# 6748
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6750
return make_char2(v.x, v.y); 
# 6751
} 
#endif
# 6753 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 texCubemapLayeredLod(texture< uchar2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6754
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6758
::exit(___);}
#if 0
# 6754
{ 
# 6755
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6757
return make_uchar2(v.x, v.y); 
# 6758
} 
#endif
# 6760 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 texCubemapLayeredLod(texture< char4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6761
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6765
::exit(___);}
#if 0
# 6761
{ 
# 6762
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6764
return make_char4(v.x, v.y, v.z, v.w); 
# 6765
} 
#endif
# 6767 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 texCubemapLayeredLod(texture< uchar4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6768
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6772
::exit(___);}
#if 0
# 6768
{ 
# 6769
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6771
return make_uchar4(v.x, v.y, v.z, v.w); 
# 6772
} 
#endif
# 6780 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short texCubemapLayeredLod(texture< short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6781
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6785
::exit(___);}
#if 0
# 6781
{ 
# 6782
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6784
return (short)(v.x); 
# 6785
} 
#endif
# 6787 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short texCubemapLayeredLod(texture< unsigned short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6788
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6792
::exit(___);}
#if 0
# 6788
{ 
# 6789
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6791
return (unsigned short)(v.x); 
# 6792
} 
#endif
# 6794 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 texCubemapLayeredLod(texture< short1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6795
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6799
::exit(___);}
#if 0
# 6795
{ 
# 6796
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6798
return make_short1(v.x); 
# 6799
} 
#endif
# 6801 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 texCubemapLayeredLod(texture< ushort1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6802
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6806
::exit(___);}
#if 0
# 6802
{ 
# 6803
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6805
return make_ushort1(v.x); 
# 6806
} 
#endif
# 6808 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 texCubemapLayeredLod(texture< short2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6809
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6813
::exit(___);}
#if 0
# 6809
{ 
# 6810
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6812
return make_short2(v.x, v.y); 
# 6813
} 
#endif
# 6815 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 texCubemapLayeredLod(texture< ushort2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6816
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6820
::exit(___);}
#if 0
# 6816
{ 
# 6817
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6819
return make_ushort2(v.x, v.y); 
# 6820
} 
#endif
# 6822 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 texCubemapLayeredLod(texture< short4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6823
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6827
::exit(___);}
#if 0
# 6823
{ 
# 6824
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6826
return make_short4(v.x, v.y, v.z, v.w); 
# 6827
} 
#endif
# 6829 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 texCubemapLayeredLod(texture< ushort4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6830
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6834
::exit(___);}
#if 0
# 6830
{ 
# 6831
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6833
return make_ushort4(v.x, v.y, v.z, v.w); 
# 6834
} 
#endif
# 6842 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int texCubemapLayeredLod(texture< int, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6847
::exit(___);}
#if 0
# 6843
{ 
# 6844
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6846
return (int)(v.x); 
# 6847
} 
#endif
# 6849 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned texCubemapLayeredLod(texture< unsigned, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6850
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6854
::exit(___);}
#if 0
# 6850
{ 
# 6851
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6853
return (unsigned)(v.x); 
# 6854
} 
#endif
# 6856 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 texCubemapLayeredLod(texture< int1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6857
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6861
::exit(___);}
#if 0
# 6857
{ 
# 6858
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6860
return make_int1(v.x); 
# 6861
} 
#endif
# 6863 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 texCubemapLayeredLod(texture< uint1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6864
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6868
::exit(___);}
#if 0
# 6864
{ 
# 6865
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6867
return make_uint1(v.x); 
# 6868
} 
#endif
# 6870 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 texCubemapLayeredLod(texture< int2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6871
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6875
::exit(___);}
#if 0
# 6871
{ 
# 6872
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6874
return make_int2(v.x, v.y); 
# 6875
} 
#endif
# 6877 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 texCubemapLayeredLod(texture< uint2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6878
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6882
::exit(___);}
#if 0
# 6878
{ 
# 6879
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6881
return make_uint2(v.x, v.y); 
# 6882
} 
#endif
# 6884 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 texCubemapLayeredLod(texture< int4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6885
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6889
::exit(___);}
#if 0
# 6885
{ 
# 6886
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6888
return make_int4(v.x, v.y, v.z, v.w); 
# 6889
} 
#endif
# 6891 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 texCubemapLayeredLod(texture< uint4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6892
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6896
::exit(___);}
#if 0
# 6892
{ 
# 6893
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6895
return make_uint4(v.x, v.y, v.z, v.w); 
# 6896
} 
#endif
# 6970 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< float, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6971
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6975
::exit(___);}
#if 0
# 6971
{ 
# 6972
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6974
return v.x; 
# 6975
} 
#endif
# 6977 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayeredLod(texture< float1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6978
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6982
::exit(___);}
#if 0
# 6978
{ 
# 6979
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6981
return make_float1(v.x); 
# 6982
} 
#endif
# 6984 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayeredLod(texture< float2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6985
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6989
::exit(___);}
#if 0
# 6985
{ 
# 6986
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6988
return make_float2(v.x, v.y); 
# 6989
} 
#endif
# 6991 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayeredLod(texture< float4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6992
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6996
::exit(___);}
#if 0
# 6992
{ 
# 6993
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6995
return make_float4(v.x, v.y, v.z, v.w); 
# 6996
} 
#endif
# 7004 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7005
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7014
::exit(___);}
#if 0
# 7005
{ 
# 7009
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7011
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7013
return w.x; 
# 7014
} 
#endif
# 7016 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< signed char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7017
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7022
::exit(___);}
#if 0
# 7017
{ 
# 7018
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7019
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7021
return w.x; 
# 7022
} 
#endif
# 7024 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< unsigned char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7025
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7030
::exit(___);}
#if 0
# 7025
{ 
# 7026
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7027
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7029
return w.x; 
# 7030
} 
#endif
# 7032 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayeredLod(texture< char1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7033
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7038
::exit(___);}
#if 0
# 7033
{ 
# 7034
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7035
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7037
return make_float1(w.x); 
# 7038
} 
#endif
# 7040 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayeredLod(texture< uchar1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7041
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7046
::exit(___);}
#if 0
# 7041
{ 
# 7042
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7043
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7045
return make_float1(w.x); 
# 7046
} 
#endif
# 7048 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayeredLod(texture< char2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7049
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7054
::exit(___);}
#if 0
# 7049
{ 
# 7050
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7051
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7053
return make_float2(w.x, w.y); 
# 7054
} 
#endif
# 7056 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayeredLod(texture< uchar2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7057
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7062
::exit(___);}
#if 0
# 7057
{ 
# 7058
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7059
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7061
return make_float2(w.x, w.y); 
# 7062
} 
#endif
# 7064 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayeredLod(texture< char4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7065
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7070
::exit(___);}
#if 0
# 7065
{ 
# 7066
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7067
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7069
return make_float4(w.x, w.y, w.z, w.w); 
# 7070
} 
#endif
# 7072 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayeredLod(texture< uchar4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7073
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7078
::exit(___);}
#if 0
# 7073
{ 
# 7074
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7075
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7077
return make_float4(w.x, w.y, w.z, w.w); 
# 7078
} 
#endif
# 7086 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7087
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7092
::exit(___);}
#if 0
# 7087
{ 
# 7088
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7089
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7091
return w.x; 
# 7092
} 
#endif
# 7094 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< unsigned short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7095
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7100
::exit(___);}
#if 0
# 7095
{ 
# 7096
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7097
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7099
return w.x; 
# 7100
} 
#endif
# 7102 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayeredLod(texture< short1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7103
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7108
::exit(___);}
#if 0
# 7103
{ 
# 7104
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7105
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7107
return make_float1(w.x); 
# 7108
} 
#endif
# 7110 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayeredLod(texture< ushort1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7111
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7116
::exit(___);}
#if 0
# 7111
{ 
# 7112
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7113
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7115
return make_float1(w.x); 
# 7116
} 
#endif
# 7118 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayeredLod(texture< short2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7119
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7124
::exit(___);}
#if 0
# 7119
{ 
# 7120
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7121
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7123
return make_float2(w.x, w.y); 
# 7124
} 
#endif
# 7126 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayeredLod(texture< ushort2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7127
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7132
::exit(___);}
#if 0
# 7127
{ 
# 7128
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7129
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7131
return make_float2(w.x, w.y); 
# 7132
} 
#endif
# 7134 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayeredLod(texture< short4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7135
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7140
::exit(___);}
#if 0
# 7135
{ 
# 7136
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7137
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7139
return make_float4(w.x, w.y, w.z, w.w); 
# 7140
} 
#endif
# 7142 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayeredLod(texture< ushort4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7143
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7148
::exit(___);}
#if 0
# 7143
{ 
# 7144
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7145
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7147
return make_float4(w.x, w.y, w.z, w.w); 
# 7148
} 
#endif
# 7157 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex1DGrad(texture< char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7158
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7166
::exit(___);}
#if 0
# 7158
{ 
# 7162
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7165
return (char)(v.x); 
# 7166
} 
#endif
# 7168 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1DGrad(texture< signed char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7169
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7173
::exit(___);}
#if 0
# 7169
{ 
# 7170
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7172
return (signed char)(v.x); 
# 7173
} 
#endif
# 7175 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1DGrad(texture< unsigned char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7176
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7180
::exit(___);}
#if 0
# 7176
{ 
# 7177
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7179
return (unsigned char)(v.x); 
# 7180
} 
#endif
# 7182 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1DGrad(texture< char1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7183
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7187
::exit(___);}
#if 0
# 7183
{ 
# 7184
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7186
return make_char1(v.x); 
# 7187
} 
#endif
# 7189 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1DGrad(texture< uchar1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7190
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7194
::exit(___);}
#if 0
# 7190
{ 
# 7191
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7193
return make_uchar1(v.x); 
# 7194
} 
#endif
# 7196 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1DGrad(texture< char2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7197
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7201
::exit(___);}
#if 0
# 7197
{ 
# 7198
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7200
return make_char2(v.x, v.y); 
# 7201
} 
#endif
# 7203 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1DGrad(texture< uchar2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7204
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7208
::exit(___);}
#if 0
# 7204
{ 
# 7205
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7207
return make_uchar2(v.x, v.y); 
# 7208
} 
#endif
# 7210 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1DGrad(texture< char4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7211
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7215
::exit(___);}
#if 0
# 7211
{ 
# 7212
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7214
return make_char4(v.x, v.y, v.z, v.w); 
# 7215
} 
#endif
# 7217 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1DGrad(texture< uchar4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7218
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7222
::exit(___);}
#if 0
# 7218
{ 
# 7219
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7221
return make_uchar4(v.x, v.y, v.z, v.w); 
# 7222
} 
#endif
# 7230 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex1DGrad(texture< short, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7231
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7235
::exit(___);}
#if 0
# 7231
{ 
# 7232
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7234
return (short)(v.x); 
# 7235
} 
#endif
# 7237 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1DGrad(texture< unsigned short, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7238
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7242
::exit(___);}
#if 0
# 7238
{ 
# 7239
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7241
return (unsigned short)(v.x); 
# 7242
} 
#endif
# 7244 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1DGrad(texture< short1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7245
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7249
::exit(___);}
#if 0
# 7245
{ 
# 7246
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7248
return make_short1(v.x); 
# 7249
} 
#endif
# 7251 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1DGrad(texture< ushort1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7252
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7256
::exit(___);}
#if 0
# 7252
{ 
# 7253
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7255
return make_ushort1(v.x); 
# 7256
} 
#endif
# 7258 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1DGrad(texture< short2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7259
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7263
::exit(___);}
#if 0
# 7259
{ 
# 7260
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7262
return make_short2(v.x, v.y); 
# 7263
} 
#endif
# 7265 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1DGrad(texture< ushort2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7266
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7270
::exit(___);}
#if 0
# 7266
{ 
# 7267
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7269
return make_ushort2(v.x, v.y); 
# 7270
} 
#endif
# 7272 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1DGrad(texture< short4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7273
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7277
::exit(___);}
#if 0
# 7273
{ 
# 7274
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7276
return make_short4(v.x, v.y, v.z, v.w); 
# 7277
} 
#endif
# 7279 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1DGrad(texture< ushort4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7280
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7284
::exit(___);}
#if 0
# 7280
{ 
# 7281
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7283
return make_ushort4(v.x, v.y, v.z, v.w); 
# 7284
} 
#endif
# 7292 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex1DGrad(texture< int, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7293
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7297
::exit(___);}
#if 0
# 7293
{ 
# 7294
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7296
return (int)(v.x); 
# 7297
} 
#endif
# 7299 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1DGrad(texture< unsigned, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7300
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7304
::exit(___);}
#if 0
# 7300
{ 
# 7301
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7303
return (unsigned)(v.x); 
# 7304
} 
#endif
# 7306 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1DGrad(texture< int1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7307
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7311
::exit(___);}
#if 0
# 7307
{ 
# 7308
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7310
return make_int1(v.x); 
# 7311
} 
#endif
# 7313 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1DGrad(texture< uint1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7314
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7318
::exit(___);}
#if 0
# 7314
{ 
# 7315
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7317
return make_uint1(v.x); 
# 7318
} 
#endif
# 7320 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1DGrad(texture< int2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7321
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7325
::exit(___);}
#if 0
# 7321
{ 
# 7322
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7324
return make_int2(v.x, v.y); 
# 7325
} 
#endif
# 7327 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1DGrad(texture< uint2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7328
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7332
::exit(___);}
#if 0
# 7328
{ 
# 7329
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7331
return make_uint2(v.x, v.y); 
# 7332
} 
#endif
# 7334 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1DGrad(texture< int4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7335
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7339
::exit(___);}
#if 0
# 7335
{ 
# 7336
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7338
return make_int4(v.x, v.y, v.z, v.w); 
# 7339
} 
#endif
# 7341 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1DGrad(texture< uint4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7342
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7346
::exit(___);}
#if 0
# 7342
{ 
# 7343
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7345
return make_uint4(v.x, v.y, v.z, v.w); 
# 7346
} 
#endif
# 7426 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< float, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7427
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7431
::exit(___);}
#if 0
# 7427
{ 
# 7428
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7430
return v.x; 
# 7431
} 
#endif
# 7433 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DGrad(texture< float1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7434
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7438
::exit(___);}
#if 0
# 7434
{ 
# 7435
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7437
return make_float1(v.x); 
# 7438
} 
#endif
# 7440 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DGrad(texture< float2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7441
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7445
::exit(___);}
#if 0
# 7441
{ 
# 7442
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7444
return make_float2(v.x, v.y); 
# 7445
} 
#endif
# 7447 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DGrad(texture< float4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7448
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7452
::exit(___);}
#if 0
# 7448
{ 
# 7449
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7451
return make_float4(v.x, v.y, v.z, v.w); 
# 7452
} 
#endif
# 7460 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7461
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7470
::exit(___);}
#if 0
# 7461
{ 
# 7465
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7467
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7469
return w.x; 
# 7470
} 
#endif
# 7472 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7473
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7478
::exit(___);}
#if 0
# 7473
{ 
# 7474
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7475
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7477
return w.x; 
# 7478
} 
#endif
# 7480 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7481
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7486
::exit(___);}
#if 0
# 7481
{ 
# 7482
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7483
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7485
return w.x; 
# 7486
} 
#endif
# 7488 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DGrad(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7489
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7494
::exit(___);}
#if 0
# 7489
{ 
# 7490
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7491
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7493
return make_float1(w.x); 
# 7494
} 
#endif
# 7496 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DGrad(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7497
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7502
::exit(___);}
#if 0
# 7497
{ 
# 7498
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7499
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7501
return make_float1(w.x); 
# 7502
} 
#endif
# 7504 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DGrad(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7505
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7510
::exit(___);}
#if 0
# 7505
{ 
# 7506
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7507
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7509
return make_float2(w.x, w.y); 
# 7510
} 
#endif
# 7512 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DGrad(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7513
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7518
::exit(___);}
#if 0
# 7513
{ 
# 7514
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7515
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7517
return make_float2(w.x, w.y); 
# 7518
} 
#endif
# 7520 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DGrad(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7521
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7526
::exit(___);}
#if 0
# 7521
{ 
# 7522
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7523
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7525
return make_float4(w.x, w.y, w.z, w.w); 
# 7526
} 
#endif
# 7528 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DGrad(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7529
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7534
::exit(___);}
#if 0
# 7529
{ 
# 7530
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7531
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7533
return make_float4(w.x, w.y, w.z, w.w); 
# 7534
} 
#endif
# 7542 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7543
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7548
::exit(___);}
#if 0
# 7543
{ 
# 7544
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7545
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7547
return w.x; 
# 7548
} 
#endif
# 7550 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7551
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7556
::exit(___);}
#if 0
# 7551
{ 
# 7552
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7553
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7555
return w.x; 
# 7556
} 
#endif
# 7558 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DGrad(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7559
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7564
::exit(___);}
#if 0
# 7559
{ 
# 7560
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7561
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7563
return make_float1(w.x); 
# 7564
} 
#endif
# 7566 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DGrad(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7567
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7572
::exit(___);}
#if 0
# 7567
{ 
# 7568
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7569
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7571
return make_float1(w.x); 
# 7572
} 
#endif
# 7574 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DGrad(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7575
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7580
::exit(___);}
#if 0
# 7575
{ 
# 7576
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7577
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7579
return make_float2(w.x, w.y); 
# 7580
} 
#endif
# 7582 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DGrad(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7583
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7588
::exit(___);}
#if 0
# 7583
{ 
# 7584
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7585
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7587
return make_float2(w.x, w.y); 
# 7588
} 
#endif
# 7590 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DGrad(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7591
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7596
::exit(___);}
#if 0
# 7591
{ 
# 7592
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7593
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7595
return make_float4(w.x, w.y, w.z, w.w); 
# 7596
} 
#endif
# 7598 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DGrad(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7599
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7604
::exit(___);}
#if 0
# 7599
{ 
# 7600
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7601
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7603
return make_float4(w.x, w.y, w.z, w.w); 
# 7604
} 
#endif
# 7612 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex2DGrad(texture< char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7613
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7621
::exit(___);}
#if 0
# 7613
{ 
# 7617
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7620
return (char)(v.x); 
# 7621
} 
#endif
# 7623 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2DGrad(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7624
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7628
::exit(___);}
#if 0
# 7624
{ 
# 7625
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7627
return (signed char)(v.x); 
# 7628
} 
#endif
# 7630 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2DGrad(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7631
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7635
::exit(___);}
#if 0
# 7631
{ 
# 7632
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7634
return (unsigned char)(v.x); 
# 7635
} 
#endif
# 7637 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2DGrad(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7638
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7642
::exit(___);}
#if 0
# 7638
{ 
# 7639
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7641
return make_char1(v.x); 
# 7642
} 
#endif
# 7644 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2DGrad(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7645
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7649
::exit(___);}
#if 0
# 7645
{ 
# 7646
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7648
return make_uchar1(v.x); 
# 7649
} 
#endif
# 7651 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2DGrad(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7652
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7656
::exit(___);}
#if 0
# 7652
{ 
# 7653
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7655
return make_char2(v.x, v.y); 
# 7656
} 
#endif
# 7658 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2DGrad(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7659
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7663
::exit(___);}
#if 0
# 7659
{ 
# 7660
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7662
return make_uchar2(v.x, v.y); 
# 7663
} 
#endif
# 7665 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2DGrad(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7666
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7670
::exit(___);}
#if 0
# 7666
{ 
# 7667
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7669
return make_char4(v.x, v.y, v.z, v.w); 
# 7670
} 
#endif
# 7672 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2DGrad(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7673
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7677
::exit(___);}
#if 0
# 7673
{ 
# 7674
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7676
return make_uchar4(v.x, v.y, v.z, v.w); 
# 7677
} 
#endif
# 7685 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex2DGrad(texture< short, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7686
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7690
::exit(___);}
#if 0
# 7686
{ 
# 7687
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7689
return (short)(v.x); 
# 7690
} 
#endif
# 7692 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2DGrad(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7693
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7697
::exit(___);}
#if 0
# 7693
{ 
# 7694
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7696
return (unsigned short)(v.x); 
# 7697
} 
#endif
# 7699 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2DGrad(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7700
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7704
::exit(___);}
#if 0
# 7700
{ 
# 7701
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7703
return make_short1(v.x); 
# 7704
} 
#endif
# 7706 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2DGrad(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7707
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7711
::exit(___);}
#if 0
# 7707
{ 
# 7708
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7710
return make_ushort1(v.x); 
# 7711
} 
#endif
# 7713 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2DGrad(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7714
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7718
::exit(___);}
#if 0
# 7714
{ 
# 7715
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7717
return make_short2(v.x, v.y); 
# 7718
} 
#endif
# 7720 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2DGrad(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7721
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7725
::exit(___);}
#if 0
# 7721
{ 
# 7722
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7724
return make_ushort2(v.x, v.y); 
# 7725
} 
#endif
# 7727 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2DGrad(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7728
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7732
::exit(___);}
#if 0
# 7728
{ 
# 7729
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7731
return make_short4(v.x, v.y, v.z, v.w); 
# 7732
} 
#endif
# 7734 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2DGrad(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7735
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7739
::exit(___);}
#if 0
# 7735
{ 
# 7736
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7738
return make_ushort4(v.x, v.y, v.z, v.w); 
# 7739
} 
#endif
# 7747 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex2DGrad(texture< int, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7748
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7752
::exit(___);}
#if 0
# 7748
{ 
# 7749
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7751
return (int)(v.x); 
# 7752
} 
#endif
# 7754 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2DGrad(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7755
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7759
::exit(___);}
#if 0
# 7755
{ 
# 7756
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7758
return (unsigned)(v.x); 
# 7759
} 
#endif
# 7761 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2DGrad(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7762
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7766
::exit(___);}
#if 0
# 7762
{ 
# 7763
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7765
return make_int1(v.x); 
# 7766
} 
#endif
# 7768 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2DGrad(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7769
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7773
::exit(___);}
#if 0
# 7769
{ 
# 7770
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7772
return make_uint1(v.x); 
# 7773
} 
#endif
# 7775 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2DGrad(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7776
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7780
::exit(___);}
#if 0
# 7776
{ 
# 7777
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7779
return make_int2(v.x, v.y); 
# 7780
} 
#endif
# 7782 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2DGrad(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7783
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7787
::exit(___);}
#if 0
# 7783
{ 
# 7784
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7786
return make_uint2(v.x, v.y); 
# 7787
} 
#endif
# 7789 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2DGrad(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7790
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7794
::exit(___);}
#if 0
# 7790
{ 
# 7791
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7793
return make_int4(v.x, v.y, v.z, v.w); 
# 7794
} 
#endif
# 7796 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2DGrad(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7797
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7801
::exit(___);}
#if 0
# 7797
{ 
# 7798
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7800
return make_uint4(v.x, v.y, v.z, v.w); 
# 7801
} 
#endif
# 7875 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< float, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7876
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7880
::exit(___);}
#if 0
# 7876
{ 
# 7877
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7879
return v.x; 
# 7880
} 
#endif
# 7882 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DGrad(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7883
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7887
::exit(___);}
#if 0
# 7883
{ 
# 7884
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7886
return make_float1(v.x); 
# 7887
} 
#endif
# 7889 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DGrad(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7890
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7894
::exit(___);}
#if 0
# 7890
{ 
# 7891
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7893
return make_float2(v.x, v.y); 
# 7894
} 
#endif
# 7896 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DGrad(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7897
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7901
::exit(___);}
#if 0
# 7897
{ 
# 7898
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7900
return make_float4(v.x, v.y, v.z, v.w); 
# 7901
} 
#endif
# 7909 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7910
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7919
::exit(___);}
#if 0
# 7910
{ 
# 7914
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7916
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7918
return w.x; 
# 7919
} 
#endif
# 7921 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7922
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7927
::exit(___);}
#if 0
# 7922
{ 
# 7923
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7924
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7926
return w.x; 
# 7927
} 
#endif
# 7929 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7930
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7935
::exit(___);}
#if 0
# 7930
{ 
# 7931
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7932
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7934
return w.x; 
# 7935
} 
#endif
# 7937 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DGrad(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7938
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7943
::exit(___);}
#if 0
# 7938
{ 
# 7939
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7940
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7942
return make_float1(w.x); 
# 7943
} 
#endif
# 7945 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DGrad(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7946
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7951
::exit(___);}
#if 0
# 7946
{ 
# 7947
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7948
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7950
return make_float1(w.x); 
# 7951
} 
#endif
# 7953 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DGrad(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7954
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7959
::exit(___);}
#if 0
# 7954
{ 
# 7955
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7956
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7958
return make_float2(w.x, w.y); 
# 7959
} 
#endif
# 7961 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DGrad(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7962
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7967
::exit(___);}
#if 0
# 7962
{ 
# 7963
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7964
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7966
return make_float2(w.x, w.y); 
# 7967
} 
#endif
# 7969 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DGrad(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7970
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7975
::exit(___);}
#if 0
# 7970
{ 
# 7971
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7972
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7974
return make_float4(w.x, w.y, w.z, w.w); 
# 7975
} 
#endif
# 7977 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DGrad(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7978
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7983
::exit(___);}
#if 0
# 7978
{ 
# 7979
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7980
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7982
return make_float4(w.x, w.y, w.z, w.w); 
# 7983
} 
#endif
# 7991 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7992
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7997
::exit(___);}
#if 0
# 7992
{ 
# 7993
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7994
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7996
return w.x; 
# 7997
} 
#endif
# 7999 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8005
::exit(___);}
#if 0
# 8000
{ 
# 8001
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8002
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8004
return w.x; 
# 8005
} 
#endif
# 8007 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DGrad(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8008
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8013
::exit(___);}
#if 0
# 8008
{ 
# 8009
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8010
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8012
return make_float1(w.x); 
# 8013
} 
#endif
# 8015 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DGrad(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8016
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8021
::exit(___);}
#if 0
# 8016
{ 
# 8017
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8018
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8020
return make_float1(w.x); 
# 8021
} 
#endif
# 8023 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DGrad(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8024
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8029
::exit(___);}
#if 0
# 8024
{ 
# 8025
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8026
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8028
return make_float2(w.x, w.y); 
# 8029
} 
#endif
# 8031 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DGrad(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8032
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8037
::exit(___);}
#if 0
# 8032
{ 
# 8033
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8034
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8036
return make_float2(w.x, w.y); 
# 8037
} 
#endif
# 8039 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DGrad(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8040
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8045
::exit(___);}
#if 0
# 8040
{ 
# 8041
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8042
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8044
return make_float4(w.x, w.y, w.z, w.w); 
# 8045
} 
#endif
# 8047 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DGrad(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8048
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8053
::exit(___);}
#if 0
# 8048
{ 
# 8049
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8050
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8052
return make_float4(w.x, w.y, w.z, w.w); 
# 8053
} 
#endif
# 8061 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex1DLayeredGrad(texture< char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8062
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8070
::exit(___);}
#if 0
# 8062
{ 
# 8066
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8069
return (char)(v.x); 
# 8070
} 
#endif
# 8072 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1DLayeredGrad(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8073
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8077
::exit(___);}
#if 0
# 8073
{ 
# 8074
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8076
return (signed char)(v.x); 
# 8077
} 
#endif
# 8079 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1DLayeredGrad(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8080
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8084
::exit(___);}
#if 0
# 8080
{ 
# 8081
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8083
return (unsigned char)(v.x); 
# 8084
} 
#endif
# 8086 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1DLayeredGrad(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8087
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8091
::exit(___);}
#if 0
# 8087
{ 
# 8088
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8090
return make_char1(v.x); 
# 8091
} 
#endif
# 8093 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1DLayeredGrad(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8094
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8098
::exit(___);}
#if 0
# 8094
{ 
# 8095
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8097
return make_uchar1(v.x); 
# 8098
} 
#endif
# 8100 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1DLayeredGrad(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8101
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8105
::exit(___);}
#if 0
# 8101
{ 
# 8102
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8104
return make_char2(v.x, v.y); 
# 8105
} 
#endif
# 8107 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1DLayeredGrad(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8108
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8112
::exit(___);}
#if 0
# 8108
{ 
# 8109
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8111
return make_uchar2(v.x, v.y); 
# 8112
} 
#endif
# 8114 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1DLayeredGrad(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8115
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8119
::exit(___);}
#if 0
# 8115
{ 
# 8116
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8118
return make_char4(v.x, v.y, v.z, v.w); 
# 8119
} 
#endif
# 8121 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1DLayeredGrad(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8122
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8126
::exit(___);}
#if 0
# 8122
{ 
# 8123
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8125
return make_uchar4(v.x, v.y, v.z, v.w); 
# 8126
} 
#endif
# 8134 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex1DLayeredGrad(texture< short, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8135
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8139
::exit(___);}
#if 0
# 8135
{ 
# 8136
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8138
return (short)(v.x); 
# 8139
} 
#endif
# 8141 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1DLayeredGrad(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8142
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8146
::exit(___);}
#if 0
# 8142
{ 
# 8143
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8145
return (unsigned short)(v.x); 
# 8146
} 
#endif
# 8148 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1DLayeredGrad(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8149
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8153
::exit(___);}
#if 0
# 8149
{ 
# 8150
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8152
return make_short1(v.x); 
# 8153
} 
#endif
# 8155 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1DLayeredGrad(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8156
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8160
::exit(___);}
#if 0
# 8156
{ 
# 8157
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8159
return make_ushort1(v.x); 
# 8160
} 
#endif
# 8162 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1DLayeredGrad(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8163
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8167
::exit(___);}
#if 0
# 8163
{ 
# 8164
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8166
return make_short2(v.x, v.y); 
# 8167
} 
#endif
# 8169 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1DLayeredGrad(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8170
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8174
::exit(___);}
#if 0
# 8170
{ 
# 8171
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8173
return make_ushort2(v.x, v.y); 
# 8174
} 
#endif
# 8176 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1DLayeredGrad(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8177
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8181
::exit(___);}
#if 0
# 8177
{ 
# 8178
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8180
return make_short4(v.x, v.y, v.z, v.w); 
# 8181
} 
#endif
# 8183 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1DLayeredGrad(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8184
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8188
::exit(___);}
#if 0
# 8184
{ 
# 8185
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8187
return make_ushort4(v.x, v.y, v.z, v.w); 
# 8188
} 
#endif
# 8196 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex1DLayeredGrad(texture< int, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8197
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8201
::exit(___);}
#if 0
# 8197
{ 
# 8198
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8200
return (int)(v.x); 
# 8201
} 
#endif
# 8203 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1DLayeredGrad(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8204
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8208
::exit(___);}
#if 0
# 8204
{ 
# 8205
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8207
return (unsigned)(v.x); 
# 8208
} 
#endif
# 8210 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1DLayeredGrad(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8211
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8215
::exit(___);}
#if 0
# 8211
{ 
# 8212
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8214
return make_int1(v.x); 
# 8215
} 
#endif
# 8217 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1DLayeredGrad(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8218
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8222
::exit(___);}
#if 0
# 8218
{ 
# 8219
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8221
return make_uint1(v.x); 
# 8222
} 
#endif
# 8224 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1DLayeredGrad(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8225
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8229
::exit(___);}
#if 0
# 8225
{ 
# 8226
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8228
return make_int2(v.x, v.y); 
# 8229
} 
#endif
# 8231 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1DLayeredGrad(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8232
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8236
::exit(___);}
#if 0
# 8232
{ 
# 8233
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8235
return make_uint2(v.x, v.y); 
# 8236
} 
#endif
# 8238 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1DLayeredGrad(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8239
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8243
::exit(___);}
#if 0
# 8239
{ 
# 8240
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8242
return make_int4(v.x, v.y, v.z, v.w); 
# 8243
} 
#endif
# 8245 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1DLayeredGrad(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8246
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8250
::exit(___);}
#if 0
# 8246
{ 
# 8247
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8249
return make_uint4(v.x, v.y, v.z, v.w); 
# 8250
} 
#endif
# 8324 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< float, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8325
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8329
::exit(___);}
#if 0
# 8325
{ 
# 8326
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8328
return v.x; 
# 8329
} 
#endif
# 8331 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredGrad(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8332
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8336
::exit(___);}
#if 0
# 8332
{ 
# 8333
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8335
return make_float1(v.x); 
# 8336
} 
#endif
# 8338 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredGrad(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8339
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8343
::exit(___);}
#if 0
# 8339
{ 
# 8340
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8342
return make_float2(v.x, v.y); 
# 8343
} 
#endif
# 8345 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredGrad(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8346
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8350
::exit(___);}
#if 0
# 8346
{ 
# 8347
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8349
return make_float4(v.x, v.y, v.z, v.w); 
# 8350
} 
#endif
# 8358 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8359
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8368
::exit(___);}
#if 0
# 8359
{ 
# 8363
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8365
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8367
return w.x; 
# 8368
} 
#endif
# 8370 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8371
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8376
::exit(___);}
#if 0
# 8371
{ 
# 8372
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8373
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8375
return w.x; 
# 8376
} 
#endif
# 8378 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8379
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8384
::exit(___);}
#if 0
# 8379
{ 
# 8380
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8381
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8383
return w.x; 
# 8384
} 
#endif
# 8386 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredGrad(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8387
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8392
::exit(___);}
#if 0
# 8387
{ 
# 8388
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8389
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8391
return make_float1(w.x); 
# 8392
} 
#endif
# 8394 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredGrad(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8395
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8400
::exit(___);}
#if 0
# 8395
{ 
# 8396
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8397
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8399
return make_float1(w.x); 
# 8400
} 
#endif
# 8402 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredGrad(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8403
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8408
::exit(___);}
#if 0
# 8403
{ 
# 8404
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8405
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8407
return make_float2(w.x, w.y); 
# 8408
} 
#endif
# 8410 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredGrad(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8411
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8416
::exit(___);}
#if 0
# 8411
{ 
# 8412
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8413
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8415
return make_float2(w.x, w.y); 
# 8416
} 
#endif
# 8418 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredGrad(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8419
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8424
::exit(___);}
#if 0
# 8419
{ 
# 8420
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8421
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8423
return make_float4(w.x, w.y, w.z, w.w); 
# 8424
} 
#endif
# 8426 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredGrad(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8427
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8432
::exit(___);}
#if 0
# 8427
{ 
# 8428
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8429
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8431
return make_float4(w.x, w.y, w.z, w.w); 
# 8432
} 
#endif
# 8440 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8441
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8446
::exit(___);}
#if 0
# 8441
{ 
# 8442
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8443
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8445
return w.x; 
# 8446
} 
#endif
# 8448 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8449
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8454
::exit(___);}
#if 0
# 8449
{ 
# 8450
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8451
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8453
return w.x; 
# 8454
} 
#endif
# 8456 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredGrad(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8457
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8462
::exit(___);}
#if 0
# 8457
{ 
# 8458
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8459
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8461
return make_float1(w.x); 
# 8462
} 
#endif
# 8464 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredGrad(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8465
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8470
::exit(___);}
#if 0
# 8465
{ 
# 8466
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8467
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8469
return make_float1(w.x); 
# 8470
} 
#endif
# 8472 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredGrad(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8473
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8478
::exit(___);}
#if 0
# 8473
{ 
# 8474
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8475
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8477
return make_float2(w.x, w.y); 
# 8478
} 
#endif
# 8480 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredGrad(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8481
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8486
::exit(___);}
#if 0
# 8481
{ 
# 8482
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8483
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8485
return make_float2(w.x, w.y); 
# 8486
} 
#endif
# 8488 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredGrad(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8489
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8494
::exit(___);}
#if 0
# 8489
{ 
# 8490
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8491
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8493
return make_float4(w.x, w.y, w.z, w.w); 
# 8494
} 
#endif
# 8496 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredGrad(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8497
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8502
::exit(___);}
#if 0
# 8497
{ 
# 8498
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8499
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8501
return make_float4(w.x, w.y, w.z, w.w); 
# 8502
} 
#endif
# 8510 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex2DLayeredGrad(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8511
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8519
::exit(___);}
#if 0
# 8511
{ 
# 8515
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8518
return (char)(v.x); 
# 8519
} 
#endif
# 8521 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2DLayeredGrad(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8522
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8526
::exit(___);}
#if 0
# 8522
{ 
# 8523
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8525
return (signed char)(v.x); 
# 8526
} 
#endif
# 8528 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2DLayeredGrad(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8529
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8533
::exit(___);}
#if 0
# 8529
{ 
# 8530
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8532
return (unsigned char)(v.x); 
# 8533
} 
#endif
# 8535 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2DLayeredGrad(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8536
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8540
::exit(___);}
#if 0
# 8536
{ 
# 8537
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8539
return make_char1(v.x); 
# 8540
} 
#endif
# 8542 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2DLayeredGrad(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8543
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8547
::exit(___);}
#if 0
# 8543
{ 
# 8544
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8546
return make_uchar1(v.x); 
# 8547
} 
#endif
# 8549 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2DLayeredGrad(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8550
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8554
::exit(___);}
#if 0
# 8550
{ 
# 8551
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8553
return make_char2(v.x, v.y); 
# 8554
} 
#endif
# 8556 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2DLayeredGrad(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8557
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8561
::exit(___);}
#if 0
# 8557
{ 
# 8558
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8560
return make_uchar2(v.x, v.y); 
# 8561
} 
#endif
# 8563 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2DLayeredGrad(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8564
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8568
::exit(___);}
#if 0
# 8564
{ 
# 8565
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8567
return make_char4(v.x, v.y, v.z, v.w); 
# 8568
} 
#endif
# 8570 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2DLayeredGrad(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8571
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8575
::exit(___);}
#if 0
# 8571
{ 
# 8572
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8574
return make_uchar4(v.x, v.y, v.z, v.w); 
# 8575
} 
#endif
# 8583 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex2DLayeredGrad(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8584
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8588
::exit(___);}
#if 0
# 8584
{ 
# 8585
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8587
return (short)(v.x); 
# 8588
} 
#endif
# 8590 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2DLayeredGrad(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8591
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8595
::exit(___);}
#if 0
# 8591
{ 
# 8592
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8594
return (unsigned short)(v.x); 
# 8595
} 
#endif
# 8597 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2DLayeredGrad(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8598
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8602
::exit(___);}
#if 0
# 8598
{ 
# 8599
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8601
return make_short1(v.x); 
# 8602
} 
#endif
# 8604 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2DLayeredGrad(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8605
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8609
::exit(___);}
#if 0
# 8605
{ 
# 8606
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8608
return make_ushort1(v.x); 
# 8609
} 
#endif
# 8611 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2DLayeredGrad(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8612
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8616
::exit(___);}
#if 0
# 8612
{ 
# 8613
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8615
return make_short2(v.x, v.y); 
# 8616
} 
#endif
# 8618 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2DLayeredGrad(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8619
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8623
::exit(___);}
#if 0
# 8619
{ 
# 8620
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8622
return make_ushort2(v.x, v.y); 
# 8623
} 
#endif
# 8625 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2DLayeredGrad(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8626
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8630
::exit(___);}
#if 0
# 8626
{ 
# 8627
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8629
return make_short4(v.x, v.y, v.z, v.w); 
# 8630
} 
#endif
# 8632 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2DLayeredGrad(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8633
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8637
::exit(___);}
#if 0
# 8633
{ 
# 8634
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8636
return make_ushort4(v.x, v.y, v.z, v.w); 
# 8637
} 
#endif
# 8645 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex2DLayeredGrad(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8646
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8650
::exit(___);}
#if 0
# 8646
{ 
# 8647
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8649
return (int)(v.x); 
# 8650
} 
#endif
# 8652 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2DLayeredGrad(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8653
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8657
::exit(___);}
#if 0
# 8653
{ 
# 8654
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8656
return (unsigned)(v.x); 
# 8657
} 
#endif
# 8659 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2DLayeredGrad(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8660
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8664
::exit(___);}
#if 0
# 8660
{ 
# 8661
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8663
return make_int1(v.x); 
# 8664
} 
#endif
# 8666 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2DLayeredGrad(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8667
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8671
::exit(___);}
#if 0
# 8667
{ 
# 8668
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8670
return make_uint1(v.x); 
# 8671
} 
#endif
# 8673 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2DLayeredGrad(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8674
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8678
::exit(___);}
#if 0
# 8674
{ 
# 8675
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8677
return make_int2(v.x, v.y); 
# 8678
} 
#endif
# 8680 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2DLayeredGrad(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8685
::exit(___);}
#if 0
# 8681
{ 
# 8682
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8684
return make_uint2(v.x, v.y); 
# 8685
} 
#endif
# 8687 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2DLayeredGrad(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8688
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8692
::exit(___);}
#if 0
# 8688
{ 
# 8689
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8691
return make_int4(v.x, v.y, v.z, v.w); 
# 8692
} 
#endif
# 8694 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2DLayeredGrad(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8695
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8699
::exit(___);}
#if 0
# 8695
{ 
# 8696
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8698
return make_uint4(v.x, v.y, v.z, v.w); 
# 8699
} 
#endif
# 8773 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8774
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8778
::exit(___);}
#if 0
# 8774
{ 
# 8775
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8777
return v.x; 
# 8778
} 
#endif
# 8780 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredGrad(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8781
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8785
::exit(___);}
#if 0
# 8781
{ 
# 8782
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8784
return make_float1(v.x); 
# 8785
} 
#endif
# 8787 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredGrad(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8788
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8792
::exit(___);}
#if 0
# 8788
{ 
# 8789
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8791
return make_float2(v.x, v.y); 
# 8792
} 
#endif
# 8794 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredGrad(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8795
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8799
::exit(___);}
#if 0
# 8795
{ 
# 8796
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8798
return make_float4(v.x, v.y, v.z, v.w); 
# 8799
} 
#endif
# 8807 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8808
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8817
::exit(___);}
#if 0
# 8808
{ 
# 8812
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8814
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8816
return w.x; 
# 8817
} 
#endif
# 8819 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8820
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8825
::exit(___);}
#if 0
# 8820
{ 
# 8821
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8822
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8824
return w.x; 
# 8825
} 
#endif
# 8827 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8828
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8833
::exit(___);}
#if 0
# 8828
{ 
# 8829
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8830
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8832
return w.x; 
# 8833
} 
#endif
# 8835 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredGrad(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8836
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8841
::exit(___);}
#if 0
# 8836
{ 
# 8837
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8838
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8840
return make_float1(w.x); 
# 8841
} 
#endif
# 8843 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredGrad(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8844
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8849
::exit(___);}
#if 0
# 8844
{ 
# 8845
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8846
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8848
return make_float1(w.x); 
# 8849
} 
#endif
# 8851 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredGrad(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8852
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8857
::exit(___);}
#if 0
# 8852
{ 
# 8853
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8854
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8856
return make_float2(w.x, w.y); 
# 8857
} 
#endif
# 8859 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredGrad(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8860
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8865
::exit(___);}
#if 0
# 8860
{ 
# 8861
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8862
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8864
return make_float2(w.x, w.y); 
# 8865
} 
#endif
# 8867 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredGrad(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8868
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8873
::exit(___);}
#if 0
# 8868
{ 
# 8869
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8870
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8872
return make_float4(w.x, w.y, w.z, w.w); 
# 8873
} 
#endif
# 8875 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredGrad(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8876
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8881
::exit(___);}
#if 0
# 8876
{ 
# 8877
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8878
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8880
return make_float4(w.x, w.y, w.z, w.w); 
# 8881
} 
#endif
# 8889 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8890
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8895
::exit(___);}
#if 0
# 8890
{ 
# 8891
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8892
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8894
return w.x; 
# 8895
} 
#endif
# 8897 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8903
::exit(___);}
#if 0
# 8898
{ 
# 8899
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8900
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8902
return w.x; 
# 8903
} 
#endif
# 8905 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredGrad(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8906
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8911
::exit(___);}
#if 0
# 8906
{ 
# 8907
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8908
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8910
return make_float1(w.x); 
# 8911
} 
#endif
# 8913 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredGrad(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8914
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8919
::exit(___);}
#if 0
# 8914
{ 
# 8915
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8916
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8918
return make_float1(w.x); 
# 8919
} 
#endif
# 8921 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredGrad(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8922
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8927
::exit(___);}
#if 0
# 8922
{ 
# 8923
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8924
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8926
return make_float2(w.x, w.y); 
# 8927
} 
#endif
# 8929 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredGrad(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8930
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8935
::exit(___);}
#if 0
# 8930
{ 
# 8931
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8932
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8934
return make_float2(w.x, w.y); 
# 8935
} 
#endif
# 8937 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredGrad(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8938
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8943
::exit(___);}
#if 0
# 8938
{ 
# 8939
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8940
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8942
return make_float4(w.x, w.y, w.z, w.w); 
# 8943
} 
#endif
# 8945 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredGrad(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8946
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8951
::exit(___);}
#if 0
# 8946
{ 
# 8947
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8948
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8950
return make_float4(w.x, w.y, w.z, w.w); 
# 8951
} 
#endif
# 8959 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char tex3DGrad(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 8960
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 8968
::exit(___);}
#if 0
# 8960
{ 
# 8964
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 8967
return (char)(v.x); 
# 8968
} 
#endif
# 8970 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex3DGrad(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 8971
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 8975
::exit(___);}
#if 0
# 8971
{ 
# 8972
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 8974
return (signed char)(v.x); 
# 8975
} 
#endif
# 8977 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex3DGrad(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 8978
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 8982
::exit(___);}
#if 0
# 8978
{ 
# 8979
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 8981
return (unsigned char)(v.x); 
# 8982
} 
#endif
# 8984 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex3DGrad(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 8985
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 8989
::exit(___);}
#if 0
# 8985
{ 
# 8986
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 8988
return make_char1(v.x); 
# 8989
} 
#endif
# 8991 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex3DGrad(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 8992
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 8996
::exit(___);}
#if 0
# 8992
{ 
# 8993
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 8995
return make_uchar1(v.x); 
# 8996
} 
#endif
# 8998 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex3DGrad(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 8999
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9003
::exit(___);}
#if 0
# 8999
{ 
# 9000
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9002
return make_char2(v.x, v.y); 
# 9003
} 
#endif
# 9005 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex3DGrad(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9006
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9010
::exit(___);}
#if 0
# 9006
{ 
# 9007
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9009
return make_uchar2(v.x, v.y); 
# 9010
} 
#endif
# 9012 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex3DGrad(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9013
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9017
::exit(___);}
#if 0
# 9013
{ 
# 9014
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9016
return make_char4(v.x, v.y, v.z, v.w); 
# 9017
} 
#endif
# 9019 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex3DGrad(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9020
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9024
::exit(___);}
#if 0
# 9020
{ 
# 9021
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9023
return make_uchar4(v.x, v.y, v.z, v.w); 
# 9024
} 
#endif
# 9032 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short tex3DGrad(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9033
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9037
::exit(___);}
#if 0
# 9033
{ 
# 9034
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9036
return (short)(v.x); 
# 9037
} 
#endif
# 9039 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex3DGrad(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9040
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9044
::exit(___);}
#if 0
# 9040
{ 
# 9041
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9043
return (unsigned short)(v.x); 
# 9044
} 
#endif
# 9046 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex3DGrad(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9047
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9051
::exit(___);}
#if 0
# 9047
{ 
# 9048
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9050
return make_short1(v.x); 
# 9051
} 
#endif
# 9053 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex3DGrad(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9054
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9058
::exit(___);}
#if 0
# 9054
{ 
# 9055
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9057
return make_ushort1(v.x); 
# 9058
} 
#endif
# 9060 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex3DGrad(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9061
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9065
::exit(___);}
#if 0
# 9061
{ 
# 9062
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9064
return make_short2(v.x, v.y); 
# 9065
} 
#endif
# 9067 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex3DGrad(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9068
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9072
::exit(___);}
#if 0
# 9068
{ 
# 9069
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9071
return make_ushort2(v.x, v.y); 
# 9072
} 
#endif
# 9074 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex3DGrad(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9075
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9079
::exit(___);}
#if 0
# 9075
{ 
# 9076
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9078
return make_short4(v.x, v.y, v.z, v.w); 
# 9079
} 
#endif
# 9081 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex3DGrad(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9082
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9086
::exit(___);}
#if 0
# 9082
{ 
# 9083
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9085
return make_ushort4(v.x, v.y, v.z, v.w); 
# 9086
} 
#endif
# 9094 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int tex3DGrad(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9095
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9099
::exit(___);}
#if 0
# 9095
{ 
# 9096
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9098
return (int)(v.x); 
# 9099
} 
#endif
# 9101 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex3DGrad(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9102
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9106
::exit(___);}
#if 0
# 9102
{ 
# 9103
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9105
return (unsigned)(v.x); 
# 9106
} 
#endif
# 9108 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex3DGrad(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9109
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9113
::exit(___);}
#if 0
# 9109
{ 
# 9110
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9112
return make_int1(v.x); 
# 9113
} 
#endif
# 9115 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex3DGrad(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9116
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9120
::exit(___);}
#if 0
# 9116
{ 
# 9117
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9119
return make_uint1(v.x); 
# 9120
} 
#endif
# 9122 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex3DGrad(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9123
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9127
::exit(___);}
#if 0
# 9123
{ 
# 9124
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9126
return make_int2(v.x, v.y); 
# 9127
} 
#endif
# 9129 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex3DGrad(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9130
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9134
::exit(___);}
#if 0
# 9130
{ 
# 9131
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9133
return make_uint2(v.x, v.y); 
# 9134
} 
#endif
# 9136 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex3DGrad(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9137
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9141
::exit(___);}
#if 0
# 9137
{ 
# 9138
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9140
return make_int4(v.x, v.y, v.z, v.w); 
# 9141
} 
#endif
# 9143 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex3DGrad(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9144
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9148
::exit(___);}
#if 0
# 9144
{ 
# 9145
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9147
return make_uint4(v.x, v.y, v.z, v.w); 
# 9148
} 
#endif
# 9222 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9223
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9227
::exit(___);}
#if 0
# 9223
{ 
# 9224
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9226
return v.x; 
# 9227
} 
#endif
# 9229 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DGrad(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9230
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9234
::exit(___);}
#if 0
# 9230
{ 
# 9231
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9233
return make_float1(v.x); 
# 9234
} 
#endif
# 9236 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DGrad(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9237
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9241
::exit(___);}
#if 0
# 9237
{ 
# 9238
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9240
return make_float2(v.x, v.y); 
# 9241
} 
#endif
# 9243 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DGrad(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9244
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9248
::exit(___);}
#if 0
# 9244
{ 
# 9245
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9247
return make_float4(v.x, v.y, v.z, v.w); 
# 9248
} 
#endif
# 9256 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9257
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9266
::exit(___);}
#if 0
# 9257
{ 
# 9261
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9263
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9265
return w.x; 
# 9266
} 
#endif
# 9268 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9269
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9274
::exit(___);}
#if 0
# 9269
{ 
# 9270
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9271
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9273
return w.x; 
# 9274
} 
#endif
# 9276 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9277
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9282
::exit(___);}
#if 0
# 9277
{ 
# 9278
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9279
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9281
return w.x; 
# 9282
} 
#endif
# 9284 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DGrad(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9285
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9290
::exit(___);}
#if 0
# 9285
{ 
# 9286
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9287
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9289
return make_float1(w.x); 
# 9290
} 
#endif
# 9292 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DGrad(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9293
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9298
::exit(___);}
#if 0
# 9293
{ 
# 9294
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9295
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9297
return make_float1(w.x); 
# 9298
} 
#endif
# 9300 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DGrad(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9301
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9306
::exit(___);}
#if 0
# 9301
{ 
# 9302
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9303
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9305
return make_float2(w.x, w.y); 
# 9306
} 
#endif
# 9308 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DGrad(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9309
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9314
::exit(___);}
#if 0
# 9309
{ 
# 9310
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9311
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9313
return make_float2(w.x, w.y); 
# 9314
} 
#endif
# 9316 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DGrad(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9317
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9322
::exit(___);}
#if 0
# 9317
{ 
# 9318
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9319
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9321
return make_float4(w.x, w.y, w.z, w.w); 
# 9322
} 
#endif
# 9324 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DGrad(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9325
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9330
::exit(___);}
#if 0
# 9325
{ 
# 9326
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9327
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9329
return make_float4(w.x, w.y, w.z, w.w); 
# 9330
} 
#endif
# 9338 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9339
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9344
::exit(___);}
#if 0
# 9339
{ 
# 9340
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9341
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9343
return w.x; 
# 9344
} 
#endif
# 9346 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9347
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9352
::exit(___);}
#if 0
# 9347
{ 
# 9348
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9349
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9351
return w.x; 
# 9352
} 
#endif
# 9354 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DGrad(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9355
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9360
::exit(___);}
#if 0
# 9355
{ 
# 9356
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9357
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9359
return make_float1(w.x); 
# 9360
} 
#endif
# 9362 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DGrad(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9363
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9368
::exit(___);}
#if 0
# 9363
{ 
# 9364
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9365
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9367
return make_float1(w.x); 
# 9368
} 
#endif
# 9370 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DGrad(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9371
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9376
::exit(___);}
#if 0
# 9371
{ 
# 9372
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9373
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9375
return make_float2(w.x, w.y); 
# 9376
} 
#endif
# 9378 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DGrad(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9379
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9384
::exit(___);}
#if 0
# 9379
{ 
# 9380
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9381
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9383
return make_float2(w.x, w.y); 
# 9384
} 
#endif
# 9386 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DGrad(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9387
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9392
::exit(___);}
#if 0
# 9387
{ 
# 9388
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9389
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9391
return make_float4(w.x, w.y, w.z, w.w); 
# 9392
} 
#endif
# 9394 "/usr/include/texture_fetch_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DGrad(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9395
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9400
::exit(___);}
#if 0
# 9395
{ 
# 9396
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9397
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9399
return make_float4(w.x, w.y, w.z, w.w); 
# 9400
} 
#endif
# 70 "/usr/include/texture_indirect_functions.h" 3
extern "C" { __attribute__((unused)) void __tex_1d_v4f32_s32(cudaTextureObject_t, int, float *, float *, float *, float *); } 
# 71
extern "C" { __attribute__((unused)) void __tex_1d_v4f32_f32(cudaTextureObject_t, float, float *, float *, float *, float *); } 
# 72
extern "C" { __attribute__((unused)) void __tex_1d_level_v4f32_f32(cudaTextureObject_t, float, float, float *, float *, float *, float *); } 
# 73
extern "C" { __attribute__((unused)) void __tex_1d_grad_v4f32_f32(cudaTextureObject_t, float, float, float, float *, float *, float *, float *); } 
# 74
extern "C" { __attribute__((unused)) void __tex_1d_v4s32_s32(cudaTextureObject_t, int, int *, int *, int *, int *); } 
# 75
extern "C" { __attribute__((unused)) void __tex_1d_v4s32_f32(cudaTextureObject_t, float, int *, int *, int *, int *); } 
# 76
extern "C" { __attribute__((unused)) void __tex_1d_level_v4s32_f32(cudaTextureObject_t, float, float, int *, int *, int *, int *); } 
# 77
extern "C" { __attribute__((unused)) void __tex_1d_grad_v4s32_f32(cudaTextureObject_t, float, float, float, int *, int *, int *, int *); } 
# 78
extern "C" { __attribute__((unused)) void __tex_1d_v4u32_s32(cudaTextureObject_t, int, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 79
extern "C" { __attribute__((unused)) void __tex_1d_v4u32_f32(cudaTextureObject_t, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 80
extern "C" { __attribute__((unused)) void __tex_1d_level_v4u32_f32(cudaTextureObject_t, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 81
extern "C" { __attribute__((unused)) void __tex_1d_grad_v4u32_f32(cudaTextureObject_t, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 83
extern "C" { __attribute__((unused)) void __tex_1d_array_v4f32_s32(cudaTextureObject_t, int, int, float *, float *, float *, float *); } 
# 84
extern "C" { __attribute__((unused)) void __tex_1d_array_v4f32_f32(cudaTextureObject_t, int, float, float *, float *, float *, float *); } 
# 85
extern "C" { __attribute__((unused)) void __tex_1d_array_level_v4f32_f32(cudaTextureObject_t, int, float, float, float *, float *, float *, float *); } 
# 86
extern "C" { __attribute__((unused)) void __tex_1d_array_grad_v4f32_f32(cudaTextureObject_t, int, float, float, float, float *, float *, float *, float *); } 
# 87
extern "C" { __attribute__((unused)) void __tex_1d_array_v4s32_s32(cudaTextureObject_t, int, int, int *, int *, int *, int *); } 
# 88
extern "C" { __attribute__((unused)) void __tex_1d_array_v4s32_f32(cudaTextureObject_t, int, float, int *, int *, int *, int *); } 
# 89
extern "C" { __attribute__((unused)) void __tex_1d_array_level_v4s32_f32(cudaTextureObject_t, int, float, float, int *, int *, int *, int *); } 
# 90
extern "C" { __attribute__((unused)) void __tex_1d_array_grad_v4s32_f32(cudaTextureObject_t, int, float, float, float, int *, int *, int *, int *); } 
# 91
extern "C" { __attribute__((unused)) void __tex_1d_array_v4u32_s32(cudaTextureObject_t, int, int, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 92
extern "C" { __attribute__((unused)) void __tex_1d_array_v4u32_f32(cudaTextureObject_t, int, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 93
extern "C" { __attribute__((unused)) void __tex_1d_array_level_v4u32_f32(cudaTextureObject_t, int, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 94
extern "C" { __attribute__((unused)) void __tex_1d_array_grad_v4u32_f32(cudaTextureObject_t, int, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 96
extern "C" { __attribute__((unused)) void __tex_2d_v4f32_s32(cudaTextureObject_t, int, int, float *, float *, float *, float *); } 
# 97
extern "C" { __attribute__((unused)) void __tex_2d_v4f32_f32(cudaTextureObject_t, float, float, float *, float *, float *, float *); } 
# 98
extern "C" { __attribute__((unused)) void __tex_2d_level_v4f32_f32(cudaTextureObject_t, float, float, float, float *, float *, float *, float *); } 
# 99
extern "C" { __attribute__((unused)) void __tex_2d_grad_v4f32_f32(cudaTextureObject_t, float, float, float, float, float, float, float *, float *, float *, float *); } 
# 100
extern "C" { __attribute__((unused)) void __tex_2d_v4s32_s32(cudaTextureObject_t, int, int, int *, int *, int *, int *); } 
# 101
extern "C" { __attribute__((unused)) void __tex_2d_v4s32_f32(cudaTextureObject_t, float, float, int *, int *, int *, int *); } 
# 102
extern "C" { __attribute__((unused)) void __tex_2d_level_v4s32_f32(cudaTextureObject_t, float, float, float, int *, int *, int *, int *); } 
# 103
extern "C" { __attribute__((unused)) void __tex_2d_grad_v4s32_f32(cudaTextureObject_t, float, float, float, float, float, float, int *, int *, int *, int *); } 
# 104
extern "C" { __attribute__((unused)) void __tex_2d_v4u32_s32(cudaTextureObject_t, int, int, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 105
extern "C" { __attribute__((unused)) void __tex_2d_v4u32_f32(cudaTextureObject_t, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 106
extern "C" { __attribute__((unused)) void __tex_2d_level_v4u32_f32(cudaTextureObject_t, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 107
extern "C" { __attribute__((unused)) void __tex_2d_grad_v4u32_f32(cudaTextureObject_t, float, float, float, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 109
extern "C" { __attribute__((unused)) void __tex_2d_array_v4f32_s32(cudaTextureObject_t, int, int, int, float *, float *, float *, float *); } 
# 110
extern "C" { __attribute__((unused)) void __tex_2d_array_v4f32_f32(cudaTextureObject_t, int, float, float, float *, float *, float *, float *); } 
# 111
extern "C" { __attribute__((unused)) void __tex_2d_array_level_v4f32_f32(cudaTextureObject_t, int, float, float, float, float *, float *, float *, float *); } 
# 112
extern "C" { __attribute__((unused)) void __tex_2d_array_grad_v4f32_f32(cudaTextureObject_t, int, float, float, float, float, float, float, float *, float *, float *, float *); } 
# 113
extern "C" { __attribute__((unused)) void __tex_2d_array_v4s32_s32(cudaTextureObject_t, int, int, int, int *, int *, int *, int *); } 
# 114
extern "C" { __attribute__((unused)) void __tex_2d_array_v4s32_f32(cudaTextureObject_t, int, float, float, int *, int *, int *, int *); } 
# 115
extern "C" { __attribute__((unused)) void __tex_2d_array_level_v4s32_f32(cudaTextureObject_t, int, float, float, float, int *, int *, int *, int *); } 
# 116
extern "C" { __attribute__((unused)) void __tex_2d_array_grad_v4s32_f32(cudaTextureObject_t, int, float, float, float, float, float, float, int *, int *, int *, int *); } 
# 117
extern "C" { __attribute__((unused)) void __tex_2d_array_v4u32_s32(cudaTextureObject_t, int, int, int, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 118
extern "C" { __attribute__((unused)) void __tex_2d_array_v4u32_f32(cudaTextureObject_t, int, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 119
extern "C" { __attribute__((unused)) void __tex_2d_array_level_v4u32_f32(cudaTextureObject_t, int, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 120
extern "C" { __attribute__((unused)) void __tex_2d_array_grad_v4u32_f32(cudaTextureObject_t, int, float, float, float, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 122
extern "C" { __attribute__((unused)) void __tex_3d_v4f32_s32(cudaTextureObject_t, int, int, int, float *, float *, float *, float *); } 
# 123
extern "C" { __attribute__((unused)) void __tex_3d_v4f32_f32(cudaTextureObject_t, float, float, float, float *, float *, float *, float *); } 
# 124
extern "C" { __attribute__((unused)) void __tex_3d_level_v4f32_f32(cudaTextureObject_t, float, float, float, float, float *, float *, float *, float *); } 
# 125
extern "C" { __attribute__((unused)) void __tex_3d_grad_v4f32_f32(cudaTextureObject_t, float, float, float, float, float, float, float, float, float, float *, float *, float *, float *); } 
# 126
extern "C" { __attribute__((unused)) void __tex_3d_v4s32_s32(cudaTextureObject_t, int, int, int, int *, int *, int *, int *); } 
# 127
extern "C" { __attribute__((unused)) void __tex_3d_v4s32_f32(cudaTextureObject_t, float, float, float, int *, int *, int *, int *); } 
# 128
extern "C" { __attribute__((unused)) void __tex_3d_level_v4s32_f32(cudaTextureObject_t, float, float, float, float, int *, int *, int *, int *); } 
# 129
extern "C" { __attribute__((unused)) void __tex_3d_grad_v4s32_f32(cudaTextureObject_t, float, float, float, float, float, float, float, float, float, int *, int *, int *, int *); } 
# 130
extern "C" { __attribute__((unused)) void __tex_3d_v4u32_s32(cudaTextureObject_t, int, int, int, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 131
extern "C" { __attribute__((unused)) void __tex_3d_v4u32_f32(cudaTextureObject_t, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 132
extern "C" { __attribute__((unused)) void __tex_3d_level_v4u32_f32(cudaTextureObject_t, float, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 133
extern "C" { __attribute__((unused)) void __tex_3d_grad_v4u32_f32(cudaTextureObject_t, float, float, float, float, float, float, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 135
extern "C" { __attribute__((unused)) void __tex_cube_v4f32_f32(cudaTextureObject_t, float, float, float, float *, float *, float *, float *); } 
# 136
extern "C" { __attribute__((unused)) void __tex_cube_level_v4f32_f32(cudaTextureObject_t, float, float, float, float, float *, float *, float *, float *); } 
# 137
extern "C" { __attribute__((unused)) void __tex_cube_v4s32_f32(cudaTextureObject_t, float, float, float, int *, int *, int *, int *); } 
# 138
extern "C" { __attribute__((unused)) void __tex_cube_level_v4s32_f32(cudaTextureObject_t, float, float, float, float, int *, int *, int *, int *); } 
# 139
extern "C" { __attribute__((unused)) void __tex_cube_v4u32_f32(cudaTextureObject_t, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 140
extern "C" { __attribute__((unused)) void __tex_cube_level_v4u32_f32(cudaTextureObject_t, float, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 142
extern "C" { __attribute__((unused)) void __tex_cube_array_v4f32_f32(cudaTextureObject_t, int, float, float, float, float *, float *, float *, float *); } 
# 143
extern "C" { __attribute__((unused)) void __tex_cube_array_level_v4f32_f32(cudaTextureObject_t, int, float, float, float, float, float *, float *, float *, float *); } 
# 144
extern "C" { __attribute__((unused)) void __tex_cube_array_v4s32_f32(cudaTextureObject_t, int, float, float, float, int *, int *, int *, int *); } 
# 145
extern "C" { __attribute__((unused)) void __tex_cube_array_level_v4s32_f32(cudaTextureObject_t, int, float, float, float, float, int *, int *, int *, int *); } 
# 146
extern "C" { __attribute__((unused)) void __tex_cube_array_v4u32_f32(cudaTextureObject_t, int, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 147
extern "C" { __attribute__((unused)) void __tex_cube_array_level_v4u32_f32(cudaTextureObject_t, int, float, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 149
extern "C" { __attribute__((unused)) void __tld4_r_2d_v4f32_f32(cudaTextureObject_t, float, float, float *, float *, float *, float *); } 
# 150
extern "C" { __attribute__((unused)) void __tld4_g_2d_v4f32_f32(cudaTextureObject_t, float, float, float *, float *, float *, float *); } 
# 151
extern "C" { __attribute__((unused)) void __tld4_b_2d_v4f32_f32(cudaTextureObject_t, float, float, float *, float *, float *, float *); } 
# 152
extern "C" { __attribute__((unused)) void __tld4_a_2d_v4f32_f32(cudaTextureObject_t, float, float, float *, float *, float *, float *); } 
# 153
extern "C" { __attribute__((unused)) void __tld4_r_2d_v4s32_f32(cudaTextureObject_t, float, float, int *, int *, int *, int *); } 
# 154
extern "C" { __attribute__((unused)) void __tld4_g_2d_v4s32_f32(cudaTextureObject_t, float, float, int *, int *, int *, int *); } 
# 155
extern "C" { __attribute__((unused)) void __tld4_b_2d_v4s32_f32(cudaTextureObject_t, float, float, int *, int *, int *, int *); } 
# 156
extern "C" { __attribute__((unused)) void __tld4_a_2d_v4s32_f32(cudaTextureObject_t, float, float, int *, int *, int *, int *); } 
# 157
extern "C" { __attribute__((unused)) void __tld4_r_2d_v4u32_f32(cudaTextureObject_t, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 158
extern "C" { __attribute__((unused)) void __tld4_g_2d_v4u32_f32(cudaTextureObject_t, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 159
extern "C" { __attribute__((unused)) void __tld4_b_2d_v4u32_f32(cudaTextureObject_t, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 160
extern "C" { __attribute__((unused)) void __tld4_a_2d_v4u32_f32(cudaTextureObject_t, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
# 169
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(char * retVal, cudaTextureObject_t texObject, int x); 
# 170
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(signed char * retVal, cudaTextureObject_t texObject, int x); 
# 172
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(char1 * retVal, cudaTextureObject_t texObject, int x); 
# 174
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(char2 * retVal, cudaTextureObject_t texObject, int x); 
# 176
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(char4 * retVal, cudaTextureObject_t texObject, int x); 
# 178
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(unsigned char * retVal, cudaTextureObject_t texObject, int x); 
# 180
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uchar1 * retVal, cudaTextureObject_t texObject, int x); 
# 182
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uchar2 * retVal, cudaTextureObject_t texObject, int x); 
# 184
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uchar4 * retVal, cudaTextureObject_t texObject, int x); 
# 192
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(short * retVal, cudaTextureObject_t texObject, int x); 
# 194
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(short1 * retVal, cudaTextureObject_t texObject, int x); 
# 196
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(short2 * retVal, cudaTextureObject_t texObject, int x); 
# 198
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(short4 * retVal, cudaTextureObject_t texObject, int x); 
# 200
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(unsigned short * retVal, cudaTextureObject_t texObject, int x); 
# 202
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(ushort1 * retVal, cudaTextureObject_t texObject, int x); 
# 204
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(ushort2 * retVal, cudaTextureObject_t texObject, int x); 
# 206
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(ushort4 * retVal, cudaTextureObject_t texObject, int x); 
# 214
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(int * retVal, cudaTextureObject_t texObject, int x); 
# 216
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(int1 * retVal, cudaTextureObject_t texObject, int x); 
# 218
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(int2 * retVal, cudaTextureObject_t texObject, int x); 
# 220
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(int4 * retVal, cudaTextureObject_t texObject, int x); 
# 222
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(unsigned * retVal, cudaTextureObject_t texObject, int x); 
# 224
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uint1 * retVal, cudaTextureObject_t texObject, int x); 
# 226
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uint2 * retVal, cudaTextureObject_t texObject, int x); 
# 228
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uint4 * retVal, cudaTextureObject_t texObject, int x); 
# 263 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(float * retVal, cudaTextureObject_t texObject, int x); 
# 265
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(float1 * retVal, cudaTextureObject_t texObject, int x); 
# 267
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(float2 * retVal, cudaTextureObject_t texObject, int x); 
# 269
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(float4 * retVal, cudaTextureObject_t texObject, int x); 
# 277
template< class T> 
# 278
__attribute((always_inline)) __attribute__((unused)) static inline T tex1Dfetch(cudaTextureObject_t texObject, int x) 
# 279
{int volatile ___ = 1;(void)texObject;(void)x;
# 283
::exit(___);}
#if 0
# 279
{ 
# 280
T ret; 
# 281
tex1Dfetch(&ret, texObject, x); 
# 282
return ret; 
# 283
} 
#endif
# 291 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(char * retVal, cudaTextureObject_t texObject, float x); 
# 292
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(signed char * retVal, cudaTextureObject_t texObject, float x); 
# 294
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(char1 * retVal, cudaTextureObject_t texObject, float x); 
# 296
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(char2 * retVal, cudaTextureObject_t texObject, float x); 
# 298
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(char4 * retVal, cudaTextureObject_t texObject, float x); 
# 300
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(unsigned char * retVal, cudaTextureObject_t texObject, float x); 
# 302
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uchar1 * retVal, cudaTextureObject_t texObject, float x); 
# 304
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uchar2 * retVal, cudaTextureObject_t texObject, float x); 
# 306
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uchar4 * retVal, cudaTextureObject_t texObject, float x); 
# 314
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(short * retVal, cudaTextureObject_t texObject, float x); 
# 316
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(short1 * retVal, cudaTextureObject_t texObject, float x); 
# 318
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(short2 * retVal, cudaTextureObject_t texObject, float x); 
# 320
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(short4 * retVal, cudaTextureObject_t texObject, float x); 
# 322
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(unsigned short * retVal, cudaTextureObject_t texObject, float x); 
# 324
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(ushort1 * retVal, cudaTextureObject_t texObject, float x); 
# 326
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(ushort2 * retVal, cudaTextureObject_t texObject, float x); 
# 328
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(ushort4 * retVal, cudaTextureObject_t texObject, float x); 
# 336
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(int * retVal, cudaTextureObject_t texObject, float x); 
# 338
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(int1 * retVal, cudaTextureObject_t texObject, float x); 
# 340
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(int2 * retVal, cudaTextureObject_t texObject, float x); 
# 342
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(int4 * retVal, cudaTextureObject_t texObject, float x); 
# 344
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(unsigned * retVal, cudaTextureObject_t texObject, float x); 
# 346
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uint1 * retVal, cudaTextureObject_t texObject, float x); 
# 348
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uint2 * retVal, cudaTextureObject_t texObject, float x); 
# 350
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uint4 * retVal, cudaTextureObject_t texObject, float x); 
# 385 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(float * retVal, cudaTextureObject_t texObject, float x); 
# 387
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(float1 * retVal, cudaTextureObject_t texObject, float x); 
# 389
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(float2 * retVal, cudaTextureObject_t texObject, float x); 
# 391
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(float4 * retVal, cudaTextureObject_t texObject, float x); 
# 399
template< class T> 
# 400
__attribute((always_inline)) __attribute__((unused)) static inline T tex1D(cudaTextureObject_t texObject, float x) 
# 401
{int volatile ___ = 1;(void)texObject;(void)x;
# 405
::exit(___);}
#if 0
# 401
{ 
# 402
T ret; 
# 403
tex1D(&ret, texObject, x); 
# 404
return ret; 
# 405
} 
#endif
# 413 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(char * retVal, cudaTextureObject_t texObject, float x, float y); 
# 414
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(signed char * retVal, cudaTextureObject_t texObject, float x, float y); 
# 416
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(char1 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 418
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(char2 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 420
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(char4 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 422
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y); 
# 424
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 426
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 428
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 436
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(short * retVal, cudaTextureObject_t texObject, float x, float y); 
# 438
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(short1 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 440
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(short2 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 442
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(short4 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 444
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y); 
# 446
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 448
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 450
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 458
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(int * retVal, cudaTextureObject_t texObject, float x, float y); 
# 460
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(int1 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 462
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(int2 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 464
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(int4 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 466
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(unsigned * retVal, cudaTextureObject_t texObject, float x, float y); 
# 468
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uint1 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 470
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uint2 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 472
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uint4 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 507 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(float * retVal, cudaTextureObject_t texObject, float x, float y); 
# 509
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(float1 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 511
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(float2 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 513
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(float4 * retVal, cudaTextureObject_t texObject, float x, float y); 
# 521
template< class T> 
# 522
__attribute((always_inline)) __attribute__((unused)) static inline T tex2D(cudaTextureObject_t texObject, float x, float y) 
# 523
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;
# 527
::exit(___);}
#if 0
# 523
{ 
# 524
T ret; 
# 525
tex2D(&ret, texObject, x, y); 
# 526
return ret; 
# 527
} 
#endif
# 535 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(char * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 536
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 538
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 540
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 542
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 544
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 546
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 548
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 550
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 558
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(short * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 560
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 562
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 564
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 566
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 568
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 570
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 572
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 580
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(int * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 582
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 584
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 586
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 588
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 590
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 592
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 594
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 629 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(float * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 631
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 633
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 635
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 643
template< class T> 
# 644
__attribute((always_inline)) __attribute__((unused)) static inline T tex3D(cudaTextureObject_t texObject, float x, float y, float z) 
# 645
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
# 649
::exit(___);}
#if 0
# 645
{ 
# 646
T ret; 
# 647
tex3D(&ret, texObject, x, y, z); 
# 648
return ret; 
# 649
} 
#endif
# 657 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(char * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 658
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(signed char * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 660
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(char1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 662
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(char2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 664
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(char4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 666
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(unsigned char * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 668
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uchar1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 670
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uchar2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 672
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uchar4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 680
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(short * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 682
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(short1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 684
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(short2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 686
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(short4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 688
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(unsigned short * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 690
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(ushort1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 692
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(ushort2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 694
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(ushort4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 702
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(int * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 704
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(int1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 706
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(int2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 708
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(int4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 710
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(unsigned * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 712
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uint1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 714
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uint2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 716
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uint4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 751 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(float * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 753
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(float1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 755
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(float2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 757
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(float4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
# 765
template< class T> 
# 766
__attribute((always_inline)) __attribute__((unused)) static inline T tex1DLayered(cudaTextureObject_t texObject, float x, int layer) 
# 767
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;
# 771
::exit(___);}
#if 0
# 767
{ 
# 768
T ret; 
# 769
tex1DLayered(&ret, texObject, x, layer); 
# 770
return ret; 
# 771
} 
#endif
# 779 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(char * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 780
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(signed char * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 782
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(char1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 784
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(char2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 786
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(char4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 788
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 790
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 792
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 794
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 802
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(short * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 804
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(short1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 806
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(short2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 808
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(short4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 810
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 812
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 814
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 816
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 824
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(int * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 826
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(int1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 828
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(int2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 830
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(int4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 832
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 834
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 836
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 838
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 873 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(float * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 875
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(float1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 877
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(float2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 879
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(float4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
# 887
template< class T> 
# 888
__attribute((always_inline)) __attribute__((unused)) static inline T tex2DLayered(cudaTextureObject_t texObject, float x, float y, int layer) 
# 889
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;
# 893
::exit(___);}
#if 0
# 889
{ 
# 890
T ret; 
# 891
tex2DLayered(&ret, texObject, x, y, layer); 
# 892
return ret; 
# 893
} 
#endif
# 901 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(char * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 902
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 904
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 906
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 908
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 910
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 912
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 914
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 916
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 924
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(short * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 926
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 928
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 930
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 932
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 934
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 936
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 938
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 946
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(int * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 948
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 950
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 952
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 954
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 956
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 958
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 960
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 995 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(float * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 997
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 999
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 1001
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
# 1009
template< class T> 
# 1010
__attribute((always_inline)) __attribute__((unused)) static inline T texCubemap(cudaTextureObject_t texObject, float x, float y, float z) 
# 1011
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
# 1015
::exit(___);}
#if 0
# 1011
{ 
# 1012
T ret; 
# 1013
texCubemap(&ret, texObject, x, y, z); 
# 1014
return ret; 
# 1015
} 
#endif
# 1023 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(char * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1024
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1026
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1028
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1030
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1032
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1034
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1036
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1038
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1046
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(short * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1048
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1050
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1052
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1054
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1056
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1058
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1060
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1068
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(int * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1070
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1072
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1074
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1076
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1078
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1080
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1082
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1117 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(float * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1119
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1121
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1123
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
# 1131
template< class T> 
# 1132
__attribute((always_inline)) __attribute__((unused)) static inline T texCubemapLayered(cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 1133
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 1137
::exit(___);}
#if 0
# 1133
{ 
# 1134
T ret; 
# 1135
texCubemapLayered(&ret, texObject, x, y, z, layer); 
# 1136
return ret; 
# 1137
} 
#endif
# 1145 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(char * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1147
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(signed char * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1149
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(char1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1151
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(char2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1153
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(char4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1155
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1157
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1159
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1161
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1169
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(short * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1171
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(short1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1173
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(short2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1175
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(short4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1177
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1179
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1181
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1183
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1191
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(int * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1193
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(int1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1195
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(int2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1197
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(int4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1199
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1201
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1203
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1205
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1213
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(long * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1215
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(long1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1217
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(long2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1219
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(long4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1221
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(unsigned long * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1223
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ulong1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1225
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ulong2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1227
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ulong4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1235
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(float * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1237
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(float1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1239
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(float2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1241
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(float4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
# 1249
template< class T> 
# 1250
__attribute((always_inline)) __attribute__((unused)) static inline T tex2Dgather(cudaTextureObject_t to, float x, float y, int comp = 0) 
# 1251
{int volatile ___ = 1;(void)to;(void)x;(void)y;(void)comp;
# 1255
::exit(___);}
#if 0
# 1251
{ 
# 1252
T ret; 
# 1253
tex2Dgather(&ret, to, x, y, comp); 
# 1254
return ret; 
# 1255
} 
#endif
# 1263 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(char * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1264
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(signed char * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1266
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(char1 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1268
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(char2 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1270
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(char4 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1272
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(unsigned char * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1274
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uchar1 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1276
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uchar2 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1278
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uchar4 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1286
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(short * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1288
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(short1 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1290
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(short2 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1292
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(short4 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1294
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(unsigned short * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1296
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(ushort1 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1298
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(ushort2 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1300
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(ushort4 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1308
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(int * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1310
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(int1 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1312
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(int2 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1314
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(int4 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1316
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(unsigned * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1318
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uint1 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1320
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uint2 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1322
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uint4 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1357 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(float * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1359
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(float1 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1361
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(float2 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1363
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(float4 * retVal, cudaTextureObject_t texObject, float x, float level); 
# 1371
template< class T> 
# 1372
__attribute((always_inline)) __attribute__((unused)) static inline T tex1DLod(cudaTextureObject_t texObject, float x, float level) 
# 1373
{int volatile ___ = 1;(void)texObject;(void)x;(void)level;
# 1377
::exit(___);}
#if 0
# 1373
{ 
# 1374
T ret; 
# 1375
tex1DLod(&ret, texObject, x, level); 
# 1376
return ret; 
# 1377
} 
#endif
# 1385 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(char * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1386
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1388
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1390
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1392
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1394
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1396
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1398
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1400
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1408
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(short * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1410
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1412
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1414
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1416
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1418
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1420
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1422
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1430
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(int * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1432
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1434
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1436
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1438
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1440
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1442
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1444
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1479 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(float * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1481
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1483
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1485
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
# 1493
template< class T> 
# 1494
__attribute((always_inline)) __attribute__((unused)) static inline T tex2DLod(cudaTextureObject_t texObject, float x, float y, float level) 
# 1495
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)level;
# 1499
::exit(___);}
#if 0
# 1495
{ 
# 1496
T ret; 
# 1497
tex2DLod(&ret, texObject, x, y, level); 
# 1498
return ret; 
# 1499
} 
#endif
# 1507 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1508
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1510
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1512
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1514
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1516
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1518
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1520
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1522
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1530
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(short * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1532
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1534
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1536
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1538
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1540
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1542
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1544
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1552
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(int * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1554
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1556
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1558
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1560
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1562
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1564
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1566
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1601 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(float * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1603
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1605
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1607
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1615
template< class T> 
# 1616
__attribute((always_inline)) __attribute__((unused)) static inline T tex3DLod(cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 1617
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 1621
::exit(___);}
#if 0
# 1617
{ 
# 1618
T ret; 
# 1619
tex3DLod(&ret, texObject, x, y, z, level); 
# 1620
return ret; 
# 1621
} 
#endif
# 1629 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(char * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1630
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(signed char * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1632
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(char1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1634
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(char2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1636
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(char4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1638
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(unsigned char * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1640
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uchar1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1642
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uchar2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1644
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uchar4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1652
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(short * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1654
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(short1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1656
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(short2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1658
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(short4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1660
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(unsigned short * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1662
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(ushort1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1664
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(ushort2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1666
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(ushort4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1674
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(int * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1676
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(int1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1678
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(int2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1680
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(int4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1682
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(unsigned * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1684
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uint1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1686
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uint2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1688
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uint4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1723 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(float * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1725
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(float1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1727
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(float2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1729
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(float4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
# 1737
template< class T> 
# 1738
__attribute((always_inline)) __attribute__((unused)) static inline T tex1DLayeredLod(cudaTextureObject_t texObject, float x, int layer, float level) 
# 1739
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)level;
# 1743
::exit(___);}
#if 0
# 1739
{ 
# 1740
T ret; 
# 1741
tex1DLayeredLod(&ret, texObject, x, layer, level); 
# 1742
return ret; 
# 1743
} 
#endif
# 1751 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(char * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1752
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(signed char * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1754
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(char1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1756
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(char2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1758
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(char4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1760
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1762
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1764
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1766
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1774
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(short * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1776
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(short1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1778
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(short2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1780
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(short4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1782
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1784
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1786
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1788
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1796
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(int * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1798
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(int1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1800
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(int2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1802
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(int4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1804
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1806
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1808
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1810
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1845 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(float * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1847
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(float1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1849
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(float2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1851
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(float4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
# 1859
template< class T> 
# 1860
__attribute((always_inline)) __attribute__((unused)) static inline T tex2DLayeredLod(cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 1861
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 1865
::exit(___);}
#if 0
# 1861
{ 
# 1862
T ret; 
# 1863
tex2DLayeredLod(&ret, texObject, x, y, layer, level); 
# 1864
return ret; 
# 1865
} 
#endif
# 1873 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1874
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1876
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1878
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1880
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1882
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1884
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1886
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1888
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1896
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(short * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1898
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1900
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1902
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1904
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1906
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1908
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1910
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1918
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(int * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1920
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1922
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1924
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1926
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1928
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1930
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1932
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1967 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(float * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1969
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1971
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1973
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
# 1981
template< class T> 
# 1982
__attribute((always_inline)) __attribute__((unused)) static inline T texCubemapLod(cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 1983
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 1987
::exit(___);}
#if 0
# 1983
{ 
# 1984
T ret; 
# 1985
texCubemapLod(&ret, texObject, x, y, z, level); 
# 1986
return ret; 
# 1987
} 
#endif
# 1995 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(char * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 1996
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 1998
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2000
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2002
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2004
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2006
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2008
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2010
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2018
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(short * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2020
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2022
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2024
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2026
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2028
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2030
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2032
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2040
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(int * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2042
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2044
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2046
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2048
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2050
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2052
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2054
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2089 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(float * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2091
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2093
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2095
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
# 2103
template< class T> 
# 2104
__attribute((always_inline)) __attribute__((unused)) static inline T texCubemapLayeredLod(cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 2105
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 2109
::exit(___);}
#if 0
# 2105
{ 
# 2106
T ret; 
# 2107
texCubemapLayeredLod(&ret, texObject, x, y, z, layer, level); 
# 2108
return ret; 
# 2109
} 
#endif
# 2117 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(char * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2118
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(signed char * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2120
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(char1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2122
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(char2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2124
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(char4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2126
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(unsigned char * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2128
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uchar1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2130
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uchar2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2132
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uchar4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2140
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(short * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2142
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(short1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2144
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(short2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2146
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(short4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2148
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(unsigned short * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2150
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(ushort1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2152
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(ushort2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2154
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(ushort4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2162
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(int * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2164
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(int1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2166
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(int2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2168
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(int4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2170
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(unsigned * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2172
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uint1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2174
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uint2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2176
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uint4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2211 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(float * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2213
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(float1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2215
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(float2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2217
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(float4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
# 2225
template< class T> 
# 2226
__attribute((always_inline)) __attribute__((unused)) static inline T tex1DGrad(cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 2227
{int volatile ___ = 1;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 2231
::exit(___);}
#if 0
# 2227
{ 
# 2228
T ret; 
# 2229
tex1DGrad(&ret, texObject, x, dPdx, dPdy); 
# 2230
return ret; 
# 2231
} 
#endif
# 2239 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(char * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2240
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2242
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2244
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2246
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2248
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2250
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2252
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2254
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2262
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(short * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2264
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2266
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2268
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2270
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2272
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2274
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2276
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2284
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(int * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2286
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2288
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2290
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2292
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2294
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2296
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2298
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2333 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(float * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2335
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2337
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2339
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
# 2347
template< class T> 
# 2348
__attribute((always_inline)) __attribute__((unused)) static inline T tex2DGrad(cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 2349
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 2353
::exit(___);}
#if 0
# 2349
{ 
# 2350
T ret; 
# 2351
tex2DGrad(&ret, texObject, x, y, dPdx, dPdy); 
# 2352
return ret; 
# 2353
} 
#endif
# 2361 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2362
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2364
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2366
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2368
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2370
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2372
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2374
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2376
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2384
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(short * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2386
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2388
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2390
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2392
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2394
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2396
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2398
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2406
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(int * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2408
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2410
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2412
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2414
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2416
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2418
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2420
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2455 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(float * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2457
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2459
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2461
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
# 2469
template< class T> 
# 2470
__attribute((always_inline)) __attribute__((unused)) static inline T tex3DGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 2471
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 2475
::exit(___);}
#if 0
# 2471
{ 
# 2472
T ret; 
# 2473
tex3DGrad(&ret, texObject, x, y, z, dPdx, dPdy); 
# 2474
return ret; 
# 2475
} 
#endif
# 2483 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(char * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2484
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(signed char * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2486
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(char1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2488
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(char2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2490
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(char4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2492
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(unsigned char * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2494
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uchar1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2496
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uchar2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2498
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uchar4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2506
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(short * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2508
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(short1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2510
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(short2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2512
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(short4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2514
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(unsigned short * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2516
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(ushort1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2518
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(ushort2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2520
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(ushort4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2528
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(int * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2530
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(int1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2532
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(int2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2534
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(int4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2536
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(unsigned * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2538
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uint1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2540
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uint2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2542
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uint4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2577 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(float * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2579
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(float1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2581
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(float2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2583
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(float4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
# 2591
template< class T> 
# 2592
__attribute((always_inline)) __attribute__((unused)) static inline T tex1DLayeredGrad(cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 2593
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 2597
::exit(___);}
#if 0
# 2593
{ 
# 2594
T ret; 
# 2595
tex1DLayeredGrad(&ret, texObject, x, layer, dPdx, dPdy); 
# 2596
return ret; 
# 2597
} 
#endif
# 2605 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(char * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2606
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(signed char * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2608
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(char1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2610
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(char2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2612
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(char4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2614
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2616
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2618
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2620
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2628
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(short * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2630
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(short1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2632
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(short2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2634
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(short4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2636
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2638
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2640
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2642
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2650
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(int * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2652
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(int1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2654
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(int2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2656
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(int4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2658
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2660
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2662
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2664
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2699 "/usr/include/texture_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(float * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2701
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(float1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2703
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(float2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2705
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(float4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
# 2713
template< class T> 
# 2714
__attribute((always_inline)) __attribute__((unused)) static inline T tex2DLayeredGrad(cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 2715
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 2719
::exit(___);}
#if 0
# 2715
{ 
# 2716
T ret; 
# 2717
tex2DLayeredGrad(&ret, texObject, x, y, layer, dPdx, dPdy); 
# 2718
return ret; 
# 2719
} 
#endif
# 75 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(char *retVal, cudaTextureObject_t texObject, int x) 
# 76
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 85
::exit(___);}
#if 0
# 76
{ 
# 81
int4 tmp; 
# 82
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 84
(*retVal) = ((char)(tmp.x)); 
# 85
} 
#endif
# 86 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(signed char *retVal, cudaTextureObject_t texObject, int x) 
# 87
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 91
::exit(___);}
#if 0
# 87
{ 
# 88
int4 tmp; 
# 89
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 90
(*retVal) = ((signed char)(tmp.x)); 
# 91
} 
#endif
# 93 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(char1 *retVal, cudaTextureObject_t texObject, int x) 
# 94
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 98
::exit(___);}
#if 0
# 94
{ 
# 95
int4 tmp; 
# 96
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 97
(*retVal) = make_char1(tmp.x); 
# 98
} 
#endif
# 100 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(char2 *retVal, cudaTextureObject_t texObject, int x) 
# 101
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 105
::exit(___);}
#if 0
# 101
{ 
# 102
int4 tmp; 
# 103
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 104
(*retVal) = make_char2(tmp.x, tmp.y); 
# 105
} 
#endif
# 107 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(char4 *retVal, cudaTextureObject_t texObject, int x) 
# 108
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 112
::exit(___);}
#if 0
# 108
{ 
# 109
int4 tmp; 
# 110
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 111
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 112
} 
#endif
# 114 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(unsigned char *retVal, cudaTextureObject_t texObject, int x) 
# 115
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 119
::exit(___);}
#if 0
# 115
{ 
# 116
uint4 tmp; 
# 117
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 118
(*retVal) = ((unsigned char)(tmp.x)); 
# 119
} 
#endif
# 121 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uchar1 *retVal, cudaTextureObject_t texObject, int x) 
# 122
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 126
::exit(___);}
#if 0
# 122
{ 
# 123
uint4 tmp; 
# 124
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 125
(*retVal) = make_uchar1(tmp.x); 
# 126
} 
#endif
# 128 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uchar2 *retVal, cudaTextureObject_t texObject, int x) 
# 129
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 133
::exit(___);}
#if 0
# 129
{ 
# 130
uint4 tmp; 
# 131
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 132
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 133
} 
#endif
# 135 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uchar4 *retVal, cudaTextureObject_t texObject, int x) 
# 136
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 140
::exit(___);}
#if 0
# 136
{ 
# 137
uint4 tmp; 
# 138
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 139
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 140
} 
#endif
# 148 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(short *retVal, cudaTextureObject_t texObject, int x) 
# 149
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 153
::exit(___);}
#if 0
# 149
{ 
# 150
int4 tmp; 
# 151
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 152
(*retVal) = ((short)(tmp.x)); 
# 153
} 
#endif
# 155 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(short1 *retVal, cudaTextureObject_t texObject, int x) 
# 156
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 160
::exit(___);}
#if 0
# 156
{ 
# 157
int4 tmp; 
# 158
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 159
(*retVal) = make_short1(tmp.x); 
# 160
} 
#endif
# 162 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(short2 *retVal, cudaTextureObject_t texObject, int x) 
# 163
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 167
::exit(___);}
#if 0
# 163
{ 
# 164
int4 tmp; 
# 165
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 166
(*retVal) = make_short2(tmp.x, tmp.y); 
# 167
} 
#endif
# 169 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(short4 *retVal, cudaTextureObject_t texObject, int x) 
# 170
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 174
::exit(___);}
#if 0
# 170
{ 
# 171
int4 tmp; 
# 172
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 173
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 174
} 
#endif
# 176 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(unsigned short *retVal, cudaTextureObject_t texObject, int x) 
# 177
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 181
::exit(___);}
#if 0
# 177
{ 
# 178
uint4 tmp; 
# 179
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 180
(*retVal) = ((unsigned short)(tmp.x)); 
# 181
} 
#endif
# 183 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(ushort1 *retVal, cudaTextureObject_t texObject, int x) 
# 184
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 188
::exit(___);}
#if 0
# 184
{ 
# 185
uint4 tmp; 
# 186
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 187
(*retVal) = make_ushort1(tmp.x); 
# 188
} 
#endif
# 190 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(ushort2 *retVal, cudaTextureObject_t texObject, int x) 
# 191
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 195
::exit(___);}
#if 0
# 191
{ 
# 192
uint4 tmp; 
# 193
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 194
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 195
} 
#endif
# 197 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(ushort4 *retVal, cudaTextureObject_t texObject, int x) 
# 198
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 202
::exit(___);}
#if 0
# 198
{ 
# 199
uint4 tmp; 
# 200
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 201
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 202
} 
#endif
# 210 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(int *retVal, cudaTextureObject_t texObject, int x) 
# 211
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 215
::exit(___);}
#if 0
# 211
{ 
# 212
int4 tmp; 
# 213
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 214
(*retVal) = ((int)(tmp.x)); 
# 215
} 
#endif
# 217 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(int1 *retVal, cudaTextureObject_t texObject, int x) 
# 218
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 222
::exit(___);}
#if 0
# 218
{ 
# 219
int4 tmp; 
# 220
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 221
(*retVal) = make_int1(tmp.x); 
# 222
} 
#endif
# 224 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(int2 *retVal, cudaTextureObject_t texObject, int x) 
# 225
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 229
::exit(___);}
#if 0
# 225
{ 
# 226
int4 tmp; 
# 227
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 228
(*retVal) = make_int2(tmp.x, tmp.y); 
# 229
} 
#endif
# 231 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(int4 *retVal, cudaTextureObject_t texObject, int x) 
# 232
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 236
::exit(___);}
#if 0
# 232
{ 
# 233
int4 tmp; 
# 234
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 235
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 236
} 
#endif
# 238 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(unsigned *retVal, cudaTextureObject_t texObject, int x) 
# 239
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 243
::exit(___);}
#if 0
# 239
{ 
# 240
uint4 tmp; 
# 241
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 242
(*retVal) = ((unsigned)(tmp.x)); 
# 243
} 
#endif
# 245 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uint1 *retVal, cudaTextureObject_t texObject, int x) 
# 246
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 250
::exit(___);}
#if 0
# 246
{ 
# 247
uint4 tmp; 
# 248
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 249
(*retVal) = make_uint1(tmp.x); 
# 250
} 
#endif
# 252 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uint2 *retVal, cudaTextureObject_t texObject, int x) 
# 253
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 257
::exit(___);}
#if 0
# 253
{ 
# 254
uint4 tmp; 
# 255
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 256
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 257
} 
#endif
# 259 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uint4 *retVal, cudaTextureObject_t texObject, int x) 
# 260
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 264
::exit(___);}
#if 0
# 260
{ 
# 261
uint4 tmp; 
# 262
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 263
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 264
} 
#endif
# 339 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(float *retVal, cudaTextureObject_t texObject, int x) 
# 340
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 344
::exit(___);}
#if 0
# 340
{ 
# 341
float4 tmp; 
# 342
__tex_1d_v4f32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 343
(*retVal) = ((float)(tmp.x)); 
# 344
} 
#endif
# 346 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(float1 *retVal, cudaTextureObject_t texObject, int x) 
# 347
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 351
::exit(___);}
#if 0
# 347
{ 
# 348
float4 tmp; 
# 349
__tex_1d_v4f32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 350
(*retVal) = make_float1(tmp.x); 
# 351
} 
#endif
# 353 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(float2 *retVal, cudaTextureObject_t texObject, int x) 
# 354
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 358
::exit(___);}
#if 0
# 354
{ 
# 355
float4 tmp; 
# 356
__tex_1d_v4f32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 357
(*retVal) = make_float2(tmp.x, tmp.y); 
# 358
} 
#endif
# 360 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(float4 *retVal, cudaTextureObject_t texObject, int x) 
# 361
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 365
::exit(___);}
#if 0
# 361
{ 
# 362
float4 tmp; 
# 363
__tex_1d_v4f32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 364
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 365
} 
#endif
# 373 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(char *retVal, cudaTextureObject_t texObject, float x) 
# 374
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 383
::exit(___);}
#if 0
# 374
{ 
# 379
int4 tmp; 
# 380
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 382
(*retVal) = ((char)(tmp.x)); 
# 383
} 
#endif
# 384 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(signed char *retVal, cudaTextureObject_t texObject, float x) 
# 385
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 389
::exit(___);}
#if 0
# 385
{ 
# 386
int4 tmp; 
# 387
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 388
(*retVal) = ((signed char)(tmp.x)); 
# 389
} 
#endif
# 391 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(char1 *retVal, cudaTextureObject_t texObject, float x) 
# 392
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 396
::exit(___);}
#if 0
# 392
{ 
# 393
int4 tmp; 
# 394
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 395
(*retVal) = make_char1(tmp.x); 
# 396
} 
#endif
# 398 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(char2 *retVal, cudaTextureObject_t texObject, float x) 
# 399
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 403
::exit(___);}
#if 0
# 399
{ 
# 400
int4 tmp; 
# 401
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 402
(*retVal) = make_char2(tmp.x, tmp.y); 
# 403
} 
#endif
# 405 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(char4 *retVal, cudaTextureObject_t texObject, float x) 
# 406
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 410
::exit(___);}
#if 0
# 406
{ 
# 407
int4 tmp; 
# 408
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 409
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 410
} 
#endif
# 412 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(unsigned char *retVal, cudaTextureObject_t texObject, float x) 
# 413
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 417
::exit(___);}
#if 0
# 413
{ 
# 414
uint4 tmp; 
# 415
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 416
(*retVal) = ((unsigned char)(tmp.x)); 
# 417
} 
#endif
# 419 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uchar1 *retVal, cudaTextureObject_t texObject, float x) 
# 420
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 424
::exit(___);}
#if 0
# 420
{ 
# 421
uint4 tmp; 
# 422
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 423
(*retVal) = make_uchar1(tmp.x); 
# 424
} 
#endif
# 426 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uchar2 *retVal, cudaTextureObject_t texObject, float x) 
# 427
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 431
::exit(___);}
#if 0
# 427
{ 
# 428
uint4 tmp; 
# 429
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 430
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 431
} 
#endif
# 433 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uchar4 *retVal, cudaTextureObject_t texObject, float x) 
# 434
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 438
::exit(___);}
#if 0
# 434
{ 
# 435
uint4 tmp; 
# 436
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 437
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 438
} 
#endif
# 446 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(short *retVal, cudaTextureObject_t texObject, float x) 
# 447
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 451
::exit(___);}
#if 0
# 447
{ 
# 448
int4 tmp; 
# 449
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 450
(*retVal) = ((short)(tmp.x)); 
# 451
} 
#endif
# 453 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(short1 *retVal, cudaTextureObject_t texObject, float x) 
# 454
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 458
::exit(___);}
#if 0
# 454
{ 
# 455
int4 tmp; 
# 456
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 457
(*retVal) = make_short1(tmp.x); 
# 458
} 
#endif
# 460 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(short2 *retVal, cudaTextureObject_t texObject, float x) 
# 461
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 465
::exit(___);}
#if 0
# 461
{ 
# 462
int4 tmp; 
# 463
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 464
(*retVal) = make_short2(tmp.x, tmp.y); 
# 465
} 
#endif
# 467 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(short4 *retVal, cudaTextureObject_t texObject, float x) 
# 468
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 472
::exit(___);}
#if 0
# 468
{ 
# 469
int4 tmp; 
# 470
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 471
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 472
} 
#endif
# 474 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(unsigned short *retVal, cudaTextureObject_t texObject, float x) 
# 475
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 479
::exit(___);}
#if 0
# 475
{ 
# 476
uint4 tmp; 
# 477
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 478
(*retVal) = ((unsigned short)(tmp.x)); 
# 479
} 
#endif
# 481 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(ushort1 *retVal, cudaTextureObject_t texObject, float x) 
# 482
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 486
::exit(___);}
#if 0
# 482
{ 
# 483
uint4 tmp; 
# 484
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 485
(*retVal) = make_ushort1(tmp.x); 
# 486
} 
#endif
# 488 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(ushort2 *retVal, cudaTextureObject_t texObject, float x) 
# 489
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 493
::exit(___);}
#if 0
# 489
{ 
# 490
uint4 tmp; 
# 491
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 492
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 493
} 
#endif
# 495 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(ushort4 *retVal, cudaTextureObject_t texObject, float x) 
# 496
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 500
::exit(___);}
#if 0
# 496
{ 
# 497
uint4 tmp; 
# 498
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 499
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 500
} 
#endif
# 508 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(int *retVal, cudaTextureObject_t texObject, float x) 
# 509
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 513
::exit(___);}
#if 0
# 509
{ 
# 510
int4 tmp; 
# 511
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 512
(*retVal) = ((int)(tmp.x)); 
# 513
} 
#endif
# 515 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(int1 *retVal, cudaTextureObject_t texObject, float x) 
# 516
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 520
::exit(___);}
#if 0
# 516
{ 
# 517
int4 tmp; 
# 518
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 519
(*retVal) = make_int1(tmp.x); 
# 520
} 
#endif
# 522 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(int2 *retVal, cudaTextureObject_t texObject, float x) 
# 523
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 527
::exit(___);}
#if 0
# 523
{ 
# 524
int4 tmp; 
# 525
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 526
(*retVal) = make_int2(tmp.x, tmp.y); 
# 527
} 
#endif
# 529 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(int4 *retVal, cudaTextureObject_t texObject, float x) 
# 530
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 534
::exit(___);}
#if 0
# 530
{ 
# 531
int4 tmp; 
# 532
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 533
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 534
} 
#endif
# 536 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(unsigned *retVal, cudaTextureObject_t texObject, float x) 
# 537
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 541
::exit(___);}
#if 0
# 537
{ 
# 538
uint4 tmp; 
# 539
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 540
(*retVal) = ((unsigned)(tmp.x)); 
# 541
} 
#endif
# 543 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uint1 *retVal, cudaTextureObject_t texObject, float x) 
# 544
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 548
::exit(___);}
#if 0
# 544
{ 
# 545
uint4 tmp; 
# 546
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 547
(*retVal) = make_uint1(tmp.x); 
# 548
} 
#endif
# 550 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uint2 *retVal, cudaTextureObject_t texObject, float x) 
# 551
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 555
::exit(___);}
#if 0
# 551
{ 
# 552
uint4 tmp; 
# 553
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 554
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 555
} 
#endif
# 557 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uint4 *retVal, cudaTextureObject_t texObject, float x) 
# 558
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 562
::exit(___);}
#if 0
# 558
{ 
# 559
uint4 tmp; 
# 560
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 561
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 562
} 
#endif
# 637 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(float *retVal, cudaTextureObject_t texObject, float x) 
# 638
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 642
::exit(___);}
#if 0
# 638
{ 
# 639
float4 tmp; 
# 640
__tex_1d_v4f32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 641
(*retVal) = ((float)(tmp.x)); 
# 642
} 
#endif
# 644 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(float1 *retVal, cudaTextureObject_t texObject, float x) 
# 645
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 649
::exit(___);}
#if 0
# 645
{ 
# 646
float4 tmp; 
# 647
__tex_1d_v4f32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 648
(*retVal) = make_float1(tmp.x); 
# 649
} 
#endif
# 651 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(float2 *retVal, cudaTextureObject_t texObject, float x) 
# 652
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 656
::exit(___);}
#if 0
# 652
{ 
# 653
float4 tmp; 
# 654
__tex_1d_v4f32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 655
(*retVal) = make_float2(tmp.x, tmp.y); 
# 656
} 
#endif
# 658 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(float4 *retVal, cudaTextureObject_t texObject, float x) 
# 659
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 663
::exit(___);}
#if 0
# 659
{ 
# 660
float4 tmp; 
# 661
__tex_1d_v4f32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 662
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 663
} 
#endif
# 671 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(char *retVal, cudaTextureObject_t texObject, float x, float y) 
# 672
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 681
::exit(___);}
#if 0
# 672
{ 
# 677
int4 tmp; 
# 678
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 680
(*retVal) = ((char)(tmp.x)); 
# 681
} 
#endif
# 682 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(signed char *retVal, cudaTextureObject_t texObject, float x, float y) 
# 683
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 687
::exit(___);}
#if 0
# 683
{ 
# 684
int4 tmp; 
# 685
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 686
(*retVal) = ((signed char)(tmp.x)); 
# 687
} 
#endif
# 689 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(char1 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 690
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 694
::exit(___);}
#if 0
# 690
{ 
# 691
int4 tmp; 
# 692
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 693
(*retVal) = make_char1(tmp.x); 
# 694
} 
#endif
# 696 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(char2 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 697
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 701
::exit(___);}
#if 0
# 697
{ 
# 698
int4 tmp; 
# 699
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 700
(*retVal) = make_char2(tmp.x, tmp.y); 
# 701
} 
#endif
# 703 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(char4 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 704
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 708
::exit(___);}
#if 0
# 704
{ 
# 705
int4 tmp; 
# 706
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 707
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 708
} 
#endif
# 710 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y) 
# 711
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 715
::exit(___);}
#if 0
# 711
{ 
# 712
uint4 tmp; 
# 713
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 714
(*retVal) = ((unsigned char)(tmp.x)); 
# 715
} 
#endif
# 717 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 718
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 722
::exit(___);}
#if 0
# 718
{ 
# 719
uint4 tmp; 
# 720
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 721
(*retVal) = make_uchar1(tmp.x); 
# 722
} 
#endif
# 724 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 725
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 729
::exit(___);}
#if 0
# 725
{ 
# 726
uint4 tmp; 
# 727
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 728
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 729
} 
#endif
# 731 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 732
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 736
::exit(___);}
#if 0
# 732
{ 
# 733
uint4 tmp; 
# 734
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 735
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 736
} 
#endif
# 744 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(short *retVal, cudaTextureObject_t texObject, float x, float y) 
# 745
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 749
::exit(___);}
#if 0
# 745
{ 
# 746
int4 tmp; 
# 747
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 748
(*retVal) = ((short)(tmp.x)); 
# 749
} 
#endif
# 751 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(short1 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 752
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 756
::exit(___);}
#if 0
# 752
{ 
# 753
int4 tmp; 
# 754
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 755
(*retVal) = make_short1(tmp.x); 
# 756
} 
#endif
# 758 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(short2 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 759
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 763
::exit(___);}
#if 0
# 759
{ 
# 760
int4 tmp; 
# 761
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 762
(*retVal) = make_short2(tmp.x, tmp.y); 
# 763
} 
#endif
# 765 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(short4 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 766
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 770
::exit(___);}
#if 0
# 766
{ 
# 767
int4 tmp; 
# 768
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 769
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 770
} 
#endif
# 772 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y) 
# 773
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 777
::exit(___);}
#if 0
# 773
{ 
# 774
uint4 tmp; 
# 775
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 776
(*retVal) = ((unsigned short)(tmp.x)); 
# 777
} 
#endif
# 779 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 780
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 784
::exit(___);}
#if 0
# 780
{ 
# 781
uint4 tmp; 
# 782
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 783
(*retVal) = make_ushort1(tmp.x); 
# 784
} 
#endif
# 786 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 787
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 791
::exit(___);}
#if 0
# 787
{ 
# 788
uint4 tmp; 
# 789
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 790
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 791
} 
#endif
# 793 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 794
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 798
::exit(___);}
#if 0
# 794
{ 
# 795
uint4 tmp; 
# 796
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 797
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 798
} 
#endif
# 806 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(int *retVal, cudaTextureObject_t texObject, float x, float y) 
# 807
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 811
::exit(___);}
#if 0
# 807
{ 
# 808
int4 tmp; 
# 809
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 810
(*retVal) = ((int)(tmp.x)); 
# 811
} 
#endif
# 813 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(int1 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 814
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 818
::exit(___);}
#if 0
# 814
{ 
# 815
int4 tmp; 
# 816
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 817
(*retVal) = make_int1(tmp.x); 
# 818
} 
#endif
# 820 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(int2 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 821
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 825
::exit(___);}
#if 0
# 821
{ 
# 822
int4 tmp; 
# 823
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 824
(*retVal) = make_int2(tmp.x, tmp.y); 
# 825
} 
#endif
# 827 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(int4 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 828
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 832
::exit(___);}
#if 0
# 828
{ 
# 829
int4 tmp; 
# 830
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 831
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 832
} 
#endif
# 834 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(unsigned *retVal, cudaTextureObject_t texObject, float x, float y) 
# 835
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 839
::exit(___);}
#if 0
# 835
{ 
# 836
uint4 tmp; 
# 837
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 838
(*retVal) = ((unsigned)(tmp.x)); 
# 839
} 
#endif
# 841 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 842
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 846
::exit(___);}
#if 0
# 842
{ 
# 843
uint4 tmp; 
# 844
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 845
(*retVal) = make_uint1(tmp.x); 
# 846
} 
#endif
# 848 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 849
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 853
::exit(___);}
#if 0
# 849
{ 
# 850
uint4 tmp; 
# 851
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 852
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 853
} 
#endif
# 855 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 856
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 860
::exit(___);}
#if 0
# 856
{ 
# 857
uint4 tmp; 
# 858
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 859
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 860
} 
#endif
# 935 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(float *retVal, cudaTextureObject_t texObject, float x, float y) 
# 936
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 940
::exit(___);}
#if 0
# 936
{ 
# 937
float4 tmp; 
# 938
__tex_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 939
(*retVal) = ((float)(tmp.x)); 
# 940
} 
#endif
# 942 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(float1 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 943
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 947
::exit(___);}
#if 0
# 943
{ 
# 944
float4 tmp; 
# 945
__tex_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 946
(*retVal) = make_float1(tmp.x); 
# 947
} 
#endif
# 949 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(float2 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 950
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 954
::exit(___);}
#if 0
# 950
{ 
# 951
float4 tmp; 
# 952
__tex_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 953
(*retVal) = make_float2(tmp.x, tmp.y); 
# 954
} 
#endif
# 956 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(float4 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 957
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 961
::exit(___);}
#if 0
# 957
{ 
# 958
float4 tmp; 
# 959
__tex_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 960
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 961
} 
#endif
# 969 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 970
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 979
::exit(___);}
#if 0
# 970
{ 
# 975
int4 tmp; 
# 976
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 978
(*retVal) = ((char)(tmp.x)); 
# 979
} 
#endif
# 980 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 981
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 985
::exit(___);}
#if 0
# 981
{ 
# 982
int4 tmp; 
# 983
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 984
(*retVal) = ((signed char)(tmp.x)); 
# 985
} 
#endif
# 987 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 988
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 992
::exit(___);}
#if 0
# 988
{ 
# 989
int4 tmp; 
# 990
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 991
(*retVal) = make_char1(tmp.x); 
# 992
} 
#endif
# 994 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 995
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 999
::exit(___);}
#if 0
# 995
{ 
# 996
int4 tmp; 
# 997
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 998
(*retVal) = make_char2(tmp.x, tmp.y); 
# 999
} 
#endif
# 1001 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1002
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1006
::exit(___);}
#if 0
# 1002
{ 
# 1003
int4 tmp; 
# 1004
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1005
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1006
} 
#endif
# 1008 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1009
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1013
::exit(___);}
#if 0
# 1009
{ 
# 1010
uint4 tmp; 
# 1011
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1012
(*retVal) = ((unsigned char)(tmp.x)); 
# 1013
} 
#endif
# 1015 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1016
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1020
::exit(___);}
#if 0
# 1016
{ 
# 1017
uint4 tmp; 
# 1018
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1019
(*retVal) = make_uchar1(tmp.x); 
# 1020
} 
#endif
# 1022 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1023
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1027
::exit(___);}
#if 0
# 1023
{ 
# 1024
uint4 tmp; 
# 1025
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1026
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 1027
} 
#endif
# 1029 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1030
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1034
::exit(___);}
#if 0
# 1030
{ 
# 1031
uint4 tmp; 
# 1032
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1033
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1034
} 
#endif
# 1042 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1043
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1047
::exit(___);}
#if 0
# 1043
{ 
# 1044
int4 tmp; 
# 1045
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1046
(*retVal) = ((short)(tmp.x)); 
# 1047
} 
#endif
# 1049 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1050
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1054
::exit(___);}
#if 0
# 1050
{ 
# 1051
int4 tmp; 
# 1052
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1053
(*retVal) = make_short1(tmp.x); 
# 1054
} 
#endif
# 1056 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1057
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1061
::exit(___);}
#if 0
# 1057
{ 
# 1058
int4 tmp; 
# 1059
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1060
(*retVal) = make_short2(tmp.x, tmp.y); 
# 1061
} 
#endif
# 1063 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1064
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1068
::exit(___);}
#if 0
# 1064
{ 
# 1065
int4 tmp; 
# 1066
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1067
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1068
} 
#endif
# 1070 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1071
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1075
::exit(___);}
#if 0
# 1071
{ 
# 1072
uint4 tmp; 
# 1073
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1074
(*retVal) = ((unsigned short)(tmp.x)); 
# 1075
} 
#endif
# 1077 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1078
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1082
::exit(___);}
#if 0
# 1078
{ 
# 1079
uint4 tmp; 
# 1080
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1081
(*retVal) = make_ushort1(tmp.x); 
# 1082
} 
#endif
# 1084 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1085
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1089
::exit(___);}
#if 0
# 1085
{ 
# 1086
uint4 tmp; 
# 1087
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1088
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 1089
} 
#endif
# 1091 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1092
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1096
::exit(___);}
#if 0
# 1092
{ 
# 1093
uint4 tmp; 
# 1094
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1095
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1096
} 
#endif
# 1104 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(int *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1105
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1109
::exit(___);}
#if 0
# 1105
{ 
# 1106
int4 tmp; 
# 1107
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1108
(*retVal) = ((int)(tmp.x)); 
# 1109
} 
#endif
# 1111 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1112
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1116
::exit(___);}
#if 0
# 1112
{ 
# 1113
int4 tmp; 
# 1114
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1115
(*retVal) = make_int1(tmp.x); 
# 1116
} 
#endif
# 1118 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1119
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1123
::exit(___);}
#if 0
# 1119
{ 
# 1120
int4 tmp; 
# 1121
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1122
(*retVal) = make_int2(tmp.x, tmp.y); 
# 1123
} 
#endif
# 1125 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1126
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1130
::exit(___);}
#if 0
# 1126
{ 
# 1127
int4 tmp; 
# 1128
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1129
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1130
} 
#endif
# 1132 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1133
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1137
::exit(___);}
#if 0
# 1133
{ 
# 1134
uint4 tmp; 
# 1135
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1136
(*retVal) = ((unsigned)(tmp.x)); 
# 1137
} 
#endif
# 1139 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1140
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1144
::exit(___);}
#if 0
# 1140
{ 
# 1141
uint4 tmp; 
# 1142
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1143
(*retVal) = make_uint1(tmp.x); 
# 1144
} 
#endif
# 1146 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1147
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1151
::exit(___);}
#if 0
# 1147
{ 
# 1148
uint4 tmp; 
# 1149
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1150
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 1151
} 
#endif
# 1153 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1154
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1158
::exit(___);}
#if 0
# 1154
{ 
# 1155
uint4 tmp; 
# 1156
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1157
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1158
} 
#endif
# 1233 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(float *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1234
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1238
::exit(___);}
#if 0
# 1234
{ 
# 1235
float4 tmp; 
# 1236
__tex_3d_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1237
(*retVal) = ((float)(tmp.x)); 
# 1238
} 
#endif
# 1240 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1241
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1245
::exit(___);}
#if 0
# 1241
{ 
# 1242
float4 tmp; 
# 1243
__tex_3d_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1244
(*retVal) = make_float1(tmp.x); 
# 1245
} 
#endif
# 1247 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1248
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1252
::exit(___);}
#if 0
# 1248
{ 
# 1249
float4 tmp; 
# 1250
__tex_3d_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1251
(*retVal) = make_float2(tmp.x, tmp.y); 
# 1252
} 
#endif
# 1254 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1255
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1259
::exit(___);}
#if 0
# 1255
{ 
# 1256
float4 tmp; 
# 1257
__tex_3d_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1258
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1259
} 
#endif
# 1267 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(char *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1268
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1277
::exit(___);}
#if 0
# 1268
{ 
# 1273
int4 tmp; 
# 1274
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1276
(*retVal) = ((char)(tmp.x)); 
# 1277
} 
#endif
# 1278 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1279
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1283
::exit(___);}
#if 0
# 1279
{ 
# 1280
int4 tmp; 
# 1281
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1282
(*retVal) = ((signed char)(tmp.x)); 
# 1283
} 
#endif
# 1285 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1286
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1290
::exit(___);}
#if 0
# 1286
{ 
# 1287
int4 tmp; 
# 1288
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1289
(*retVal) = make_char1(tmp.x); 
# 1290
} 
#endif
# 1292 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1293
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1297
::exit(___);}
#if 0
# 1293
{ 
# 1294
int4 tmp; 
# 1295
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1296
(*retVal) = make_char2(tmp.x, tmp.y); 
# 1297
} 
#endif
# 1299 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1300
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1304
::exit(___);}
#if 0
# 1300
{ 
# 1301
int4 tmp; 
# 1302
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1303
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1304
} 
#endif
# 1306 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1307
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1311
::exit(___);}
#if 0
# 1307
{ 
# 1308
uint4 tmp; 
# 1309
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1310
(*retVal) = ((unsigned char)(tmp.x)); 
# 1311
} 
#endif
# 1313 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1314
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1318
::exit(___);}
#if 0
# 1314
{ 
# 1315
uint4 tmp; 
# 1316
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1317
(*retVal) = make_uchar1(tmp.x); 
# 1318
} 
#endif
# 1320 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1321
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1325
::exit(___);}
#if 0
# 1321
{ 
# 1322
uint4 tmp; 
# 1323
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1324
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 1325
} 
#endif
# 1327 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1328
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1332
::exit(___);}
#if 0
# 1328
{ 
# 1329
uint4 tmp; 
# 1330
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1331
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1332
} 
#endif
# 1340 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(short *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1341
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1345
::exit(___);}
#if 0
# 1341
{ 
# 1342
int4 tmp; 
# 1343
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1344
(*retVal) = ((short)(tmp.x)); 
# 1345
} 
#endif
# 1347 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1348
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1352
::exit(___);}
#if 0
# 1348
{ 
# 1349
int4 tmp; 
# 1350
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1351
(*retVal) = make_short1(tmp.x); 
# 1352
} 
#endif
# 1354 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1355
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1359
::exit(___);}
#if 0
# 1355
{ 
# 1356
int4 tmp; 
# 1357
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1358
(*retVal) = make_short2(tmp.x, tmp.y); 
# 1359
} 
#endif
# 1361 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1362
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1366
::exit(___);}
#if 0
# 1362
{ 
# 1363
int4 tmp; 
# 1364
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1365
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1366
} 
#endif
# 1368 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1369
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1373
::exit(___);}
#if 0
# 1369
{ 
# 1370
uint4 tmp; 
# 1371
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1372
(*retVal) = ((unsigned short)(tmp.x)); 
# 1373
} 
#endif
# 1375 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1376
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1380
::exit(___);}
#if 0
# 1376
{ 
# 1377
uint4 tmp; 
# 1378
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1379
(*retVal) = make_ushort1(tmp.x); 
# 1380
} 
#endif
# 1382 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1383
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1387
::exit(___);}
#if 0
# 1383
{ 
# 1384
uint4 tmp; 
# 1385
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1386
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 1387
} 
#endif
# 1389 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1390
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1394
::exit(___);}
#if 0
# 1390
{ 
# 1391
uint4 tmp; 
# 1392
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1393
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1394
} 
#endif
# 1402 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(int *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1403
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1407
::exit(___);}
#if 0
# 1403
{ 
# 1404
int4 tmp; 
# 1405
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1406
(*retVal) = ((int)(tmp.x)); 
# 1407
} 
#endif
# 1409 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1410
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1414
::exit(___);}
#if 0
# 1410
{ 
# 1411
int4 tmp; 
# 1412
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1413
(*retVal) = make_int1(tmp.x); 
# 1414
} 
#endif
# 1416 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1417
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1421
::exit(___);}
#if 0
# 1417
{ 
# 1418
int4 tmp; 
# 1419
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1420
(*retVal) = make_int2(tmp.x, tmp.y); 
# 1421
} 
#endif
# 1423 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1424
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1428
::exit(___);}
#if 0
# 1424
{ 
# 1425
int4 tmp; 
# 1426
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1427
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1428
} 
#endif
# 1430 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(unsigned *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1431
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1435
::exit(___);}
#if 0
# 1431
{ 
# 1432
uint4 tmp; 
# 1433
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1434
(*retVal) = ((unsigned)(tmp.x)); 
# 1435
} 
#endif
# 1437 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1438
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1442
::exit(___);}
#if 0
# 1438
{ 
# 1439
uint4 tmp; 
# 1440
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1441
(*retVal) = make_uint1(tmp.x); 
# 1442
} 
#endif
# 1444 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1445
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1449
::exit(___);}
#if 0
# 1445
{ 
# 1446
uint4 tmp; 
# 1447
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1448
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 1449
} 
#endif
# 1451 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1452
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1456
::exit(___);}
#if 0
# 1452
{ 
# 1453
uint4 tmp; 
# 1454
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1455
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1456
} 
#endif
# 1531 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(float *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1532
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1536
::exit(___);}
#if 0
# 1532
{ 
# 1533
float4 tmp; 
# 1534
__tex_1d_array_v4f32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1535
(*retVal) = ((float)(tmp.x)); 
# 1536
} 
#endif
# 1538 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1539
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1543
::exit(___);}
#if 0
# 1539
{ 
# 1540
float4 tmp; 
# 1541
__tex_1d_array_v4f32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1542
(*retVal) = make_float1(tmp.x); 
# 1543
} 
#endif
# 1545 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1546
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1550
::exit(___);}
#if 0
# 1546
{ 
# 1547
float4 tmp; 
# 1548
__tex_1d_array_v4f32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1549
(*retVal) = make_float2(tmp.x, tmp.y); 
# 1550
} 
#endif
# 1552 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1553
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1557
::exit(___);}
#if 0
# 1553
{ 
# 1554
float4 tmp; 
# 1555
__tex_1d_array_v4f32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1556
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1557
} 
#endif
# 1565 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1566
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1575
::exit(___);}
#if 0
# 1566
{ 
# 1571
int4 tmp; 
# 1572
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1574
(*retVal) = ((char)(tmp.x)); 
# 1575
} 
#endif
# 1576 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1577
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1581
::exit(___);}
#if 0
# 1577
{ 
# 1578
int4 tmp; 
# 1579
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1580
(*retVal) = ((signed char)(tmp.x)); 
# 1581
} 
#endif
# 1583 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1584
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1588
::exit(___);}
#if 0
# 1584
{ 
# 1585
int4 tmp; 
# 1586
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1587
(*retVal) = make_char1(tmp.x); 
# 1588
} 
#endif
# 1590 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1591
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1595
::exit(___);}
#if 0
# 1591
{ 
# 1592
int4 tmp; 
# 1593
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1594
(*retVal) = make_char2(tmp.x, tmp.y); 
# 1595
} 
#endif
# 1597 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1598
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1602
::exit(___);}
#if 0
# 1598
{ 
# 1599
int4 tmp; 
# 1600
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1601
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1602
} 
#endif
# 1604 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1605
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1609
::exit(___);}
#if 0
# 1605
{ 
# 1606
uint4 tmp; 
# 1607
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1608
(*retVal) = ((unsigned char)(tmp.x)); 
# 1609
} 
#endif
# 1611 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1612
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1616
::exit(___);}
#if 0
# 1612
{ 
# 1613
uint4 tmp; 
# 1614
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1615
(*retVal) = make_uchar1(tmp.x); 
# 1616
} 
#endif
# 1618 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1619
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1623
::exit(___);}
#if 0
# 1619
{ 
# 1620
uint4 tmp; 
# 1621
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1622
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 1623
} 
#endif
# 1625 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1626
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1630
::exit(___);}
#if 0
# 1626
{ 
# 1627
uint4 tmp; 
# 1628
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1629
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1630
} 
#endif
# 1638 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1639
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1643
::exit(___);}
#if 0
# 1639
{ 
# 1640
int4 tmp; 
# 1641
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1642
(*retVal) = ((short)(tmp.x)); 
# 1643
} 
#endif
# 1645 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1646
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1650
::exit(___);}
#if 0
# 1646
{ 
# 1647
int4 tmp; 
# 1648
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1649
(*retVal) = make_short1(tmp.x); 
# 1650
} 
#endif
# 1652 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1653
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1657
::exit(___);}
#if 0
# 1653
{ 
# 1654
int4 tmp; 
# 1655
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1656
(*retVal) = make_short2(tmp.x, tmp.y); 
# 1657
} 
#endif
# 1659 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1660
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1664
::exit(___);}
#if 0
# 1660
{ 
# 1661
int4 tmp; 
# 1662
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1663
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1664
} 
#endif
# 1666 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1667
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1671
::exit(___);}
#if 0
# 1667
{ 
# 1668
uint4 tmp; 
# 1669
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1670
(*retVal) = ((unsigned short)(tmp.x)); 
# 1671
} 
#endif
# 1673 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1674
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1678
::exit(___);}
#if 0
# 1674
{ 
# 1675
uint4 tmp; 
# 1676
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1677
(*retVal) = make_ushort1(tmp.x); 
# 1678
} 
#endif
# 1680 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1681
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1685
::exit(___);}
#if 0
# 1681
{ 
# 1682
uint4 tmp; 
# 1683
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1684
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 1685
} 
#endif
# 1687 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1688
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1692
::exit(___);}
#if 0
# 1688
{ 
# 1689
uint4 tmp; 
# 1690
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1691
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1692
} 
#endif
# 1700 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1701
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1705
::exit(___);}
#if 0
# 1701
{ 
# 1702
int4 tmp; 
# 1703
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1704
(*retVal) = ((int)(tmp.x)); 
# 1705
} 
#endif
# 1707 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1708
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1712
::exit(___);}
#if 0
# 1708
{ 
# 1709
int4 tmp; 
# 1710
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1711
(*retVal) = make_int1(tmp.x); 
# 1712
} 
#endif
# 1714 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1715
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1719
::exit(___);}
#if 0
# 1715
{ 
# 1716
int4 tmp; 
# 1717
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1718
(*retVal) = make_int2(tmp.x, tmp.y); 
# 1719
} 
#endif
# 1721 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1722
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1726
::exit(___);}
#if 0
# 1722
{ 
# 1723
int4 tmp; 
# 1724
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1725
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1726
} 
#endif
# 1728 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1729
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1733
::exit(___);}
#if 0
# 1729
{ 
# 1730
uint4 tmp; 
# 1731
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1732
(*retVal) = ((unsigned)(tmp.x)); 
# 1733
} 
#endif
# 1735 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1736
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1740
::exit(___);}
#if 0
# 1736
{ 
# 1737
uint4 tmp; 
# 1738
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1739
(*retVal) = make_uint1(tmp.x); 
# 1740
} 
#endif
# 1742 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1743
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1747
::exit(___);}
#if 0
# 1743
{ 
# 1744
uint4 tmp; 
# 1745
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1746
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 1747
} 
#endif
# 1749 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1750
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1754
::exit(___);}
#if 0
# 1750
{ 
# 1751
uint4 tmp; 
# 1752
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1753
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1754
} 
#endif
# 1829 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1830
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1834
::exit(___);}
#if 0
# 1830
{ 
# 1831
float4 tmp; 
# 1832
__tex_2d_array_v4f32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1833
(*retVal) = ((float)(tmp.x)); 
# 1834
} 
#endif
# 1836 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1837
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1841
::exit(___);}
#if 0
# 1837
{ 
# 1838
float4 tmp; 
# 1839
__tex_2d_array_v4f32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1840
(*retVal) = make_float1(tmp.x); 
# 1841
} 
#endif
# 1843 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1844
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1848
::exit(___);}
#if 0
# 1844
{ 
# 1845
float4 tmp; 
# 1846
__tex_2d_array_v4f32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1847
(*retVal) = make_float2(tmp.x, tmp.y); 
# 1848
} 
#endif
# 1850 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1851
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1855
::exit(___);}
#if 0
# 1851
{ 
# 1852
float4 tmp; 
# 1853
__tex_2d_array_v4f32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1854
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1855
} 
#endif
# 1863 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1864
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1873
::exit(___);}
#if 0
# 1864
{ 
# 1869
int4 tmp; 
# 1870
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1872
(*retVal) = ((char)(tmp.x)); 
# 1873
} 
#endif
# 1874 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1875
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1879
::exit(___);}
#if 0
# 1875
{ 
# 1876
int4 tmp; 
# 1877
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1878
(*retVal) = ((signed char)(tmp.x)); 
# 1879
} 
#endif
# 1881 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1882
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1886
::exit(___);}
#if 0
# 1882
{ 
# 1883
int4 tmp; 
# 1884
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1885
(*retVal) = make_char1(tmp.x); 
# 1886
} 
#endif
# 1888 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1889
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1893
::exit(___);}
#if 0
# 1889
{ 
# 1890
int4 tmp; 
# 1891
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1892
(*retVal) = make_char2(tmp.x, tmp.y); 
# 1893
} 
#endif
# 1895 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1896
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1900
::exit(___);}
#if 0
# 1896
{ 
# 1897
int4 tmp; 
# 1898
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1899
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1900
} 
#endif
# 1902 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1903
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1907
::exit(___);}
#if 0
# 1903
{ 
# 1904
uint4 tmp; 
# 1905
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1906
(*retVal) = ((unsigned char)(tmp.x)); 
# 1907
} 
#endif
# 1909 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1910
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1914
::exit(___);}
#if 0
# 1910
{ 
# 1911
uint4 tmp; 
# 1912
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1913
(*retVal) = make_uchar1(tmp.x); 
# 1914
} 
#endif
# 1916 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1917
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1921
::exit(___);}
#if 0
# 1917
{ 
# 1918
uint4 tmp; 
# 1919
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1920
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 1921
} 
#endif
# 1923 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1924
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1928
::exit(___);}
#if 0
# 1924
{ 
# 1925
uint4 tmp; 
# 1926
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1927
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1928
} 
#endif
# 1936 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1937
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1941
::exit(___);}
#if 0
# 1937
{ 
# 1938
int4 tmp; 
# 1939
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1940
(*retVal) = ((short)(tmp.x)); 
# 1941
} 
#endif
# 1943 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1944
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1948
::exit(___);}
#if 0
# 1944
{ 
# 1945
int4 tmp; 
# 1946
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1947
(*retVal) = make_short1(tmp.x); 
# 1948
} 
#endif
# 1950 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1951
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1955
::exit(___);}
#if 0
# 1951
{ 
# 1952
int4 tmp; 
# 1953
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1954
(*retVal) = make_short2(tmp.x, tmp.y); 
# 1955
} 
#endif
# 1957 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1958
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1962
::exit(___);}
#if 0
# 1958
{ 
# 1959
int4 tmp; 
# 1960
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1961
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1962
} 
#endif
# 1964 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1965
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1969
::exit(___);}
#if 0
# 1965
{ 
# 1966
uint4 tmp; 
# 1967
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1968
(*retVal) = ((unsigned short)(tmp.x)); 
# 1969
} 
#endif
# 1971 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1972
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1976
::exit(___);}
#if 0
# 1972
{ 
# 1973
uint4 tmp; 
# 1974
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1975
(*retVal) = make_ushort1(tmp.x); 
# 1976
} 
#endif
# 1978 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1979
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1983
::exit(___);}
#if 0
# 1979
{ 
# 1980
uint4 tmp; 
# 1981
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1982
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 1983
} 
#endif
# 1985 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1986
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1990
::exit(___);}
#if 0
# 1986
{ 
# 1987
uint4 tmp; 
# 1988
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 1989
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1990
} 
#endif
# 1998 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(int *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1999
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2003
::exit(___);}
#if 0
# 1999
{ 
# 2000
int4 tmp; 
# 2001
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2002
(*retVal) = ((int)(tmp.x)); 
# 2003
} 
#endif
# 2005 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2006
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2010
::exit(___);}
#if 0
# 2006
{ 
# 2007
int4 tmp; 
# 2008
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2009
(*retVal) = make_int1(tmp.x); 
# 2010
} 
#endif
# 2012 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2013
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2017
::exit(___);}
#if 0
# 2013
{ 
# 2014
int4 tmp; 
# 2015
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2016
(*retVal) = make_int2(tmp.x, tmp.y); 
# 2017
} 
#endif
# 2019 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2020
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2024
::exit(___);}
#if 0
# 2020
{ 
# 2021
int4 tmp; 
# 2022
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2023
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2024
} 
#endif
# 2026 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2027
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2031
::exit(___);}
#if 0
# 2027
{ 
# 2028
uint4 tmp; 
# 2029
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2030
(*retVal) = ((unsigned)(tmp.x)); 
# 2031
} 
#endif
# 2033 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2034
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2038
::exit(___);}
#if 0
# 2034
{ 
# 2035
uint4 tmp; 
# 2036
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2037
(*retVal) = make_uint1(tmp.x); 
# 2038
} 
#endif
# 2040 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2041
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2045
::exit(___);}
#if 0
# 2041
{ 
# 2042
uint4 tmp; 
# 2043
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2044
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 2045
} 
#endif
# 2047 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2048
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2052
::exit(___);}
#if 0
# 2048
{ 
# 2049
uint4 tmp; 
# 2050
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2051
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2052
} 
#endif
# 2127 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(float *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2128
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2132
::exit(___);}
#if 0
# 2128
{ 
# 2129
float4 tmp; 
# 2130
__tex_cube_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2131
(*retVal) = ((float)(tmp.x)); 
# 2132
} 
#endif
# 2134 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2135
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2139
::exit(___);}
#if 0
# 2135
{ 
# 2136
float4 tmp; 
# 2137
__tex_cube_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2138
(*retVal) = make_float1(tmp.x); 
# 2139
} 
#endif
# 2141 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2142
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2146
::exit(___);}
#if 0
# 2142
{ 
# 2143
float4 tmp; 
# 2144
__tex_cube_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2145
(*retVal) = make_float2(tmp.x, tmp.y); 
# 2146
} 
#endif
# 2148 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2149
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2153
::exit(___);}
#if 0
# 2149
{ 
# 2150
float4 tmp; 
# 2151
__tex_cube_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2152
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2153
} 
#endif
# 2161 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2162
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2171
::exit(___);}
#if 0
# 2162
{ 
# 2167
int4 tmp; 
# 2168
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2170
(*retVal) = ((char)(tmp.x)); 
# 2171
} 
#endif
# 2172 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2173
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2177
::exit(___);}
#if 0
# 2173
{ 
# 2174
int4 tmp; 
# 2175
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2176
(*retVal) = ((signed char)(tmp.x)); 
# 2177
} 
#endif
# 2179 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2180
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2184
::exit(___);}
#if 0
# 2180
{ 
# 2181
int4 tmp; 
# 2182
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2183
(*retVal) = make_char1(tmp.x); 
# 2184
} 
#endif
# 2186 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2187
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2191
::exit(___);}
#if 0
# 2187
{ 
# 2188
int4 tmp; 
# 2189
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2190
(*retVal) = make_char2(tmp.x, tmp.y); 
# 2191
} 
#endif
# 2193 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2194
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2198
::exit(___);}
#if 0
# 2194
{ 
# 2195
int4 tmp; 
# 2196
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2197
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2198
} 
#endif
# 2200 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2201
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2205
::exit(___);}
#if 0
# 2201
{ 
# 2202
uint4 tmp; 
# 2203
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2204
(*retVal) = ((unsigned char)(tmp.x)); 
# 2205
} 
#endif
# 2207 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2208
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2212
::exit(___);}
#if 0
# 2208
{ 
# 2209
uint4 tmp; 
# 2210
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2211
(*retVal) = make_uchar1(tmp.x); 
# 2212
} 
#endif
# 2214 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2215
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2219
::exit(___);}
#if 0
# 2215
{ 
# 2216
uint4 tmp; 
# 2217
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2218
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 2219
} 
#endif
# 2221 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2222
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2226
::exit(___);}
#if 0
# 2222
{ 
# 2223
uint4 tmp; 
# 2224
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2225
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2226
} 
#endif
# 2234 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2235
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2239
::exit(___);}
#if 0
# 2235
{ 
# 2236
int4 tmp; 
# 2237
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2238
(*retVal) = ((short)(tmp.x)); 
# 2239
} 
#endif
# 2241 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2242
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2246
::exit(___);}
#if 0
# 2242
{ 
# 2243
int4 tmp; 
# 2244
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2245
(*retVal) = make_short1(tmp.x); 
# 2246
} 
#endif
# 2248 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2249
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2253
::exit(___);}
#if 0
# 2249
{ 
# 2250
int4 tmp; 
# 2251
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2252
(*retVal) = make_short2(tmp.x, tmp.y); 
# 2253
} 
#endif
# 2255 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2256
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2260
::exit(___);}
#if 0
# 2256
{ 
# 2257
int4 tmp; 
# 2258
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2259
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2260
} 
#endif
# 2262 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2263
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2267
::exit(___);}
#if 0
# 2263
{ 
# 2264
uint4 tmp; 
# 2265
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2266
(*retVal) = ((unsigned short)(tmp.x)); 
# 2267
} 
#endif
# 2269 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2270
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2274
::exit(___);}
#if 0
# 2270
{ 
# 2271
uint4 tmp; 
# 2272
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2273
(*retVal) = make_ushort1(tmp.x); 
# 2274
} 
#endif
# 2276 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2277
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2281
::exit(___);}
#if 0
# 2277
{ 
# 2278
uint4 tmp; 
# 2279
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2280
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 2281
} 
#endif
# 2283 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2284
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2288
::exit(___);}
#if 0
# 2284
{ 
# 2285
uint4 tmp; 
# 2286
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2287
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2288
} 
#endif
# 2296 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2297
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2301
::exit(___);}
#if 0
# 2297
{ 
# 2298
int4 tmp; 
# 2299
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2300
(*retVal) = ((int)(tmp.x)); 
# 2301
} 
#endif
# 2303 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2304
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2308
::exit(___);}
#if 0
# 2304
{ 
# 2305
int4 tmp; 
# 2306
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2307
(*retVal) = make_int1(tmp.x); 
# 2308
} 
#endif
# 2310 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2311
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2315
::exit(___);}
#if 0
# 2311
{ 
# 2312
int4 tmp; 
# 2313
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2314
(*retVal) = make_int2(tmp.x, tmp.y); 
# 2315
} 
#endif
# 2317 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2318
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2322
::exit(___);}
#if 0
# 2318
{ 
# 2319
int4 tmp; 
# 2320
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2321
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2322
} 
#endif
# 2324 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2325
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2329
::exit(___);}
#if 0
# 2325
{ 
# 2326
uint4 tmp; 
# 2327
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2328
(*retVal) = ((unsigned)(tmp.x)); 
# 2329
} 
#endif
# 2331 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2332
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2336
::exit(___);}
#if 0
# 2332
{ 
# 2333
uint4 tmp; 
# 2334
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2335
(*retVal) = make_uint1(tmp.x); 
# 2336
} 
#endif
# 2338 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2339
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2343
::exit(___);}
#if 0
# 2339
{ 
# 2340
uint4 tmp; 
# 2341
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2342
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 2343
} 
#endif
# 2345 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2346
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2350
::exit(___);}
#if 0
# 2346
{ 
# 2347
uint4 tmp; 
# 2348
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2349
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2350
} 
#endif
# 2425 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2426
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2430
::exit(___);}
#if 0
# 2426
{ 
# 2427
float4 tmp; 
# 2428
__tex_cube_array_v4f32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2429
(*retVal) = ((float)(tmp.x)); 
# 2430
} 
#endif
# 2432 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2433
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2437
::exit(___);}
#if 0
# 2433
{ 
# 2434
float4 tmp; 
# 2435
__tex_cube_array_v4f32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2436
(*retVal) = make_float1(tmp.x); 
# 2437
} 
#endif
# 2439 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2440
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2444
::exit(___);}
#if 0
# 2440
{ 
# 2441
float4 tmp; 
# 2442
__tex_cube_array_v4f32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2443
(*retVal) = make_float2(tmp.x, tmp.y); 
# 2444
} 
#endif
# 2446 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2447
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2451
::exit(___);}
#if 0
# 2447
{ 
# 2448
float4 tmp; 
# 2449
__tex_cube_array_v4f32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2450
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2451
} 
#endif
# 2459 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(char *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2460
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2475
::exit(___);}
#if 0
# 2460
{ 
# 2461
int4 tmp; 
# 2462
if (comp == 0) { 
# 2463
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2464
} else { 
# 2465
if (comp == 1) { 
# 2466
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2467
} else { 
# 2468
if (comp == 2) { 
# 2469
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2470
} else { 
# 2471
if (comp == 3) { 
# 2472
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2473
}  }  }  }  
# 2474
(*retVal) = ((char)(tmp.x)); 
# 2475
} 
#endif
# 2477 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2478
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2493
::exit(___);}
#if 0
# 2478
{ 
# 2479
int4 tmp; 
# 2480
if (comp == 0) { 
# 2481
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2482
} else { 
# 2483
if (comp == 1) { 
# 2484
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2485
} else { 
# 2486
if (comp == 2) { 
# 2487
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2488
} else { 
# 2489
if (comp == 3) { 
# 2490
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2491
}  }  }  }  
# 2492
(*retVal) = ((signed char)(tmp.x)); 
# 2493
} 
#endif
# 2495 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2496
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2511
::exit(___);}
#if 0
# 2496
{ 
# 2497
int4 tmp; 
# 2498
if (comp == 0) { 
# 2499
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2500
} else { 
# 2501
if (comp == 1) { 
# 2502
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2503
} else { 
# 2504
if (comp == 2) { 
# 2505
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2506
} else { 
# 2507
if (comp == 3) { 
# 2508
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2509
}  }  }  }  
# 2510
(*retVal) = make_char1(tmp.x); 
# 2511
} 
#endif
# 2513 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2514
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2529
::exit(___);}
#if 0
# 2514
{ 
# 2515
int4 tmp; 
# 2516
if (comp == 0) { 
# 2517
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2518
} else { 
# 2519
if (comp == 1) { 
# 2520
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2521
} else { 
# 2522
if (comp == 2) { 
# 2523
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2524
} else { 
# 2525
if (comp == 3) { 
# 2526
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2527
}  }  }  }  
# 2528
(*retVal) = make_char2(tmp.x, tmp.y); 
# 2529
} 
#endif
# 2531 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2532
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2547
::exit(___);}
#if 0
# 2532
{ 
# 2533
int4 tmp; 
# 2534
if (comp == 0) { 
# 2535
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2536
} else { 
# 2537
if (comp == 1) { 
# 2538
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2539
} else { 
# 2540
if (comp == 2) { 
# 2541
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2542
} else { 
# 2543
if (comp == 3) { 
# 2544
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2545
}  }  }  }  
# 2546
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2547
} 
#endif
# 2549 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2550
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2565
::exit(___);}
#if 0
# 2550
{ 
# 2551
uint4 tmp; 
# 2552
if (comp == 0) { 
# 2553
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2554
} else { 
# 2555
if (comp == 1) { 
# 2556
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2557
} else { 
# 2558
if (comp == 2) { 
# 2559
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2560
} else { 
# 2561
if (comp == 3) { 
# 2562
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2563
}  }  }  }  
# 2564
(*retVal) = ((unsigned char)(tmp.x)); 
# 2565
} 
#endif
# 2567 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2568
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2583
::exit(___);}
#if 0
# 2568
{ 
# 2569
uint4 tmp; 
# 2570
if (comp == 0) { 
# 2571
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2572
} else { 
# 2573
if (comp == 1) { 
# 2574
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2575
} else { 
# 2576
if (comp == 2) { 
# 2577
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2578
} else { 
# 2579
if (comp == 3) { 
# 2580
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2581
}  }  }  }  
# 2582
(*retVal) = make_uchar1(tmp.x); 
# 2583
} 
#endif
# 2585 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2586
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2601
::exit(___);}
#if 0
# 2586
{ 
# 2587
uint4 tmp; 
# 2588
if (comp == 0) { 
# 2589
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2590
} else { 
# 2591
if (comp == 1) { 
# 2592
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2593
} else { 
# 2594
if (comp == 2) { 
# 2595
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2596
} else { 
# 2597
if (comp == 3) { 
# 2598
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2599
}  }  }  }  
# 2600
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 2601
} 
#endif
# 2603 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2604
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2619
::exit(___);}
#if 0
# 2604
{ 
# 2605
uint4 tmp; 
# 2606
if (comp == 0) { 
# 2607
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2608
} else { 
# 2609
if (comp == 1) { 
# 2610
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2611
} else { 
# 2612
if (comp == 2) { 
# 2613
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2614
} else { 
# 2615
if (comp == 3) { 
# 2616
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2617
}  }  }  }  
# 2618
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2619
} 
#endif
# 2627 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(short *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2628
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2643
::exit(___);}
#if 0
# 2628
{ 
# 2629
int4 tmp; 
# 2630
if (comp == 0) { 
# 2631
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2632
} else { 
# 2633
if (comp == 1) { 
# 2634
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2635
} else { 
# 2636
if (comp == 2) { 
# 2637
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2638
} else { 
# 2639
if (comp == 3) { 
# 2640
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2641
}  }  }  }  
# 2642
(*retVal) = ((short)(tmp.x)); 
# 2643
} 
#endif
# 2645 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2646
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2661
::exit(___);}
#if 0
# 2646
{ 
# 2647
int4 tmp; 
# 2648
if (comp == 0) { 
# 2649
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2650
} else { 
# 2651
if (comp == 1) { 
# 2652
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2653
} else { 
# 2654
if (comp == 2) { 
# 2655
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2656
} else { 
# 2657
if (comp == 3) { 
# 2658
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2659
}  }  }  }  
# 2660
(*retVal) = make_short1(tmp.x); 
# 2661
} 
#endif
# 2663 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2664
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2679
::exit(___);}
#if 0
# 2664
{ 
# 2665
int4 tmp; 
# 2666
if (comp == 0) { 
# 2667
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2668
} else { 
# 2669
if (comp == 1) { 
# 2670
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2671
} else { 
# 2672
if (comp == 2) { 
# 2673
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2674
} else { 
# 2675
if (comp == 3) { 
# 2676
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2677
}  }  }  }  
# 2678
(*retVal) = make_short2(tmp.x, tmp.y); 
# 2679
} 
#endif
# 2681 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2682
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2697
::exit(___);}
#if 0
# 2682
{ 
# 2683
int4 tmp; 
# 2684
if (comp == 0) { 
# 2685
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2686
} else { 
# 2687
if (comp == 1) { 
# 2688
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2689
} else { 
# 2690
if (comp == 2) { 
# 2691
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2692
} else { 
# 2693
if (comp == 3) { 
# 2694
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2695
}  }  }  }  
# 2696
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2697
} 
#endif
# 2699 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2700
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2715
::exit(___);}
#if 0
# 2700
{ 
# 2701
uint4 tmp; 
# 2702
if (comp == 0) { 
# 2703
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2704
} else { 
# 2705
if (comp == 1) { 
# 2706
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2707
} else { 
# 2708
if (comp == 2) { 
# 2709
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2710
} else { 
# 2711
if (comp == 3) { 
# 2712
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2713
}  }  }  }  
# 2714
(*retVal) = ((unsigned short)(tmp.x)); 
# 2715
} 
#endif
# 2717 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2718
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2733
::exit(___);}
#if 0
# 2718
{ 
# 2719
uint4 tmp; 
# 2720
if (comp == 0) { 
# 2721
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2722
} else { 
# 2723
if (comp == 1) { 
# 2724
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2725
} else { 
# 2726
if (comp == 2) { 
# 2727
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2728
} else { 
# 2729
if (comp == 3) { 
# 2730
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2731
}  }  }  }  
# 2732
(*retVal) = make_ushort1(tmp.x); 
# 2733
} 
#endif
# 2735 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2736
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2751
::exit(___);}
#if 0
# 2736
{ 
# 2737
uint4 tmp; 
# 2738
if (comp == 0) { 
# 2739
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2740
} else { 
# 2741
if (comp == 1) { 
# 2742
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2743
} else { 
# 2744
if (comp == 2) { 
# 2745
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2746
} else { 
# 2747
if (comp == 3) { 
# 2748
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2749
}  }  }  }  
# 2750
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 2751
} 
#endif
# 2753 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2754
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2769
::exit(___);}
#if 0
# 2754
{ 
# 2755
uint4 tmp; 
# 2756
if (comp == 0) { 
# 2757
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2758
} else { 
# 2759
if (comp == 1) { 
# 2760
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2761
} else { 
# 2762
if (comp == 2) { 
# 2763
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2764
} else { 
# 2765
if (comp == 3) { 
# 2766
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2767
}  }  }  }  
# 2768
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2769
} 
#endif
# 2777 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(int *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2778
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2793
::exit(___);}
#if 0
# 2778
{ 
# 2779
int4 tmp; 
# 2780
if (comp == 0) { 
# 2781
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2782
} else { 
# 2783
if (comp == 1) { 
# 2784
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2785
} else { 
# 2786
if (comp == 2) { 
# 2787
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2788
} else { 
# 2789
if (comp == 3) { 
# 2790
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2791
}  }  }  }  
# 2792
(*retVal) = ((int)(tmp.x)); 
# 2793
} 
#endif
# 2795 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2796
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2811
::exit(___);}
#if 0
# 2796
{ 
# 2797
int4 tmp; 
# 2798
if (comp == 0) { 
# 2799
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2800
} else { 
# 2801
if (comp == 1) { 
# 2802
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2803
} else { 
# 2804
if (comp == 2) { 
# 2805
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2806
} else { 
# 2807
if (comp == 3) { 
# 2808
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2809
}  }  }  }  
# 2810
(*retVal) = make_int1(tmp.x); 
# 2811
} 
#endif
# 2813 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2814
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2829
::exit(___);}
#if 0
# 2814
{ 
# 2815
int4 tmp; 
# 2816
if (comp == 0) { 
# 2817
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2818
} else { 
# 2819
if (comp == 1) { 
# 2820
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2821
} else { 
# 2822
if (comp == 2) { 
# 2823
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2824
} else { 
# 2825
if (comp == 3) { 
# 2826
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2827
}  }  }  }  
# 2828
(*retVal) = make_int2(tmp.x, tmp.y); 
# 2829
} 
#endif
# 2831 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2832
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2847
::exit(___);}
#if 0
# 2832
{ 
# 2833
int4 tmp; 
# 2834
if (comp == 0) { 
# 2835
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2836
} else { 
# 2837
if (comp == 1) { 
# 2838
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2839
} else { 
# 2840
if (comp == 2) { 
# 2841
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2842
} else { 
# 2843
if (comp == 3) { 
# 2844
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2845
}  }  }  }  
# 2846
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2847
} 
#endif
# 2849 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2850
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2865
::exit(___);}
#if 0
# 2850
{ 
# 2851
uint4 tmp; 
# 2852
if (comp == 0) { 
# 2853
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2854
} else { 
# 2855
if (comp == 1) { 
# 2856
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2857
} else { 
# 2858
if (comp == 2) { 
# 2859
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2860
} else { 
# 2861
if (comp == 3) { 
# 2862
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2863
}  }  }  }  
# 2864
(*retVal) = ((unsigned)(tmp.x)); 
# 2865
} 
#endif
# 2867 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2868
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2883
::exit(___);}
#if 0
# 2868
{ 
# 2869
uint4 tmp; 
# 2870
if (comp == 0) { 
# 2871
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2872
} else { 
# 2873
if (comp == 1) { 
# 2874
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2875
} else { 
# 2876
if (comp == 2) { 
# 2877
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2878
} else { 
# 2879
if (comp == 3) { 
# 2880
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2881
}  }  }  }  
# 2882
(*retVal) = make_uint1(tmp.x); 
# 2883
} 
#endif
# 2885 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2886
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2901
::exit(___);}
#if 0
# 2886
{ 
# 2887
uint4 tmp; 
# 2888
if (comp == 0) { 
# 2889
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2890
} else { 
# 2891
if (comp == 1) { 
# 2892
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2893
} else { 
# 2894
if (comp == 2) { 
# 2895
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2896
} else { 
# 2897
if (comp == 3) { 
# 2898
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2899
}  }  }  }  
# 2900
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 2901
} 
#endif
# 2903 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2904
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2919
::exit(___);}
#if 0
# 2904
{ 
# 2905
uint4 tmp; 
# 2906
if (comp == 0) { 
# 2907
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2908
} else { 
# 2909
if (comp == 1) { 
# 2910
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2911
} else { 
# 2912
if (comp == 2) { 
# 2913
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2914
} else { 
# 2915
if (comp == 3) { 
# 2916
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2917
}  }  }  }  
# 2918
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2919
} 
#endif
# 2927 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(long *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2928
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2943
::exit(___);}
#if 0
# 2928
{ 
# 2929
int4 tmp; 
# 2930
if (comp == 0) { 
# 2931
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2932
} else { 
# 2933
if (comp == 1) { 
# 2934
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2935
} else { 
# 2936
if (comp == 2) { 
# 2937
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2938
} else { 
# 2939
if (comp == 3) { 
# 2940
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2941
}  }  }  }  
# 2942
(*retVal) = ((long)(tmp.x)); 
# 2943
} 
#endif
# 2945 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2946
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2961
::exit(___);}
#if 0
# 2946
{ 
# 2947
int4 tmp; 
# 2948
if (comp == 0) { 
# 2949
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2950
} else { 
# 2951
if (comp == 1) { 
# 2952
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2953
} else { 
# 2954
if (comp == 2) { 
# 2955
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2956
} else { 
# 2957
if (comp == 3) { 
# 2958
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2959
}  }  }  }  
# 2960
(*retVal) = make_long1(tmp.x); 
# 2961
} 
#endif
# 2963 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2964
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2979
::exit(___);}
#if 0
# 2964
{ 
# 2965
int4 tmp; 
# 2966
if (comp == 0) { 
# 2967
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2968
} else { 
# 2969
if (comp == 1) { 
# 2970
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2971
} else { 
# 2972
if (comp == 2) { 
# 2973
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2974
} else { 
# 2975
if (comp == 3) { 
# 2976
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2977
}  }  }  }  
# 2978
(*retVal) = make_long2(tmp.x, tmp.y); 
# 2979
} 
#endif
# 2981 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 2982
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2997
::exit(___);}
#if 0
# 2982
{ 
# 2983
int4 tmp; 
# 2984
if (comp == 0) { 
# 2985
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2986
} else { 
# 2987
if (comp == 1) { 
# 2988
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2989
} else { 
# 2990
if (comp == 2) { 
# 2991
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2992
} else { 
# 2993
if (comp == 3) { 
# 2994
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 2995
}  }  }  }  
# 2996
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2997
} 
#endif
# 2999 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 3000
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3015
::exit(___);}
#if 0
# 3000
{ 
# 3001
uint4 tmp; 
# 3002
if (comp == 0) { 
# 3003
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3004
} else { 
# 3005
if (comp == 1) { 
# 3006
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3007
} else { 
# 3008
if (comp == 2) { 
# 3009
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3010
} else { 
# 3011
if (comp == 3) { 
# 3012
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3013
}  }  }  }  
# 3014
(*retVal) = ((unsigned long)(tmp.x)); 
# 3015
} 
#endif
# 3017 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 3018
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3033
::exit(___);}
#if 0
# 3018
{ 
# 3019
uint4 tmp; 
# 3020
if (comp == 0) { 
# 3021
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3022
} else { 
# 3023
if (comp == 1) { 
# 3024
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3025
} else { 
# 3026
if (comp == 2) { 
# 3027
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3028
} else { 
# 3029
if (comp == 3) { 
# 3030
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3031
}  }  }  }  
# 3032
(*retVal) = make_ulong1(tmp.x); 
# 3033
} 
#endif
# 3035 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 3036
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3051
::exit(___);}
#if 0
# 3036
{ 
# 3037
uint4 tmp; 
# 3038
if (comp == 0) { 
# 3039
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3040
} else { 
# 3041
if (comp == 1) { 
# 3042
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3043
} else { 
# 3044
if (comp == 2) { 
# 3045
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3046
} else { 
# 3047
if (comp == 3) { 
# 3048
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3049
}  }  }  }  
# 3050
(*retVal) = make_ulong2(tmp.x, tmp.y); 
# 3051
} 
#endif
# 3053 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 3054
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3069
::exit(___);}
#if 0
# 3054
{ 
# 3055
uint4 tmp; 
# 3056
if (comp == 0) { 
# 3057
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3058
} else { 
# 3059
if (comp == 1) { 
# 3060
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3061
} else { 
# 3062
if (comp == 2) { 
# 3063
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3064
} else { 
# 3065
if (comp == 3) { 
# 3066
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3067
}  }  }  }  
# 3068
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3069
} 
#endif
# 3077 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(float *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 3078
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3093
::exit(___);}
#if 0
# 3078
{ 
# 3079
float4 tmp; 
# 3080
if (comp == 0) { 
# 3081
__tld4_r_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3082
} else { 
# 3083
if (comp == 1) { 
# 3084
__tld4_g_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3085
} else { 
# 3086
if (comp == 2) { 
# 3087
__tld4_b_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3088
} else { 
# 3089
if (comp == 3) { 
# 3090
__tld4_a_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3091
}  }  }  }  
# 3092
(*retVal) = ((float)(tmp.x)); 
# 3093
} 
#endif
# 3095 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 3096
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3111
::exit(___);}
#if 0
# 3096
{ 
# 3097
float4 tmp; 
# 3098
if (comp == 0) { 
# 3099
__tld4_r_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3100
} else { 
# 3101
if (comp == 1) { 
# 3102
__tld4_g_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3103
} else { 
# 3104
if (comp == 2) { 
# 3105
__tld4_b_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3106
} else { 
# 3107
if (comp == 3) { 
# 3108
__tld4_a_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3109
}  }  }  }  
# 3110
(*retVal) = make_float1(tmp.x); 
# 3111
} 
#endif
# 3113 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 3114
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3129
::exit(___);}
#if 0
# 3114
{ 
# 3115
float4 tmp; 
# 3116
if (comp == 0) { 
# 3117
__tld4_r_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3118
} else { 
# 3119
if (comp == 1) { 
# 3120
__tld4_g_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3121
} else { 
# 3122
if (comp == 2) { 
# 3123
__tld4_b_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3124
} else { 
# 3125
if (comp == 3) { 
# 3126
__tld4_a_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3127
}  }  }  }  
# 3128
(*retVal) = make_float2(tmp.x, tmp.y); 
# 3129
} 
#endif
# 3131 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
# 3132
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3147
::exit(___);}
#if 0
# 3132
{ 
# 3133
float4 tmp; 
# 3134
if (comp == 0) { 
# 3135
__tld4_r_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3136
} else { 
# 3137
if (comp == 1) { 
# 3138
__tld4_g_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3139
} else { 
# 3140
if (comp == 2) { 
# 3141
__tld4_b_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3142
} else { 
# 3143
if (comp == 3) { 
# 3144
__tld4_a_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3145
}  }  }  }  
# 3146
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3147
} 
#endif
# 3155 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(char *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3156
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3165
::exit(___);}
#if 0
# 3156
{ 
# 3161
int4 tmp; 
# 3162
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3164
(*retVal) = ((char)(tmp.x)); 
# 3165
} 
#endif
# 3166 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3167
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3171
::exit(___);}
#if 0
# 3167
{ 
# 3168
int4 tmp; 
# 3169
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3170
(*retVal) = ((signed char)(tmp.x)); 
# 3171
} 
#endif
# 3173 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3174
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3178
::exit(___);}
#if 0
# 3174
{ 
# 3175
int4 tmp; 
# 3176
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3177
(*retVal) = make_char1(tmp.x); 
# 3178
} 
#endif
# 3180 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3181
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3185
::exit(___);}
#if 0
# 3181
{ 
# 3182
int4 tmp; 
# 3183
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3184
(*retVal) = make_char2(tmp.x, tmp.y); 
# 3185
} 
#endif
# 3187 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3188
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3192
::exit(___);}
#if 0
# 3188
{ 
# 3189
int4 tmp; 
# 3190
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3191
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3192
} 
#endif
# 3194 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3195
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3199
::exit(___);}
#if 0
# 3195
{ 
# 3196
uint4 tmp; 
# 3197
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3198
(*retVal) = ((unsigned char)(tmp.x)); 
# 3199
} 
#endif
# 3201 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3202
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3206
::exit(___);}
#if 0
# 3202
{ 
# 3203
uint4 tmp; 
# 3204
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3205
(*retVal) = make_uchar1(tmp.x); 
# 3206
} 
#endif
# 3208 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3209
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3213
::exit(___);}
#if 0
# 3209
{ 
# 3210
uint4 tmp; 
# 3211
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3212
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 3213
} 
#endif
# 3215 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3216
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3220
::exit(___);}
#if 0
# 3216
{ 
# 3217
uint4 tmp; 
# 3218
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3219
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3220
} 
#endif
# 3228 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(short *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3229
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3233
::exit(___);}
#if 0
# 3229
{ 
# 3230
int4 tmp; 
# 3231
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3232
(*retVal) = ((short)(tmp.x)); 
# 3233
} 
#endif
# 3235 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3236
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3240
::exit(___);}
#if 0
# 3236
{ 
# 3237
int4 tmp; 
# 3238
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3239
(*retVal) = make_short1(tmp.x); 
# 3240
} 
#endif
# 3242 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3243
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3247
::exit(___);}
#if 0
# 3243
{ 
# 3244
int4 tmp; 
# 3245
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3246
(*retVal) = make_short2(tmp.x, tmp.y); 
# 3247
} 
#endif
# 3249 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3250
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3254
::exit(___);}
#if 0
# 3250
{ 
# 3251
int4 tmp; 
# 3252
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3253
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3254
} 
#endif
# 3256 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3257
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3261
::exit(___);}
#if 0
# 3257
{ 
# 3258
uint4 tmp; 
# 3259
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3260
(*retVal) = ((unsigned short)(tmp.x)); 
# 3261
} 
#endif
# 3263 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3264
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3268
::exit(___);}
#if 0
# 3264
{ 
# 3265
uint4 tmp; 
# 3266
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3267
(*retVal) = make_ushort1(tmp.x); 
# 3268
} 
#endif
# 3270 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3271
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3275
::exit(___);}
#if 0
# 3271
{ 
# 3272
uint4 tmp; 
# 3273
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3274
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 3275
} 
#endif
# 3277 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3278
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3282
::exit(___);}
#if 0
# 3278
{ 
# 3279
uint4 tmp; 
# 3280
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3281
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3282
} 
#endif
# 3290 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(int *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3291
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3295
::exit(___);}
#if 0
# 3291
{ 
# 3292
int4 tmp; 
# 3293
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3294
(*retVal) = ((int)(tmp.x)); 
# 3295
} 
#endif
# 3297 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3298
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3302
::exit(___);}
#if 0
# 3298
{ 
# 3299
int4 tmp; 
# 3300
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3301
(*retVal) = make_int1(tmp.x); 
# 3302
} 
#endif
# 3304 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3305
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3309
::exit(___);}
#if 0
# 3305
{ 
# 3306
int4 tmp; 
# 3307
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3308
(*retVal) = make_int2(tmp.x, tmp.y); 
# 3309
} 
#endif
# 3311 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3312
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3316
::exit(___);}
#if 0
# 3312
{ 
# 3313
int4 tmp; 
# 3314
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3315
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3316
} 
#endif
# 3318 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3319
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3323
::exit(___);}
#if 0
# 3319
{ 
# 3320
uint4 tmp; 
# 3321
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3322
(*retVal) = ((unsigned)(tmp.x)); 
# 3323
} 
#endif
# 3325 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3326
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3330
::exit(___);}
#if 0
# 3326
{ 
# 3327
uint4 tmp; 
# 3328
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3329
(*retVal) = make_uint1(tmp.x); 
# 3330
} 
#endif
# 3332 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3333
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3337
::exit(___);}
#if 0
# 3333
{ 
# 3334
uint4 tmp; 
# 3335
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3336
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 3337
} 
#endif
# 3339 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3340
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3344
::exit(___);}
#if 0
# 3340
{ 
# 3341
uint4 tmp; 
# 3342
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3343
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3344
} 
#endif
# 3419 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(float *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3420
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3424
::exit(___);}
#if 0
# 3420
{ 
# 3421
float4 tmp; 
# 3422
__tex_1d_level_v4f32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3423
(*retVal) = ((float)(tmp.x)); 
# 3424
} 
#endif
# 3426 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3427
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3431
::exit(___);}
#if 0
# 3427
{ 
# 3428
float4 tmp; 
# 3429
__tex_1d_level_v4f32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3430
(*retVal) = make_float1(tmp.x); 
# 3431
} 
#endif
# 3433 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3434
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3438
::exit(___);}
#if 0
# 3434
{ 
# 3435
float4 tmp; 
# 3436
__tex_1d_level_v4f32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3437
(*retVal) = make_float2(tmp.x, tmp.y); 
# 3438
} 
#endif
# 3440 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3441
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3445
::exit(___);}
#if 0
# 3441
{ 
# 3442
float4 tmp; 
# 3443
__tex_1d_level_v4f32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3444
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3445
} 
#endif
# 3453 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3454
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3463
::exit(___);}
#if 0
# 3454
{ 
# 3459
int4 tmp; 
# 3460
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3462
(*retVal) = ((char)(tmp.x)); 
# 3463
} 
#endif
# 3464 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3465
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3469
::exit(___);}
#if 0
# 3465
{ 
# 3466
int4 tmp; 
# 3467
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3468
(*retVal) = ((signed char)(tmp.x)); 
# 3469
} 
#endif
# 3471 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3472
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3476
::exit(___);}
#if 0
# 3472
{ 
# 3473
int4 tmp; 
# 3474
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3475
(*retVal) = make_char1(tmp.x); 
# 3476
} 
#endif
# 3478 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3479
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3483
::exit(___);}
#if 0
# 3479
{ 
# 3480
int4 tmp; 
# 3481
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3482
(*retVal) = make_char2(tmp.x, tmp.y); 
# 3483
} 
#endif
# 3485 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3486
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3490
::exit(___);}
#if 0
# 3486
{ 
# 3487
int4 tmp; 
# 3488
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3489
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3490
} 
#endif
# 3492 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3493
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3497
::exit(___);}
#if 0
# 3493
{ 
# 3494
uint4 tmp; 
# 3495
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3496
(*retVal) = ((unsigned char)(tmp.x)); 
# 3497
} 
#endif
# 3499 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3500
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3504
::exit(___);}
#if 0
# 3500
{ 
# 3501
uint4 tmp; 
# 3502
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3503
(*retVal) = make_uchar1(tmp.x); 
# 3504
} 
#endif
# 3506 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3507
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3511
::exit(___);}
#if 0
# 3507
{ 
# 3508
uint4 tmp; 
# 3509
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3510
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 3511
} 
#endif
# 3513 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3514
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3518
::exit(___);}
#if 0
# 3514
{ 
# 3515
uint4 tmp; 
# 3516
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3517
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3518
} 
#endif
# 3526 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3527
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3531
::exit(___);}
#if 0
# 3527
{ 
# 3528
int4 tmp; 
# 3529
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3530
(*retVal) = ((short)(tmp.x)); 
# 3531
} 
#endif
# 3533 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3534
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3538
::exit(___);}
#if 0
# 3534
{ 
# 3535
int4 tmp; 
# 3536
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3537
(*retVal) = make_short1(tmp.x); 
# 3538
} 
#endif
# 3540 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3541
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3545
::exit(___);}
#if 0
# 3541
{ 
# 3542
int4 tmp; 
# 3543
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3544
(*retVal) = make_short2(tmp.x, tmp.y); 
# 3545
} 
#endif
# 3547 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3548
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3552
::exit(___);}
#if 0
# 3548
{ 
# 3549
int4 tmp; 
# 3550
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3551
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3552
} 
#endif
# 3554 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3555
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3559
::exit(___);}
#if 0
# 3555
{ 
# 3556
uint4 tmp; 
# 3557
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3558
(*retVal) = ((unsigned short)(tmp.x)); 
# 3559
} 
#endif
# 3561 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3562
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3566
::exit(___);}
#if 0
# 3562
{ 
# 3563
uint4 tmp; 
# 3564
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3565
(*retVal) = make_ushort1(tmp.x); 
# 3566
} 
#endif
# 3568 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3569
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3573
::exit(___);}
#if 0
# 3569
{ 
# 3570
uint4 tmp; 
# 3571
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3572
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 3573
} 
#endif
# 3575 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3576
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3580
::exit(___);}
#if 0
# 3576
{ 
# 3577
uint4 tmp; 
# 3578
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3579
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3580
} 
#endif
# 3588 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3589
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3593
::exit(___);}
#if 0
# 3589
{ 
# 3590
int4 tmp; 
# 3591
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3592
(*retVal) = ((int)(tmp.x)); 
# 3593
} 
#endif
# 3595 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3596
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3600
::exit(___);}
#if 0
# 3596
{ 
# 3597
int4 tmp; 
# 3598
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3599
(*retVal) = make_int1(tmp.x); 
# 3600
} 
#endif
# 3602 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3603
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3607
::exit(___);}
#if 0
# 3603
{ 
# 3604
int4 tmp; 
# 3605
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3606
(*retVal) = make_int2(tmp.x, tmp.y); 
# 3607
} 
#endif
# 3609 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3610
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3614
::exit(___);}
#if 0
# 3610
{ 
# 3611
int4 tmp; 
# 3612
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3613
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3614
} 
#endif
# 3616 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3617
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3621
::exit(___);}
#if 0
# 3617
{ 
# 3618
uint4 tmp; 
# 3619
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3620
(*retVal) = ((unsigned)(tmp.x)); 
# 3621
} 
#endif
# 3623 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3624
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3628
::exit(___);}
#if 0
# 3624
{ 
# 3625
uint4 tmp; 
# 3626
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3627
(*retVal) = make_uint1(tmp.x); 
# 3628
} 
#endif
# 3630 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3631
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3635
::exit(___);}
#if 0
# 3631
{ 
# 3632
uint4 tmp; 
# 3633
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3634
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 3635
} 
#endif
# 3637 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3638
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3642
::exit(___);}
#if 0
# 3638
{ 
# 3639
uint4 tmp; 
# 3640
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3641
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3642
} 
#endif
# 3717 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3718
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3722
::exit(___);}
#if 0
# 3718
{ 
# 3719
float4 tmp; 
# 3720
__tex_2d_level_v4f32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3721
(*retVal) = ((float)(tmp.x)); 
# 3722
} 
#endif
# 3724 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3725
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3729
::exit(___);}
#if 0
# 3725
{ 
# 3726
float4 tmp; 
# 3727
__tex_2d_level_v4f32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3728
(*retVal) = make_float1(tmp.x); 
# 3729
} 
#endif
# 3731 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3732
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3736
::exit(___);}
#if 0
# 3732
{ 
# 3733
float4 tmp; 
# 3734
__tex_2d_level_v4f32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3735
(*retVal) = make_float2(tmp.x, tmp.y); 
# 3736
} 
#endif
# 3738 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3739
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3743
::exit(___);}
#if 0
# 3739
{ 
# 3740
float4 tmp; 
# 3741
__tex_2d_level_v4f32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3742
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3743
} 
#endif
# 3751 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3752
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3761
::exit(___);}
#if 0
# 3752
{ 
# 3757
int4 tmp; 
# 3758
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3760
(*retVal) = ((char)(tmp.x)); 
# 3761
} 
#endif
# 3762 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3763
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3767
::exit(___);}
#if 0
# 3763
{ 
# 3764
int4 tmp; 
# 3765
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3766
(*retVal) = ((signed char)(tmp.x)); 
# 3767
} 
#endif
# 3769 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3770
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3774
::exit(___);}
#if 0
# 3770
{ 
# 3771
int4 tmp; 
# 3772
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3773
(*retVal) = make_char1(tmp.x); 
# 3774
} 
#endif
# 3776 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3777
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3781
::exit(___);}
#if 0
# 3777
{ 
# 3778
int4 tmp; 
# 3779
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3780
(*retVal) = make_char2(tmp.x, tmp.y); 
# 3781
} 
#endif
# 3783 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3784
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3788
::exit(___);}
#if 0
# 3784
{ 
# 3785
int4 tmp; 
# 3786
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3787
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3788
} 
#endif
# 3790 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3791
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3795
::exit(___);}
#if 0
# 3791
{ 
# 3792
uint4 tmp; 
# 3793
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3794
(*retVal) = ((unsigned char)(tmp.x)); 
# 3795
} 
#endif
# 3797 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3798
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3802
::exit(___);}
#if 0
# 3798
{ 
# 3799
uint4 tmp; 
# 3800
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3801
(*retVal) = make_uchar1(tmp.x); 
# 3802
} 
#endif
# 3804 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3805
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3809
::exit(___);}
#if 0
# 3805
{ 
# 3806
uint4 tmp; 
# 3807
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3808
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 3809
} 
#endif
# 3811 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3812
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3816
::exit(___);}
#if 0
# 3812
{ 
# 3813
uint4 tmp; 
# 3814
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3815
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3816
} 
#endif
# 3824 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3825
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3829
::exit(___);}
#if 0
# 3825
{ 
# 3826
int4 tmp; 
# 3827
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3828
(*retVal) = ((short)(tmp.x)); 
# 3829
} 
#endif
# 3831 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3832
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3836
::exit(___);}
#if 0
# 3832
{ 
# 3833
int4 tmp; 
# 3834
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3835
(*retVal) = make_short1(tmp.x); 
# 3836
} 
#endif
# 3838 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3839
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3843
::exit(___);}
#if 0
# 3839
{ 
# 3840
int4 tmp; 
# 3841
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3842
(*retVal) = make_short2(tmp.x, tmp.y); 
# 3843
} 
#endif
# 3845 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3846
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3850
::exit(___);}
#if 0
# 3846
{ 
# 3847
int4 tmp; 
# 3848
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3849
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3850
} 
#endif
# 3852 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3853
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3857
::exit(___);}
#if 0
# 3853
{ 
# 3854
uint4 tmp; 
# 3855
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3856
(*retVal) = ((unsigned short)(tmp.x)); 
# 3857
} 
#endif
# 3859 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3860
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3864
::exit(___);}
#if 0
# 3860
{ 
# 3861
uint4 tmp; 
# 3862
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3863
(*retVal) = make_ushort1(tmp.x); 
# 3864
} 
#endif
# 3866 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3867
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3871
::exit(___);}
#if 0
# 3867
{ 
# 3868
uint4 tmp; 
# 3869
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3870
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 3871
} 
#endif
# 3873 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3874
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3878
::exit(___);}
#if 0
# 3874
{ 
# 3875
uint4 tmp; 
# 3876
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3877
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3878
} 
#endif
# 3886 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3887
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3891
::exit(___);}
#if 0
# 3887
{ 
# 3888
int4 tmp; 
# 3889
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3890
(*retVal) = ((int)(tmp.x)); 
# 3891
} 
#endif
# 3893 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3894
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3898
::exit(___);}
#if 0
# 3894
{ 
# 3895
int4 tmp; 
# 3896
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3897
(*retVal) = make_int1(tmp.x); 
# 3898
} 
#endif
# 3900 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3901
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3905
::exit(___);}
#if 0
# 3901
{ 
# 3902
int4 tmp; 
# 3903
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3904
(*retVal) = make_int2(tmp.x, tmp.y); 
# 3905
} 
#endif
# 3907 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3908
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3912
::exit(___);}
#if 0
# 3908
{ 
# 3909
int4 tmp; 
# 3910
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3911
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3912
} 
#endif
# 3914 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3915
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3919
::exit(___);}
#if 0
# 3915
{ 
# 3916
uint4 tmp; 
# 3917
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3918
(*retVal) = ((unsigned)(tmp.x)); 
# 3919
} 
#endif
# 3921 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3922
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3926
::exit(___);}
#if 0
# 3922
{ 
# 3923
uint4 tmp; 
# 3924
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3925
(*retVal) = make_uint1(tmp.x); 
# 3926
} 
#endif
# 3928 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3929
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3933
::exit(___);}
#if 0
# 3929
{ 
# 3930
uint4 tmp; 
# 3931
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3932
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 3933
} 
#endif
# 3935 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3936
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3940
::exit(___);}
#if 0
# 3936
{ 
# 3937
uint4 tmp; 
# 3938
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 3939
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3940
} 
#endif
# 4015 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4016
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4020
::exit(___);}
#if 0
# 4016
{ 
# 4017
float4 tmp; 
# 4018
__tex_3d_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4019
(*retVal) = ((float)(tmp.x)); 
# 4020
} 
#endif
# 4022 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4023
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4027
::exit(___);}
#if 0
# 4023
{ 
# 4024
float4 tmp; 
# 4025
__tex_3d_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4026
(*retVal) = make_float1(tmp.x); 
# 4027
} 
#endif
# 4029 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4030
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4034
::exit(___);}
#if 0
# 4030
{ 
# 4031
float4 tmp; 
# 4032
__tex_3d_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4033
(*retVal) = make_float2(tmp.x, tmp.y); 
# 4034
} 
#endif
# 4036 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4037
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4041
::exit(___);}
#if 0
# 4037
{ 
# 4038
float4 tmp; 
# 4039
__tex_3d_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4040
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4041
} 
#endif
# 4049 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4050
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4059
::exit(___);}
#if 0
# 4050
{ 
# 4055
int4 tmp; 
# 4056
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4058
(*retVal) = ((char)(tmp.x)); 
# 4059
} 
#endif
# 4060 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4061
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4065
::exit(___);}
#if 0
# 4061
{ 
# 4062
int4 tmp; 
# 4063
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4064
(*retVal) = ((signed char)(tmp.x)); 
# 4065
} 
#endif
# 4067 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4068
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4072
::exit(___);}
#if 0
# 4068
{ 
# 4069
int4 tmp; 
# 4070
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4071
(*retVal) = make_char1(tmp.x); 
# 4072
} 
#endif
# 4074 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4075
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4079
::exit(___);}
#if 0
# 4075
{ 
# 4076
int4 tmp; 
# 4077
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4078
(*retVal) = make_char2(tmp.x, tmp.y); 
# 4079
} 
#endif
# 4081 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4082
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4086
::exit(___);}
#if 0
# 4082
{ 
# 4083
int4 tmp; 
# 4084
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4085
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4086
} 
#endif
# 4088 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4089
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4093
::exit(___);}
#if 0
# 4089
{ 
# 4090
uint4 tmp; 
# 4091
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4092
(*retVal) = ((unsigned char)(tmp.x)); 
# 4093
} 
#endif
# 4095 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4096
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4100
::exit(___);}
#if 0
# 4096
{ 
# 4097
uint4 tmp; 
# 4098
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4099
(*retVal) = make_uchar1(tmp.x); 
# 4100
} 
#endif
# 4102 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4103
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4107
::exit(___);}
#if 0
# 4103
{ 
# 4104
uint4 tmp; 
# 4105
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4106
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 4107
} 
#endif
# 4109 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4110
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4114
::exit(___);}
#if 0
# 4110
{ 
# 4111
uint4 tmp; 
# 4112
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4113
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4114
} 
#endif
# 4122 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4123
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4127
::exit(___);}
#if 0
# 4123
{ 
# 4124
int4 tmp; 
# 4125
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4126
(*retVal) = ((short)(tmp.x)); 
# 4127
} 
#endif
# 4129 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4130
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4134
::exit(___);}
#if 0
# 4130
{ 
# 4131
int4 tmp; 
# 4132
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4133
(*retVal) = make_short1(tmp.x); 
# 4134
} 
#endif
# 4136 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4137
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4141
::exit(___);}
#if 0
# 4137
{ 
# 4138
int4 tmp; 
# 4139
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4140
(*retVal) = make_short2(tmp.x, tmp.y); 
# 4141
} 
#endif
# 4143 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4144
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4148
::exit(___);}
#if 0
# 4144
{ 
# 4145
int4 tmp; 
# 4146
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4147
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4148
} 
#endif
# 4150 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4151
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4155
::exit(___);}
#if 0
# 4151
{ 
# 4152
uint4 tmp; 
# 4153
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4154
(*retVal) = ((unsigned short)(tmp.x)); 
# 4155
} 
#endif
# 4157 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4158
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4162
::exit(___);}
#if 0
# 4158
{ 
# 4159
uint4 tmp; 
# 4160
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4161
(*retVal) = make_ushort1(tmp.x); 
# 4162
} 
#endif
# 4164 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4165
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4169
::exit(___);}
#if 0
# 4165
{ 
# 4166
uint4 tmp; 
# 4167
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4168
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 4169
} 
#endif
# 4171 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4172
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4176
::exit(___);}
#if 0
# 4172
{ 
# 4173
uint4 tmp; 
# 4174
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4175
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4176
} 
#endif
# 4184 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4185
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4189
::exit(___);}
#if 0
# 4185
{ 
# 4186
int4 tmp; 
# 4187
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4188
(*retVal) = ((int)(tmp.x)); 
# 4189
} 
#endif
# 4191 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4192
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4196
::exit(___);}
#if 0
# 4192
{ 
# 4193
int4 tmp; 
# 4194
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4195
(*retVal) = make_int1(tmp.x); 
# 4196
} 
#endif
# 4198 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4199
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4203
::exit(___);}
#if 0
# 4199
{ 
# 4200
int4 tmp; 
# 4201
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4202
(*retVal) = make_int2(tmp.x, tmp.y); 
# 4203
} 
#endif
# 4205 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4206
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4210
::exit(___);}
#if 0
# 4206
{ 
# 4207
int4 tmp; 
# 4208
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4209
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4210
} 
#endif
# 4212 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(unsigned *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4213
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4217
::exit(___);}
#if 0
# 4213
{ 
# 4214
uint4 tmp; 
# 4215
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4216
(*retVal) = ((unsigned)(tmp.x)); 
# 4217
} 
#endif
# 4219 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4220
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4224
::exit(___);}
#if 0
# 4220
{ 
# 4221
uint4 tmp; 
# 4222
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4223
(*retVal) = make_uint1(tmp.x); 
# 4224
} 
#endif
# 4226 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4227
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4231
::exit(___);}
#if 0
# 4227
{ 
# 4228
uint4 tmp; 
# 4229
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4230
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 4231
} 
#endif
# 4233 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4234
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4238
::exit(___);}
#if 0
# 4234
{ 
# 4235
uint4 tmp; 
# 4236
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4237
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4238
} 
#endif
# 4313 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4314
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4318
::exit(___);}
#if 0
# 4314
{ 
# 4315
float4 tmp; 
# 4316
__tex_1d_array_level_v4f32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4317
(*retVal) = ((float)(tmp.x)); 
# 4318
} 
#endif
# 4320 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4321
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4325
::exit(___);}
#if 0
# 4321
{ 
# 4322
float4 tmp; 
# 4323
__tex_1d_array_level_v4f32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4324
(*retVal) = make_float1(tmp.x); 
# 4325
} 
#endif
# 4327 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4328
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4332
::exit(___);}
#if 0
# 4328
{ 
# 4329
float4 tmp; 
# 4330
__tex_1d_array_level_v4f32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4331
(*retVal) = make_float2(tmp.x, tmp.y); 
# 4332
} 
#endif
# 4334 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4335
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4339
::exit(___);}
#if 0
# 4335
{ 
# 4336
float4 tmp; 
# 4337
__tex_1d_array_level_v4f32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4338
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4339
} 
#endif
# 4347 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4348
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4357
::exit(___);}
#if 0
# 4348
{ 
# 4353
int4 tmp; 
# 4354
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4356
(*retVal) = ((char)(tmp.x)); 
# 4357
} 
#endif
# 4358 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4359
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4363
::exit(___);}
#if 0
# 4359
{ 
# 4360
int4 tmp; 
# 4361
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4362
(*retVal) = ((signed char)(tmp.x)); 
# 4363
} 
#endif
# 4365 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4366
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4370
::exit(___);}
#if 0
# 4366
{ 
# 4367
int4 tmp; 
# 4368
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4369
(*retVal) = make_char1(tmp.x); 
# 4370
} 
#endif
# 4372 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4373
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4377
::exit(___);}
#if 0
# 4373
{ 
# 4374
int4 tmp; 
# 4375
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4376
(*retVal) = make_char2(tmp.x, tmp.y); 
# 4377
} 
#endif
# 4379 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4380
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4384
::exit(___);}
#if 0
# 4380
{ 
# 4381
int4 tmp; 
# 4382
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4383
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4384
} 
#endif
# 4386 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4387
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4391
::exit(___);}
#if 0
# 4387
{ 
# 4388
uint4 tmp; 
# 4389
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4390
(*retVal) = ((unsigned char)(tmp.x)); 
# 4391
} 
#endif
# 4393 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4394
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4398
::exit(___);}
#if 0
# 4394
{ 
# 4395
uint4 tmp; 
# 4396
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4397
(*retVal) = make_uchar1(tmp.x); 
# 4398
} 
#endif
# 4400 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4401
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4405
::exit(___);}
#if 0
# 4401
{ 
# 4402
uint4 tmp; 
# 4403
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4404
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 4405
} 
#endif
# 4407 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4408
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4412
::exit(___);}
#if 0
# 4408
{ 
# 4409
uint4 tmp; 
# 4410
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4411
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4412
} 
#endif
# 4420 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4421
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4425
::exit(___);}
#if 0
# 4421
{ 
# 4422
int4 tmp; 
# 4423
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4424
(*retVal) = ((short)(tmp.x)); 
# 4425
} 
#endif
# 4427 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4428
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4432
::exit(___);}
#if 0
# 4428
{ 
# 4429
int4 tmp; 
# 4430
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4431
(*retVal) = make_short1(tmp.x); 
# 4432
} 
#endif
# 4434 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4435
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4439
::exit(___);}
#if 0
# 4435
{ 
# 4436
int4 tmp; 
# 4437
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4438
(*retVal) = make_short2(tmp.x, tmp.y); 
# 4439
} 
#endif
# 4441 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4442
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4446
::exit(___);}
#if 0
# 4442
{ 
# 4443
int4 tmp; 
# 4444
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4445
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4446
} 
#endif
# 4448 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4449
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4453
::exit(___);}
#if 0
# 4449
{ 
# 4450
uint4 tmp; 
# 4451
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4452
(*retVal) = ((unsigned short)(tmp.x)); 
# 4453
} 
#endif
# 4455 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4456
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4460
::exit(___);}
#if 0
# 4456
{ 
# 4457
uint4 tmp; 
# 4458
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4459
(*retVal) = make_ushort1(tmp.x); 
# 4460
} 
#endif
# 4462 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4463
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4467
::exit(___);}
#if 0
# 4463
{ 
# 4464
uint4 tmp; 
# 4465
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4466
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 4467
} 
#endif
# 4469 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4470
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4474
::exit(___);}
#if 0
# 4470
{ 
# 4471
uint4 tmp; 
# 4472
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4473
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4474
} 
#endif
# 4482 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4483
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4487
::exit(___);}
#if 0
# 4483
{ 
# 4484
int4 tmp; 
# 4485
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4486
(*retVal) = ((int)(tmp.x)); 
# 4487
} 
#endif
# 4489 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4490
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4494
::exit(___);}
#if 0
# 4490
{ 
# 4491
int4 tmp; 
# 4492
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4493
(*retVal) = make_int1(tmp.x); 
# 4494
} 
#endif
# 4496 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4497
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4501
::exit(___);}
#if 0
# 4497
{ 
# 4498
int4 tmp; 
# 4499
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4500
(*retVal) = make_int2(tmp.x, tmp.y); 
# 4501
} 
#endif
# 4503 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4504
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4508
::exit(___);}
#if 0
# 4504
{ 
# 4505
int4 tmp; 
# 4506
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4507
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4508
} 
#endif
# 4510 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4511
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4515
::exit(___);}
#if 0
# 4511
{ 
# 4512
uint4 tmp; 
# 4513
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4514
(*retVal) = ((unsigned)(tmp.x)); 
# 4515
} 
#endif
# 4517 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4518
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4522
::exit(___);}
#if 0
# 4518
{ 
# 4519
uint4 tmp; 
# 4520
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4521
(*retVal) = make_uint1(tmp.x); 
# 4522
} 
#endif
# 4524 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4525
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4529
::exit(___);}
#if 0
# 4525
{ 
# 4526
uint4 tmp; 
# 4527
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4528
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 4529
} 
#endif
# 4531 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4532
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4536
::exit(___);}
#if 0
# 4532
{ 
# 4533
uint4 tmp; 
# 4534
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4535
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4536
} 
#endif
# 4611 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4612
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4616
::exit(___);}
#if 0
# 4612
{ 
# 4613
float4 tmp; 
# 4614
__tex_2d_array_level_v4f32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4615
(*retVal) = ((float)(tmp.x)); 
# 4616
} 
#endif
# 4618 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4619
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4623
::exit(___);}
#if 0
# 4619
{ 
# 4620
float4 tmp; 
# 4621
__tex_2d_array_level_v4f32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4622
(*retVal) = make_float1(tmp.x); 
# 4623
} 
#endif
# 4625 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4626
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4630
::exit(___);}
#if 0
# 4626
{ 
# 4627
float4 tmp; 
# 4628
__tex_2d_array_level_v4f32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4629
(*retVal) = make_float2(tmp.x, tmp.y); 
# 4630
} 
#endif
# 4632 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4633
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4637
::exit(___);}
#if 0
# 4633
{ 
# 4634
float4 tmp; 
# 4635
__tex_2d_array_level_v4f32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4636
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4637
} 
#endif
# 4645 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4646
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4655
::exit(___);}
#if 0
# 4646
{ 
# 4651
int4 tmp; 
# 4652
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4654
(*retVal) = ((char)(tmp.x)); 
# 4655
} 
#endif
# 4656 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4657
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4661
::exit(___);}
#if 0
# 4657
{ 
# 4658
int4 tmp; 
# 4659
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4660
(*retVal) = ((signed char)(tmp.x)); 
# 4661
} 
#endif
# 4663 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4664
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4668
::exit(___);}
#if 0
# 4664
{ 
# 4665
int4 tmp; 
# 4666
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4667
(*retVal) = make_char1(tmp.x); 
# 4668
} 
#endif
# 4670 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4671
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4675
::exit(___);}
#if 0
# 4671
{ 
# 4672
int4 tmp; 
# 4673
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4674
(*retVal) = make_char2(tmp.x, tmp.y); 
# 4675
} 
#endif
# 4677 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4678
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4682
::exit(___);}
#if 0
# 4678
{ 
# 4679
int4 tmp; 
# 4680
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4681
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4682
} 
#endif
# 4684 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4685
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4689
::exit(___);}
#if 0
# 4685
{ 
# 4686
uint4 tmp; 
# 4687
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4688
(*retVal) = ((unsigned char)(tmp.x)); 
# 4689
} 
#endif
# 4691 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4692
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4696
::exit(___);}
#if 0
# 4692
{ 
# 4693
uint4 tmp; 
# 4694
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4695
(*retVal) = make_uchar1(tmp.x); 
# 4696
} 
#endif
# 4698 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4699
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4703
::exit(___);}
#if 0
# 4699
{ 
# 4700
uint4 tmp; 
# 4701
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4702
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 4703
} 
#endif
# 4705 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4706
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4710
::exit(___);}
#if 0
# 4706
{ 
# 4707
uint4 tmp; 
# 4708
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4709
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4710
} 
#endif
# 4718 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4719
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4723
::exit(___);}
#if 0
# 4719
{ 
# 4720
int4 tmp; 
# 4721
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4722
(*retVal) = ((short)(tmp.x)); 
# 4723
} 
#endif
# 4725 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4726
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4730
::exit(___);}
#if 0
# 4726
{ 
# 4727
int4 tmp; 
# 4728
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4729
(*retVal) = make_short1(tmp.x); 
# 4730
} 
#endif
# 4732 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4733
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4737
::exit(___);}
#if 0
# 4733
{ 
# 4734
int4 tmp; 
# 4735
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4736
(*retVal) = make_short2(tmp.x, tmp.y); 
# 4737
} 
#endif
# 4739 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4740
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4744
::exit(___);}
#if 0
# 4740
{ 
# 4741
int4 tmp; 
# 4742
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4743
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4744
} 
#endif
# 4746 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4747
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4751
::exit(___);}
#if 0
# 4747
{ 
# 4748
uint4 tmp; 
# 4749
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4750
(*retVal) = ((unsigned short)(tmp.x)); 
# 4751
} 
#endif
# 4753 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4754
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4758
::exit(___);}
#if 0
# 4754
{ 
# 4755
uint4 tmp; 
# 4756
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4757
(*retVal) = make_ushort1(tmp.x); 
# 4758
} 
#endif
# 4760 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4761
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4765
::exit(___);}
#if 0
# 4761
{ 
# 4762
uint4 tmp; 
# 4763
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4764
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 4765
} 
#endif
# 4767 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4768
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4772
::exit(___);}
#if 0
# 4768
{ 
# 4769
uint4 tmp; 
# 4770
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4771
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4772
} 
#endif
# 4780 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4781
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4785
::exit(___);}
#if 0
# 4781
{ 
# 4782
int4 tmp; 
# 4783
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4784
(*retVal) = ((int)(tmp.x)); 
# 4785
} 
#endif
# 4787 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4788
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4792
::exit(___);}
#if 0
# 4788
{ 
# 4789
int4 tmp; 
# 4790
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4791
(*retVal) = make_int1(tmp.x); 
# 4792
} 
#endif
# 4794 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4795
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4799
::exit(___);}
#if 0
# 4795
{ 
# 4796
int4 tmp; 
# 4797
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4798
(*retVal) = make_int2(tmp.x, tmp.y); 
# 4799
} 
#endif
# 4801 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4802
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4806
::exit(___);}
#if 0
# 4802
{ 
# 4803
int4 tmp; 
# 4804
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4805
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4806
} 
#endif
# 4808 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4809
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4813
::exit(___);}
#if 0
# 4809
{ 
# 4810
uint4 tmp; 
# 4811
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4812
(*retVal) = ((unsigned)(tmp.x)); 
# 4813
} 
#endif
# 4815 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4816
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4820
::exit(___);}
#if 0
# 4816
{ 
# 4817
uint4 tmp; 
# 4818
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4819
(*retVal) = make_uint1(tmp.x); 
# 4820
} 
#endif
# 4822 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4823
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4827
::exit(___);}
#if 0
# 4823
{ 
# 4824
uint4 tmp; 
# 4825
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4826
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 4827
} 
#endif
# 4829 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4830
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4834
::exit(___);}
#if 0
# 4830
{ 
# 4831
uint4 tmp; 
# 4832
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4833
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4834
} 
#endif
# 4909 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4910
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4914
::exit(___);}
#if 0
# 4910
{ 
# 4911
float4 tmp; 
# 4912
__tex_cube_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4913
(*retVal) = ((float)(tmp.x)); 
# 4914
} 
#endif
# 4916 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4917
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4921
::exit(___);}
#if 0
# 4917
{ 
# 4918
float4 tmp; 
# 4919
__tex_cube_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4920
(*retVal) = make_float1(tmp.x); 
# 4921
} 
#endif
# 4923 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4924
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4928
::exit(___);}
#if 0
# 4924
{ 
# 4925
float4 tmp; 
# 4926
__tex_cube_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4927
(*retVal) = make_float2(tmp.x, tmp.y); 
# 4928
} 
#endif
# 4930 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4931
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4935
::exit(___);}
#if 0
# 4931
{ 
# 4932
float4 tmp; 
# 4933
__tex_cube_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4934
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4935
} 
#endif
# 4943 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 4944
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 4953
::exit(___);}
#if 0
# 4944
{ 
# 4949
int4 tmp; 
# 4950
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4952
(*retVal) = ((char)(tmp.x)); 
# 4953
} 
#endif
# 4954 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 4955
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 4959
::exit(___);}
#if 0
# 4955
{ 
# 4956
int4 tmp; 
# 4957
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4958
(*retVal) = ((signed char)(tmp.x)); 
# 4959
} 
#endif
# 4961 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 4962
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 4966
::exit(___);}
#if 0
# 4962
{ 
# 4963
int4 tmp; 
# 4964
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4965
(*retVal) = make_char1(tmp.x); 
# 4966
} 
#endif
# 4968 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 4969
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 4973
::exit(___);}
#if 0
# 4969
{ 
# 4970
int4 tmp; 
# 4971
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4972
(*retVal) = make_char2(tmp.x, tmp.y); 
# 4973
} 
#endif
# 4975 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 4976
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 4980
::exit(___);}
#if 0
# 4976
{ 
# 4977
int4 tmp; 
# 4978
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4979
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4980
} 
#endif
# 4982 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 4983
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 4987
::exit(___);}
#if 0
# 4983
{ 
# 4984
uint4 tmp; 
# 4985
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4986
(*retVal) = ((unsigned char)(tmp.x)); 
# 4987
} 
#endif
# 4989 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 4990
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 4994
::exit(___);}
#if 0
# 4990
{ 
# 4991
uint4 tmp; 
# 4992
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 4993
(*retVal) = make_uchar1(tmp.x); 
# 4994
} 
#endif
# 4996 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 4997
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5001
::exit(___);}
#if 0
# 4997
{ 
# 4998
uint4 tmp; 
# 4999
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5000
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 5001
} 
#endif
# 5003 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5004
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5008
::exit(___);}
#if 0
# 5004
{ 
# 5005
uint4 tmp; 
# 5006
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5007
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5008
} 
#endif
# 5016 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5017
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5021
::exit(___);}
#if 0
# 5017
{ 
# 5018
int4 tmp; 
# 5019
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5020
(*retVal) = ((short)(tmp.x)); 
# 5021
} 
#endif
# 5023 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5024
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5028
::exit(___);}
#if 0
# 5024
{ 
# 5025
int4 tmp; 
# 5026
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5027
(*retVal) = make_short1(tmp.x); 
# 5028
} 
#endif
# 5030 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5031
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5035
::exit(___);}
#if 0
# 5031
{ 
# 5032
int4 tmp; 
# 5033
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5034
(*retVal) = make_short2(tmp.x, tmp.y); 
# 5035
} 
#endif
# 5037 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5038
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5042
::exit(___);}
#if 0
# 5038
{ 
# 5039
int4 tmp; 
# 5040
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5041
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5042
} 
#endif
# 5044 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5045
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5049
::exit(___);}
#if 0
# 5045
{ 
# 5046
uint4 tmp; 
# 5047
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5048
(*retVal) = ((unsigned short)(tmp.x)); 
# 5049
} 
#endif
# 5051 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5052
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5056
::exit(___);}
#if 0
# 5052
{ 
# 5053
uint4 tmp; 
# 5054
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5055
(*retVal) = make_ushort1(tmp.x); 
# 5056
} 
#endif
# 5058 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5059
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5063
::exit(___);}
#if 0
# 5059
{ 
# 5060
uint4 tmp; 
# 5061
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5062
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 5063
} 
#endif
# 5065 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5066
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5070
::exit(___);}
#if 0
# 5066
{ 
# 5067
uint4 tmp; 
# 5068
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5069
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5070
} 
#endif
# 5078 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5079
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5083
::exit(___);}
#if 0
# 5079
{ 
# 5080
int4 tmp; 
# 5081
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5082
(*retVal) = ((int)(tmp.x)); 
# 5083
} 
#endif
# 5085 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5086
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5090
::exit(___);}
#if 0
# 5086
{ 
# 5087
int4 tmp; 
# 5088
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5089
(*retVal) = make_int1(tmp.x); 
# 5090
} 
#endif
# 5092 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5093
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5097
::exit(___);}
#if 0
# 5093
{ 
# 5094
int4 tmp; 
# 5095
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5096
(*retVal) = make_int2(tmp.x, tmp.y); 
# 5097
} 
#endif
# 5099 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5100
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5104
::exit(___);}
#if 0
# 5100
{ 
# 5101
int4 tmp; 
# 5102
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5103
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5104
} 
#endif
# 5106 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5107
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5111
::exit(___);}
#if 0
# 5107
{ 
# 5108
uint4 tmp; 
# 5109
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5110
(*retVal) = ((unsigned)(tmp.x)); 
# 5111
} 
#endif
# 5113 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5114
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5118
::exit(___);}
#if 0
# 5114
{ 
# 5115
uint4 tmp; 
# 5116
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5117
(*retVal) = make_uint1(tmp.x); 
# 5118
} 
#endif
# 5120 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5121
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5125
::exit(___);}
#if 0
# 5121
{ 
# 5122
uint4 tmp; 
# 5123
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5124
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 5125
} 
#endif
# 5127 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5128
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5132
::exit(___);}
#if 0
# 5128
{ 
# 5129
uint4 tmp; 
# 5130
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5131
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5132
} 
#endif
# 5207 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5208
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5212
::exit(___);}
#if 0
# 5208
{ 
# 5209
float4 tmp; 
# 5210
__tex_cube_array_level_v4f32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5211
(*retVal) = ((float)(tmp.x)); 
# 5212
} 
#endif
# 5214 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5215
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5219
::exit(___);}
#if 0
# 5215
{ 
# 5216
float4 tmp; 
# 5217
__tex_cube_array_level_v4f32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5218
(*retVal) = make_float1(tmp.x); 
# 5219
} 
#endif
# 5221 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5222
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5226
::exit(___);}
#if 0
# 5222
{ 
# 5223
float4 tmp; 
# 5224
__tex_cube_array_level_v4f32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5225
(*retVal) = make_float2(tmp.x, tmp.y); 
# 5226
} 
#endif
# 5228 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5229
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5233
::exit(___);}
#if 0
# 5229
{ 
# 5230
float4 tmp; 
# 5231
__tex_cube_array_level_v4f32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5232
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5233
} 
#endif
# 5241 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5242
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5251
::exit(___);}
#if 0
# 5242
{ 
# 5247
int4 tmp; 
# 5248
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5250
(*retVal) = ((char)(tmp.x)); 
# 5251
} 
#endif
# 5252 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5253
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5257
::exit(___);}
#if 0
# 5253
{ 
# 5254
int4 tmp; 
# 5255
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5256
(*retVal) = ((signed char)(tmp.x)); 
# 5257
} 
#endif
# 5259 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5260
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5264
::exit(___);}
#if 0
# 5260
{ 
# 5261
int4 tmp; 
# 5262
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5263
(*retVal) = make_char1(tmp.x); 
# 5264
} 
#endif
# 5266 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5267
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5271
::exit(___);}
#if 0
# 5267
{ 
# 5268
int4 tmp; 
# 5269
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5270
(*retVal) = make_char2(tmp.x, tmp.y); 
# 5271
} 
#endif
# 5273 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5274
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5278
::exit(___);}
#if 0
# 5274
{ 
# 5275
int4 tmp; 
# 5276
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5277
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5278
} 
#endif
# 5280 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5281
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5285
::exit(___);}
#if 0
# 5281
{ 
# 5282
uint4 tmp; 
# 5283
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5284
(*retVal) = ((unsigned char)(tmp.x)); 
# 5285
} 
#endif
# 5287 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5288
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5292
::exit(___);}
#if 0
# 5288
{ 
# 5289
uint4 tmp; 
# 5290
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5291
(*retVal) = make_uchar1(tmp.x); 
# 5292
} 
#endif
# 5294 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5295
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5299
::exit(___);}
#if 0
# 5295
{ 
# 5296
uint4 tmp; 
# 5297
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5298
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 5299
} 
#endif
# 5301 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5302
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5306
::exit(___);}
#if 0
# 5302
{ 
# 5303
uint4 tmp; 
# 5304
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5305
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5306
} 
#endif
# 5314 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5315
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5319
::exit(___);}
#if 0
# 5315
{ 
# 5316
int4 tmp; 
# 5317
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5318
(*retVal) = ((short)(tmp.x)); 
# 5319
} 
#endif
# 5321 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5322
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5326
::exit(___);}
#if 0
# 5322
{ 
# 5323
int4 tmp; 
# 5324
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5325
(*retVal) = make_short1(tmp.x); 
# 5326
} 
#endif
# 5328 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5329
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5333
::exit(___);}
#if 0
# 5329
{ 
# 5330
int4 tmp; 
# 5331
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5332
(*retVal) = make_short2(tmp.x, tmp.y); 
# 5333
} 
#endif
# 5335 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5336
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5340
::exit(___);}
#if 0
# 5336
{ 
# 5337
int4 tmp; 
# 5338
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5339
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5340
} 
#endif
# 5342 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5343
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5347
::exit(___);}
#if 0
# 5343
{ 
# 5344
uint4 tmp; 
# 5345
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5346
(*retVal) = ((unsigned short)(tmp.x)); 
# 5347
} 
#endif
# 5349 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5350
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5354
::exit(___);}
#if 0
# 5350
{ 
# 5351
uint4 tmp; 
# 5352
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5353
(*retVal) = make_ushort1(tmp.x); 
# 5354
} 
#endif
# 5356 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5357
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5361
::exit(___);}
#if 0
# 5357
{ 
# 5358
uint4 tmp; 
# 5359
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5360
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 5361
} 
#endif
# 5363 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5364
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5368
::exit(___);}
#if 0
# 5364
{ 
# 5365
uint4 tmp; 
# 5366
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5367
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5368
} 
#endif
# 5376 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(int *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5377
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5381
::exit(___);}
#if 0
# 5377
{ 
# 5378
int4 tmp; 
# 5379
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5380
(*retVal) = ((int)(tmp.x)); 
# 5381
} 
#endif
# 5383 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5384
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5388
::exit(___);}
#if 0
# 5384
{ 
# 5385
int4 tmp; 
# 5386
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5387
(*retVal) = make_int1(tmp.x); 
# 5388
} 
#endif
# 5390 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5391
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5395
::exit(___);}
#if 0
# 5391
{ 
# 5392
int4 tmp; 
# 5393
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5394
(*retVal) = make_int2(tmp.x, tmp.y); 
# 5395
} 
#endif
# 5397 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5398
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5402
::exit(___);}
#if 0
# 5398
{ 
# 5399
int4 tmp; 
# 5400
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5401
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5402
} 
#endif
# 5404 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5405
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5409
::exit(___);}
#if 0
# 5405
{ 
# 5406
uint4 tmp; 
# 5407
__asm__ volatile("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5408
(*retVal) = ((unsigned)(tmp.x)); 
# 5409
} 
#endif
# 5411 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5412
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5416
::exit(___);}
#if 0
# 5412
{ 
# 5413
uint4 tmp; 
# 5414
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5415
(*retVal) = make_uint1(tmp.x); 
# 5416
} 
#endif
# 5418 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5419
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5423
::exit(___);}
#if 0
# 5419
{ 
# 5420
uint4 tmp; 
# 5421
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5422
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 5423
} 
#endif
# 5425 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5426
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5430
::exit(___);}
#if 0
# 5426
{ 
# 5427
uint4 tmp; 
# 5428
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5429
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5430
} 
#endif
# 5505 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(float *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5506
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5510
::exit(___);}
#if 0
# 5506
{ 
# 5507
float4 tmp; 
# 5508
__tex_1d_grad_v4f32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5509
(*retVal) = ((float)(tmp.x)); 
# 5510
} 
#endif
# 5512 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5513
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5517
::exit(___);}
#if 0
# 5513
{ 
# 5514
float4 tmp; 
# 5515
__tex_1d_grad_v4f32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5516
(*retVal) = make_float1(tmp.x); 
# 5517
} 
#endif
# 5519 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5520
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5524
::exit(___);}
#if 0
# 5520
{ 
# 5521
float4 tmp; 
# 5522
__tex_1d_grad_v4f32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5523
(*retVal) = make_float2(tmp.x, tmp.y); 
# 5524
} 
#endif
# 5526 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5527
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5531
::exit(___);}
#if 0
# 5527
{ 
# 5528
float4 tmp; 
# 5529
__tex_1d_grad_v4f32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5530
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5531
} 
#endif
# 5539 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5540
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5549
::exit(___);}
#if 0
# 5540
{ 
# 5545
int4 tmp; 
# 5546
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5548
(*retVal) = ((char)(tmp.x)); 
# 5549
} 
#endif
# 5550 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5551
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5555
::exit(___);}
#if 0
# 5551
{ 
# 5552
int4 tmp; 
# 5553
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5554
(*retVal) = ((signed char)(tmp.x)); 
# 5555
} 
#endif
# 5557 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5558
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5562
::exit(___);}
#if 0
# 5558
{ 
# 5559
int4 tmp; 
# 5560
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5561
(*retVal) = make_char1(tmp.x); 
# 5562
} 
#endif
# 5564 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5565
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5569
::exit(___);}
#if 0
# 5565
{ 
# 5566
int4 tmp; 
# 5567
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5568
(*retVal) = make_char2(tmp.x, tmp.y); 
# 5569
} 
#endif
# 5571 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5572
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5576
::exit(___);}
#if 0
# 5572
{ 
# 5573
int4 tmp; 
# 5574
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5575
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5576
} 
#endif
# 5578 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5579
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5583
::exit(___);}
#if 0
# 5579
{ 
# 5580
uint4 tmp; 
# 5581
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5582
(*retVal) = ((unsigned char)(tmp.x)); 
# 5583
} 
#endif
# 5585 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5586
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5590
::exit(___);}
#if 0
# 5586
{ 
# 5587
uint4 tmp; 
# 5588
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5589
(*retVal) = make_uchar1(tmp.x); 
# 5590
} 
#endif
# 5592 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5593
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5597
::exit(___);}
#if 0
# 5593
{ 
# 5594
uint4 tmp; 
# 5595
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5596
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 5597
} 
#endif
# 5599 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5600
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5604
::exit(___);}
#if 0
# 5600
{ 
# 5601
uint4 tmp; 
# 5602
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5603
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5604
} 
#endif
# 5612 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5613
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5617
::exit(___);}
#if 0
# 5613
{ 
# 5614
int4 tmp; 
# 5615
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5616
(*retVal) = ((short)(tmp.x)); 
# 5617
} 
#endif
# 5619 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5620
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5624
::exit(___);}
#if 0
# 5620
{ 
# 5621
int4 tmp; 
# 5622
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5623
(*retVal) = make_short1(tmp.x); 
# 5624
} 
#endif
# 5626 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5627
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5631
::exit(___);}
#if 0
# 5627
{ 
# 5628
int4 tmp; 
# 5629
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5630
(*retVal) = make_short2(tmp.x, tmp.y); 
# 5631
} 
#endif
# 5633 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5634
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5638
::exit(___);}
#if 0
# 5634
{ 
# 5635
int4 tmp; 
# 5636
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5637
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5638
} 
#endif
# 5640 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5641
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5645
::exit(___);}
#if 0
# 5641
{ 
# 5642
uint4 tmp; 
# 5643
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5644
(*retVal) = ((unsigned short)(tmp.x)); 
# 5645
} 
#endif
# 5647 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5648
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5652
::exit(___);}
#if 0
# 5648
{ 
# 5649
uint4 tmp; 
# 5650
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5651
(*retVal) = make_ushort1(tmp.x); 
# 5652
} 
#endif
# 5654 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5655
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5659
::exit(___);}
#if 0
# 5655
{ 
# 5656
uint4 tmp; 
# 5657
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5658
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 5659
} 
#endif
# 5661 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5662
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5666
::exit(___);}
#if 0
# 5662
{ 
# 5663
uint4 tmp; 
# 5664
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5665
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5666
} 
#endif
# 5674 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5675
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5679
::exit(___);}
#if 0
# 5675
{ 
# 5676
int4 tmp; 
# 5677
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5678
(*retVal) = ((int)(tmp.x)); 
# 5679
} 
#endif
# 5681 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5682
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5686
::exit(___);}
#if 0
# 5682
{ 
# 5683
int4 tmp; 
# 5684
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5685
(*retVal) = make_int1(tmp.x); 
# 5686
} 
#endif
# 5688 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5689
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5693
::exit(___);}
#if 0
# 5689
{ 
# 5690
int4 tmp; 
# 5691
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5692
(*retVal) = make_int2(tmp.x, tmp.y); 
# 5693
} 
#endif
# 5695 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5696
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5700
::exit(___);}
#if 0
# 5696
{ 
# 5697
int4 tmp; 
# 5698
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5699
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5700
} 
#endif
# 5702 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5703
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5707
::exit(___);}
#if 0
# 5703
{ 
# 5704
uint4 tmp; 
# 5705
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5706
(*retVal) = ((unsigned)(tmp.x)); 
# 5707
} 
#endif
# 5709 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5710
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5714
::exit(___);}
#if 0
# 5710
{ 
# 5711
uint4 tmp; 
# 5712
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5713
(*retVal) = make_uint1(tmp.x); 
# 5714
} 
#endif
# 5716 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5717
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5721
::exit(___);}
#if 0
# 5717
{ 
# 5718
uint4 tmp; 
# 5719
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5720
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 5721
} 
#endif
# 5723 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5724
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5728
::exit(___);}
#if 0
# 5724
{ 
# 5725
uint4 tmp; 
# 5726
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5727
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5728
} 
#endif
# 5803 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5804
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5808
::exit(___);}
#if 0
# 5804
{ 
# 5805
float4 tmp; 
# 5806
__tex_2d_grad_v4f32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5807
(*retVal) = ((float)(tmp.x)); 
# 5808
} 
#endif
# 5810 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5811
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5815
::exit(___);}
#if 0
# 5811
{ 
# 5812
float4 tmp; 
# 5813
__tex_2d_grad_v4f32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5814
(*retVal) = make_float1(tmp.x); 
# 5815
} 
#endif
# 5817 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5818
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5822
::exit(___);}
#if 0
# 5818
{ 
# 5819
float4 tmp; 
# 5820
__tex_2d_grad_v4f32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5821
(*retVal) = make_float2(tmp.x, tmp.y); 
# 5822
} 
#endif
# 5824 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5825
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5829
::exit(___);}
#if 0
# 5825
{ 
# 5826
float4 tmp; 
# 5827
__tex_2d_grad_v4f32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5828
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5829
} 
#endif
# 5837 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5838
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5847
::exit(___);}
#if 0
# 5838
{ 
# 5843
int4 tmp; 
# 5844
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5846
(*retVal) = ((char)(tmp.x)); 
# 5847
} 
#endif
# 5848 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5849
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5853
::exit(___);}
#if 0
# 5849
{ 
# 5850
int4 tmp; 
# 5851
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5852
(*retVal) = ((signed char)(tmp.x)); 
# 5853
} 
#endif
# 5855 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5856
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5860
::exit(___);}
#if 0
# 5856
{ 
# 5857
int4 tmp; 
# 5858
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5859
(*retVal) = make_char1(tmp.x); 
# 5860
} 
#endif
# 5862 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5863
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5867
::exit(___);}
#if 0
# 5863
{ 
# 5864
int4 tmp; 
# 5865
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5866
(*retVal) = make_char2(tmp.x, tmp.y); 
# 5867
} 
#endif
# 5869 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5870
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5874
::exit(___);}
#if 0
# 5870
{ 
# 5871
int4 tmp; 
# 5872
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5873
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5874
} 
#endif
# 5876 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5877
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5881
::exit(___);}
#if 0
# 5877
{ 
# 5878
uint4 tmp; 
# 5879
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5880
(*retVal) = ((unsigned char)(tmp.x)); 
# 5881
} 
#endif
# 5883 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5884
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5888
::exit(___);}
#if 0
# 5884
{ 
# 5885
uint4 tmp; 
# 5886
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5887
(*retVal) = make_uchar1(tmp.x); 
# 5888
} 
#endif
# 5890 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5891
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5895
::exit(___);}
#if 0
# 5891
{ 
# 5892
uint4 tmp; 
# 5893
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5894
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 5895
} 
#endif
# 5897 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5898
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5902
::exit(___);}
#if 0
# 5898
{ 
# 5899
uint4 tmp; 
# 5900
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5901
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5902
} 
#endif
# 5910 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5911
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5915
::exit(___);}
#if 0
# 5911
{ 
# 5912
int4 tmp; 
# 5913
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5914
(*retVal) = ((short)(tmp.x)); 
# 5915
} 
#endif
# 5917 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5918
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5922
::exit(___);}
#if 0
# 5918
{ 
# 5919
int4 tmp; 
# 5920
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5921
(*retVal) = make_short1(tmp.x); 
# 5922
} 
#endif
# 5924 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5925
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5929
::exit(___);}
#if 0
# 5925
{ 
# 5926
int4 tmp; 
# 5927
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5928
(*retVal) = make_short2(tmp.x, tmp.y); 
# 5929
} 
#endif
# 5931 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5932
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5936
::exit(___);}
#if 0
# 5932
{ 
# 5933
int4 tmp; 
# 5934
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5935
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5936
} 
#endif
# 5938 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5939
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5943
::exit(___);}
#if 0
# 5939
{ 
# 5940
uint4 tmp; 
# 5941
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5942
(*retVal) = ((unsigned short)(tmp.x)); 
# 5943
} 
#endif
# 5945 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5946
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5950
::exit(___);}
#if 0
# 5946
{ 
# 5947
uint4 tmp; 
# 5948
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5949
(*retVal) = make_ushort1(tmp.x); 
# 5950
} 
#endif
# 5952 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5953
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5957
::exit(___);}
#if 0
# 5953
{ 
# 5954
uint4 tmp; 
# 5955
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5956
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 5957
} 
#endif
# 5959 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5960
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5964
::exit(___);}
#if 0
# 5960
{ 
# 5961
uint4 tmp; 
# 5962
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5963
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5964
} 
#endif
# 5972 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5973
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5977
::exit(___);}
#if 0
# 5973
{ 
# 5974
int4 tmp; 
# 5975
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5976
(*retVal) = ((int)(tmp.x)); 
# 5977
} 
#endif
# 5979 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5980
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5984
::exit(___);}
#if 0
# 5980
{ 
# 5981
int4 tmp; 
# 5982
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5983
(*retVal) = make_int1(tmp.x); 
# 5984
} 
#endif
# 5986 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5987
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5991
::exit(___);}
#if 0
# 5987
{ 
# 5988
int4 tmp; 
# 5989
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5990
(*retVal) = make_int2(tmp.x, tmp.y); 
# 5991
} 
#endif
# 5993 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 5994
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 5998
::exit(___);}
#if 0
# 5994
{ 
# 5995
int4 tmp; 
# 5996
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 5997
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5998
} 
#endif
# 6000 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6001
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6005
::exit(___);}
#if 0
# 6001
{ 
# 6002
uint4 tmp; 
# 6003
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6004
(*retVal) = ((unsigned)(tmp.x)); 
# 6005
} 
#endif
# 6007 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6008
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6012
::exit(___);}
#if 0
# 6008
{ 
# 6009
uint4 tmp; 
# 6010
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6011
(*retVal) = make_uint1(tmp.x); 
# 6012
} 
#endif
# 6014 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6015
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6019
::exit(___);}
#if 0
# 6015
{ 
# 6016
uint4 tmp; 
# 6017
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6018
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 6019
} 
#endif
# 6021 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6022
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6026
::exit(___);}
#if 0
# 6022
{ 
# 6023
uint4 tmp; 
# 6024
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6025
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6026
} 
#endif
# 6101 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6102
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6106
::exit(___);}
#if 0
# 6102
{ 
# 6103
float4 tmp; 
# 6104
__tex_3d_grad_v4f32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6105
(*retVal) = ((float)(tmp.x)); 
# 6106
} 
#endif
# 6108 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6109
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6113
::exit(___);}
#if 0
# 6109
{ 
# 6110
float4 tmp; 
# 6111
__tex_3d_grad_v4f32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6112
(*retVal) = make_float1(tmp.x); 
# 6113
} 
#endif
# 6115 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6116
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6120
::exit(___);}
#if 0
# 6116
{ 
# 6117
float4 tmp; 
# 6118
__tex_3d_grad_v4f32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6119
(*retVal) = make_float2(tmp.x, tmp.y); 
# 6120
} 
#endif
# 6122 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6123
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6127
::exit(___);}
#if 0
# 6123
{ 
# 6124
float4 tmp; 
# 6125
__tex_3d_grad_v4f32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6126
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6127
} 
#endif
# 6135 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6136
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6145
::exit(___);}
#if 0
# 6136
{ 
# 6141
int4 tmp; 
# 6142
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6144
(*retVal) = ((char)(tmp.x)); 
# 6145
} 
#endif
# 6146 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6147
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6151
::exit(___);}
#if 0
# 6147
{ 
# 6148
int4 tmp; 
# 6149
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6150
(*retVal) = ((signed char)(tmp.x)); 
# 6151
} 
#endif
# 6153 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6154
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6158
::exit(___);}
#if 0
# 6154
{ 
# 6155
int4 tmp; 
# 6156
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6157
(*retVal) = make_char1(tmp.x); 
# 6158
} 
#endif
# 6160 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6161
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6165
::exit(___);}
#if 0
# 6161
{ 
# 6162
int4 tmp; 
# 6163
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6164
(*retVal) = make_char2(tmp.x, tmp.y); 
# 6165
} 
#endif
# 6167 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6168
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6172
::exit(___);}
#if 0
# 6168
{ 
# 6169
int4 tmp; 
# 6170
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6171
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6172
} 
#endif
# 6174 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6175
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6179
::exit(___);}
#if 0
# 6175
{ 
# 6176
uint4 tmp; 
# 6177
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6178
(*retVal) = ((unsigned char)(tmp.x)); 
# 6179
} 
#endif
# 6181 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6182
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6186
::exit(___);}
#if 0
# 6182
{ 
# 6183
uint4 tmp; 
# 6184
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6185
(*retVal) = make_uchar1(tmp.x); 
# 6186
} 
#endif
# 6188 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6189
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6193
::exit(___);}
#if 0
# 6189
{ 
# 6190
uint4 tmp; 
# 6191
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6192
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 6193
} 
#endif
# 6195 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6196
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6200
::exit(___);}
#if 0
# 6196
{ 
# 6197
uint4 tmp; 
# 6198
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6199
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6200
} 
#endif
# 6208 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6209
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6213
::exit(___);}
#if 0
# 6209
{ 
# 6210
int4 tmp; 
# 6211
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6212
(*retVal) = ((short)(tmp.x)); 
# 6213
} 
#endif
# 6215 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6216
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6220
::exit(___);}
#if 0
# 6216
{ 
# 6217
int4 tmp; 
# 6218
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6219
(*retVal) = make_short1(tmp.x); 
# 6220
} 
#endif
# 6222 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6223
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6227
::exit(___);}
#if 0
# 6223
{ 
# 6224
int4 tmp; 
# 6225
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6226
(*retVal) = make_short2(tmp.x, tmp.y); 
# 6227
} 
#endif
# 6229 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6230
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6234
::exit(___);}
#if 0
# 6230
{ 
# 6231
int4 tmp; 
# 6232
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6233
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6234
} 
#endif
# 6236 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6237
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6241
::exit(___);}
#if 0
# 6237
{ 
# 6238
uint4 tmp; 
# 6239
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6240
(*retVal) = ((unsigned short)(tmp.x)); 
# 6241
} 
#endif
# 6243 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6244
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6248
::exit(___);}
#if 0
# 6244
{ 
# 6245
uint4 tmp; 
# 6246
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6247
(*retVal) = make_ushort1(tmp.x); 
# 6248
} 
#endif
# 6250 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6251
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6255
::exit(___);}
#if 0
# 6251
{ 
# 6252
uint4 tmp; 
# 6253
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6254
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 6255
} 
#endif
# 6257 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6258
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6262
::exit(___);}
#if 0
# 6258
{ 
# 6259
uint4 tmp; 
# 6260
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6261
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6262
} 
#endif
# 6270 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6271
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6275
::exit(___);}
#if 0
# 6271
{ 
# 6272
int4 tmp; 
# 6273
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6274
(*retVal) = ((int)(tmp.x)); 
# 6275
} 
#endif
# 6277 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6278
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6282
::exit(___);}
#if 0
# 6278
{ 
# 6279
int4 tmp; 
# 6280
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6281
(*retVal) = make_int1(tmp.x); 
# 6282
} 
#endif
# 6284 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6285
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6289
::exit(___);}
#if 0
# 6285
{ 
# 6286
int4 tmp; 
# 6287
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6288
(*retVal) = make_int2(tmp.x, tmp.y); 
# 6289
} 
#endif
# 6291 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6292
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6296
::exit(___);}
#if 0
# 6292
{ 
# 6293
int4 tmp; 
# 6294
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6295
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6296
} 
#endif
# 6298 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6299
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6303
::exit(___);}
#if 0
# 6299
{ 
# 6300
uint4 tmp; 
# 6301
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6302
(*retVal) = ((unsigned)(tmp.x)); 
# 6303
} 
#endif
# 6305 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6306
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6310
::exit(___);}
#if 0
# 6306
{ 
# 6307
uint4 tmp; 
# 6308
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6309
(*retVal) = make_uint1(tmp.x); 
# 6310
} 
#endif
# 6312 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6313
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6317
::exit(___);}
#if 0
# 6313
{ 
# 6314
uint4 tmp; 
# 6315
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6316
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 6317
} 
#endif
# 6319 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6320
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6324
::exit(___);}
#if 0
# 6320
{ 
# 6321
uint4 tmp; 
# 6322
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6323
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6324
} 
#endif
# 6399 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6400
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6404
::exit(___);}
#if 0
# 6400
{ 
# 6401
float4 tmp; 
# 6402
__tex_1d_array_grad_v4f32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6403
(*retVal) = ((float)(tmp.x)); 
# 6404
} 
#endif
# 6406 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6407
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6411
::exit(___);}
#if 0
# 6407
{ 
# 6408
float4 tmp; 
# 6409
__tex_1d_array_grad_v4f32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6410
(*retVal) = make_float1(tmp.x); 
# 6411
} 
#endif
# 6413 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6414
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6418
::exit(___);}
#if 0
# 6414
{ 
# 6415
float4 tmp; 
# 6416
__tex_1d_array_grad_v4f32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6417
(*retVal) = make_float2(tmp.x, tmp.y); 
# 6418
} 
#endif
# 6420 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6421
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6425
::exit(___);}
#if 0
# 6421
{ 
# 6422
float4 tmp; 
# 6423
__tex_1d_array_grad_v4f32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6424
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6425
} 
#endif
# 6433 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6434
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6443
::exit(___);}
#if 0
# 6434
{ 
# 6439
int4 tmp; 
# 6440
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6442
(*retVal) = ((char)(tmp.x)); 
# 6443
} 
#endif
# 6444 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6445
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6449
::exit(___);}
#if 0
# 6445
{ 
# 6446
int4 tmp; 
# 6447
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6448
(*retVal) = ((signed char)(tmp.x)); 
# 6449
} 
#endif
# 6451 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6452
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6456
::exit(___);}
#if 0
# 6452
{ 
# 6453
int4 tmp; 
# 6454
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6455
(*retVal) = make_char1(tmp.x); 
# 6456
} 
#endif
# 6458 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6459
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6463
::exit(___);}
#if 0
# 6459
{ 
# 6460
int4 tmp; 
# 6461
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6462
(*retVal) = make_char2(tmp.x, tmp.y); 
# 6463
} 
#endif
# 6465 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6466
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6470
::exit(___);}
#if 0
# 6466
{ 
# 6467
int4 tmp; 
# 6468
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6469
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6470
} 
#endif
# 6472 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6473
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6477
::exit(___);}
#if 0
# 6473
{ 
# 6474
uint4 tmp; 
# 6475
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6476
(*retVal) = ((unsigned char)(tmp.x)); 
# 6477
} 
#endif
# 6479 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6480
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6484
::exit(___);}
#if 0
# 6480
{ 
# 6481
uint4 tmp; 
# 6482
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6483
(*retVal) = make_uchar1(tmp.x); 
# 6484
} 
#endif
# 6486 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6487
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6491
::exit(___);}
#if 0
# 6487
{ 
# 6488
uint4 tmp; 
# 6489
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6490
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 6491
} 
#endif
# 6493 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6494
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6498
::exit(___);}
#if 0
# 6494
{ 
# 6495
uint4 tmp; 
# 6496
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6497
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6498
} 
#endif
# 6506 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6507
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6511
::exit(___);}
#if 0
# 6507
{ 
# 6508
int4 tmp; 
# 6509
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6510
(*retVal) = ((short)(tmp.x)); 
# 6511
} 
#endif
# 6513 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6514
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6518
::exit(___);}
#if 0
# 6514
{ 
# 6515
int4 tmp; 
# 6516
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6517
(*retVal) = make_short1(tmp.x); 
# 6518
} 
#endif
# 6520 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6521
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6525
::exit(___);}
#if 0
# 6521
{ 
# 6522
int4 tmp; 
# 6523
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6524
(*retVal) = make_short2(tmp.x, tmp.y); 
# 6525
} 
#endif
# 6527 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6528
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6532
::exit(___);}
#if 0
# 6528
{ 
# 6529
int4 tmp; 
# 6530
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6531
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6532
} 
#endif
# 6534 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6535
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6539
::exit(___);}
#if 0
# 6535
{ 
# 6536
uint4 tmp; 
# 6537
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6538
(*retVal) = ((unsigned short)(tmp.x)); 
# 6539
} 
#endif
# 6541 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6542
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6546
::exit(___);}
#if 0
# 6542
{ 
# 6543
uint4 tmp; 
# 6544
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6545
(*retVal) = make_ushort1(tmp.x); 
# 6546
} 
#endif
# 6548 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6549
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6553
::exit(___);}
#if 0
# 6549
{ 
# 6550
uint4 tmp; 
# 6551
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6552
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 6553
} 
#endif
# 6555 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6556
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6560
::exit(___);}
#if 0
# 6556
{ 
# 6557
uint4 tmp; 
# 6558
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6559
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6560
} 
#endif
# 6568 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6569
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6573
::exit(___);}
#if 0
# 6569
{ 
# 6570
int4 tmp; 
# 6571
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6572
(*retVal) = ((int)(tmp.x)); 
# 6573
} 
#endif
# 6575 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6576
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6580
::exit(___);}
#if 0
# 6576
{ 
# 6577
int4 tmp; 
# 6578
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6579
(*retVal) = make_int1(tmp.x); 
# 6580
} 
#endif
# 6582 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6583
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6587
::exit(___);}
#if 0
# 6583
{ 
# 6584
int4 tmp; 
# 6585
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6586
(*retVal) = make_int2(tmp.x, tmp.y); 
# 6587
} 
#endif
# 6589 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6590
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6594
::exit(___);}
#if 0
# 6590
{ 
# 6591
int4 tmp; 
# 6592
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6593
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6594
} 
#endif
# 6596 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6597
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6601
::exit(___);}
#if 0
# 6597
{ 
# 6598
uint4 tmp; 
# 6599
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6600
(*retVal) = ((unsigned)(tmp.x)); 
# 6601
} 
#endif
# 6603 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6604
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6608
::exit(___);}
#if 0
# 6604
{ 
# 6605
uint4 tmp; 
# 6606
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6607
(*retVal) = make_uint1(tmp.x); 
# 6608
} 
#endif
# 6610 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6611
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6615
::exit(___);}
#if 0
# 6611
{ 
# 6612
uint4 tmp; 
# 6613
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6614
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 6615
} 
#endif
# 6617 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6618
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6622
::exit(___);}
#if 0
# 6618
{ 
# 6619
uint4 tmp; 
# 6620
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6621
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6622
} 
#endif
# 6697 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6698
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6702
::exit(___);}
#if 0
# 6698
{ 
# 6699
float4 tmp; 
# 6700
__tex_2d_array_grad_v4f32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6701
(*retVal) = ((float)(tmp.x)); 
# 6702
} 
#endif
# 6704 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6705
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6709
::exit(___);}
#if 0
# 6705
{ 
# 6706
float4 tmp; 
# 6707
__tex_2d_array_grad_v4f32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6708
(*retVal) = make_float1(tmp.x); 
# 6709
} 
#endif
# 6711 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6712
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6716
::exit(___);}
#if 0
# 6712
{ 
# 6713
float4 tmp; 
# 6714
__tex_2d_array_grad_v4f32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6715
(*retVal) = make_float2(tmp.x, tmp.y); 
# 6716
} 
#endif
# 6718 "/usr/include/texture_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6719
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6723
::exit(___);}
#if 0
# 6719
{ 
# 6720
float4 tmp; 
# 6721
__tex_2d_array_grad_v4f32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
# 6722
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6723
} 
#endif
# 77 "/usr/include/surface_indirect_functions.h" 3
extern "C" { __attribute__((unused)) void __suld_1d_i8_clamp(char *, unsigned long long, int); } 
# 78
extern "C" { __attribute__((unused)) void __suld_1d_i16_clamp(short *, unsigned long long, int); } 
# 79
extern "C" { __attribute__((unused)) void __suld_1d_i32_clamp(int *, unsigned long long, int); } 
# 80
extern "C" { __attribute__((unused)) void __suld_1d_i64_clamp(long long *, unsigned long long, int); } 
# 81
extern "C" { __attribute__((unused)) void __suld_1d_v2i8_clamp(char *, char *, unsigned long long, int); } 
# 82
extern "C" { __attribute__((unused)) void __suld_1d_v2i16_clamp(short *, short *, unsigned long long, int); } 
# 83
extern "C" { __attribute__((unused)) void __suld_1d_v2i32_clamp(int *, int *, unsigned long long, int); } 
# 84
extern "C" { __attribute__((unused)) void __suld_1d_v2i64_clamp(long long *, long long *, unsigned long long, int); } 
# 85
extern "C" { __attribute__((unused)) void __suld_1d_v4i8_clamp(char *, char *, char *, char *, unsigned long long, int); } 
# 86
extern "C" { __attribute__((unused)) void __suld_1d_v4i16_clamp(short *, short *, short *, short *, unsigned long long, int); } 
# 87
extern "C" { __attribute__((unused)) void __suld_1d_v4i32_clamp(int *, int *, int *, int *, unsigned long long, int); } 
# 88
extern "C" { __attribute__((unused)) void __suld_1d_array_i8_clamp(char *, unsigned long long, int, int); } 
# 89
extern "C" { __attribute__((unused)) void __suld_1d_array_i16_clamp(short *, unsigned long long, int, int); } 
# 90
extern "C" { __attribute__((unused)) void __suld_1d_array_i32_clamp(int *, unsigned long long, int, int); } 
# 91
extern "C" { __attribute__((unused)) void __suld_1d_array_i64_clamp(long long *, unsigned long long, int, int); } 
# 92
extern "C" { __attribute__((unused)) void __suld_1d_array_v2i8_clamp(char *, char *, unsigned long long, int, int); } 
# 93
extern "C" { __attribute__((unused)) void __suld_1d_array_v2i16_clamp(short *, short *, unsigned long long, int, int); } 
# 94
extern "C" { __attribute__((unused)) void __suld_1d_array_v2i32_clamp(int *, int *, unsigned long long, int, int); } 
# 95
extern "C" { __attribute__((unused)) void __suld_1d_array_v2i64_clamp(long long *, long long *, unsigned long long, int, int); } 
# 96
extern "C" { __attribute__((unused)) void __suld_1d_array_v4i8_clamp(char *, char *, char *, char *, unsigned long long, int, int); } 
# 97
extern "C" { __attribute__((unused)) void __suld_1d_array_v4i16_clamp(short *, short *, short *, short *, unsigned long long, int, int); } 
# 98
extern "C" { __attribute__((unused)) void __suld_1d_array_v4i32_clamp(int *, int *, int *, int *, unsigned long long, int, int); } 
# 99
extern "C" { __attribute__((unused)) void __suld_2d_i8_clamp(char *, unsigned long long, int, int); } 
# 100
extern "C" { __attribute__((unused)) void __suld_2d_i16_clamp(short *, unsigned long long, int, int); } 
# 101
extern "C" { __attribute__((unused)) void __suld_2d_i32_clamp(int *, unsigned long long, int, int); } 
# 102
extern "C" { __attribute__((unused)) void __suld_2d_i64_clamp(long long *, unsigned long long, int, int); } 
# 103
extern "C" { __attribute__((unused)) void __suld_2d_v2i8_clamp(char *, char *, unsigned long long, int, int); } 
# 104
extern "C" { __attribute__((unused)) void __suld_2d_v2i16_clamp(short *, short *, unsigned long long, int, int); } 
# 105
extern "C" { __attribute__((unused)) void __suld_2d_v2i32_clamp(int *, int *, unsigned long long, int, int); } 
# 106
extern "C" { __attribute__((unused)) void __suld_2d_v2i64_clamp(long long *, long long *, unsigned long long, int, int); } 
# 107
extern "C" { __attribute__((unused)) void __suld_2d_v4i8_clamp(char *, char *, char *, char *, unsigned long long, int, int); } 
# 108
extern "C" { __attribute__((unused)) void __suld_2d_v4i16_clamp(short *, short *, short *, short *, unsigned long long, int, int); } 
# 109
extern "C" { __attribute__((unused)) void __suld_2d_v4i32_clamp(int *, int *, int *, int *, unsigned long long, int, int); } 
# 110
extern "C" { __attribute__((unused)) void __suld_2d_array_i8_clamp(char *, unsigned long long, int, int, int); } 
# 111
extern "C" { __attribute__((unused)) void __suld_2d_array_i16_clamp(short *, unsigned long long, int, int, int); } 
# 112
extern "C" { __attribute__((unused)) void __suld_2d_array_i32_clamp(int *, unsigned long long, int, int, int); } 
# 113
extern "C" { __attribute__((unused)) void __suld_2d_array_i64_clamp(long long *, unsigned long long, int, int, int); } 
# 114
extern "C" { __attribute__((unused)) void __suld_2d_array_v2i8_clamp(char *, char *, unsigned long long, int, int, int); } 
# 115
extern "C" { __attribute__((unused)) void __suld_2d_array_v2i16_clamp(short *, short *, unsigned long long, int, int, int); } 
# 116
extern "C" { __attribute__((unused)) void __suld_2d_array_v2i32_clamp(int *, int *, unsigned long long, int, int, int); } 
# 117
extern "C" { __attribute__((unused)) void __suld_2d_array_v2i64_clamp(long long *, long long *, unsigned long long, int, int, int); } 
# 118
extern "C" { __attribute__((unused)) void __suld_2d_array_v4i8_clamp(char *, char *, char *, char *, unsigned long long, int, int, int); } 
# 119
extern "C" { __attribute__((unused)) void __suld_2d_array_v4i16_clamp(short *, short *, short *, short *, unsigned long long, int, int, int); } 
# 120
extern "C" { __attribute__((unused)) void __suld_2d_array_v4i32_clamp(int *, int *, int *, int *, unsigned long long, int, int, int); } 
# 121
extern "C" { __attribute__((unused)) void __suld_3d_i8_clamp(char *, unsigned long long, int, int, int); } 
# 122
extern "C" { __attribute__((unused)) void __suld_3d_i16_clamp(short *, unsigned long long, int, int, int); } 
# 123
extern "C" { __attribute__((unused)) void __suld_3d_i32_clamp(int *, unsigned long long, int, int, int); } 
# 124
extern "C" { __attribute__((unused)) void __suld_3d_i64_clamp(long long *, unsigned long long, int, int, int); } 
# 125
extern "C" { __attribute__((unused)) void __suld_3d_v2i8_clamp(char *, char *, unsigned long long, int, int, int); } 
# 126
extern "C" { __attribute__((unused)) void __suld_3d_v2i16_clamp(short *, short *, unsigned long long, int, int, int); } 
# 127
extern "C" { __attribute__((unused)) void __suld_3d_v2i32_clamp(int *, int *, unsigned long long, int, int, int); } 
# 128
extern "C" { __attribute__((unused)) void __suld_3d_v2i64_clamp(long long *, long long *, unsigned long long, int, int, int); } 
# 129
extern "C" { __attribute__((unused)) void __suld_3d_v4i8_clamp(char *, char *, char *, char *, unsigned long long, int, int, int); } 
# 130
extern "C" { __attribute__((unused)) void __suld_3d_v4i16_clamp(short *, short *, short *, short *, unsigned long long, int, int, int); } 
# 131
extern "C" { __attribute__((unused)) void __suld_3d_v4i32_clamp(int *, int *, int *, int *, unsigned long long, int, int, int); } 
# 132
extern "C" { __attribute__((unused)) void __suld_1d_i8_trap(char *, unsigned long long, int); } 
# 133
extern "C" { __attribute__((unused)) void __suld_1d_i16_trap(short *, unsigned long long, int); } 
# 134
extern "C" { __attribute__((unused)) void __suld_1d_i32_trap(int *, unsigned long long, int); } 
# 135
extern "C" { __attribute__((unused)) void __suld_1d_i64_trap(long long *, unsigned long long, int); } 
# 136
extern "C" { __attribute__((unused)) void __suld_1d_v2i8_trap(char *, char *, unsigned long long, int); } 
# 137
extern "C" { __attribute__((unused)) void __suld_1d_v2i16_trap(short *, short *, unsigned long long, int); } 
# 138
extern "C" { __attribute__((unused)) void __suld_1d_v2i32_trap(int *, int *, unsigned long long, int); } 
# 139
extern "C" { __attribute__((unused)) void __suld_1d_v2i64_trap(long long *, long long *, unsigned long long, int); } 
# 140
extern "C" { __attribute__((unused)) void __suld_1d_v4i8_trap(char *, char *, char *, char *, unsigned long long, int); } 
# 141
extern "C" { __attribute__((unused)) void __suld_1d_v4i16_trap(short *, short *, short *, short *, unsigned long long, int); } 
# 142
extern "C" { __attribute__((unused)) void __suld_1d_v4i32_trap(int *, int *, int *, int *, unsigned long long, int); } 
# 143
extern "C" { __attribute__((unused)) void __suld_1d_array_i8_trap(char *, unsigned long long, int, int); } 
# 144
extern "C" { __attribute__((unused)) void __suld_1d_array_i16_trap(short *, unsigned long long, int, int); } 
# 145
extern "C" { __attribute__((unused)) void __suld_1d_array_i32_trap(int *, unsigned long long, int, int); } 
# 146
extern "C" { __attribute__((unused)) void __suld_1d_array_i64_trap(long long *, unsigned long long, int, int); } 
# 147
extern "C" { __attribute__((unused)) void __suld_1d_array_v2i8_trap(char *, char *, unsigned long long, int, int); } 
# 148
extern "C" { __attribute__((unused)) void __suld_1d_array_v2i16_trap(short *, short *, unsigned long long, int, int); } 
# 149
extern "C" { __attribute__((unused)) void __suld_1d_array_v2i32_trap(int *, int *, unsigned long long, int, int); } 
# 150
extern "C" { __attribute__((unused)) void __suld_1d_array_v2i64_trap(long long *, long long *, unsigned long long, int, int); } 
# 151
extern "C" { __attribute__((unused)) void __suld_1d_array_v4i8_trap(char *, char *, char *, char *, unsigned long long, int, int); } 
# 152
extern "C" { __attribute__((unused)) void __suld_1d_array_v4i16_trap(short *, short *, short *, short *, unsigned long long, int, int); } 
# 153
extern "C" { __attribute__((unused)) void __suld_1d_array_v4i32_trap(int *, int *, int *, int *, unsigned long long, int, int); } 
# 154
extern "C" { __attribute__((unused)) void __suld_2d_i8_trap(char *, unsigned long long, int, int); } 
# 155
extern "C" { __attribute__((unused)) void __suld_2d_i16_trap(short *, unsigned long long, int, int); } 
# 156
extern "C" { __attribute__((unused)) void __suld_2d_i32_trap(int *, unsigned long long, int, int); } 
# 157
extern "C" { __attribute__((unused)) void __suld_2d_i64_trap(long long *, unsigned long long, int, int); } 
# 158
extern "C" { __attribute__((unused)) void __suld_2d_v2i8_trap(char *, char *, unsigned long long, int, int); } 
# 159
extern "C" { __attribute__((unused)) void __suld_2d_v2i16_trap(short *, short *, unsigned long long, int, int); } 
# 160
extern "C" { __attribute__((unused)) void __suld_2d_v2i32_trap(int *, int *, unsigned long long, int, int); } 
# 161
extern "C" { __attribute__((unused)) void __suld_2d_v2i64_trap(long long *, long long *, unsigned long long, int, int); } 
# 162
extern "C" { __attribute__((unused)) void __suld_2d_v4i8_trap(char *, char *, char *, char *, unsigned long long, int, int); } 
# 163
extern "C" { __attribute__((unused)) void __suld_2d_v4i16_trap(short *, short *, short *, short *, unsigned long long, int, int); } 
# 164
extern "C" { __attribute__((unused)) void __suld_2d_v4i32_trap(int *, int *, int *, int *, unsigned long long, int, int); } 
# 165
extern "C" { __attribute__((unused)) void __suld_2d_array_i8_trap(char *, unsigned long long, int, int, int); } 
# 166
extern "C" { __attribute__((unused)) void __suld_2d_array_i16_trap(short *, unsigned long long, int, int, int); } 
# 167
extern "C" { __attribute__((unused)) void __suld_2d_array_i32_trap(int *, unsigned long long, int, int, int); } 
# 168
extern "C" { __attribute__((unused)) void __suld_2d_array_i64_trap(long long *, unsigned long long, int, int, int); } 
# 169
extern "C" { __attribute__((unused)) void __suld_2d_array_v2i8_trap(char *, char *, unsigned long long, int, int, int); } 
# 170
extern "C" { __attribute__((unused)) void __suld_2d_array_v2i16_trap(short *, short *, unsigned long long, int, int, int); } 
# 171
extern "C" { __attribute__((unused)) void __suld_2d_array_v2i32_trap(int *, int *, unsigned long long, int, int, int); } 
# 172
extern "C" { __attribute__((unused)) void __suld_2d_array_v2i64_trap(long long *, long long *, unsigned long long, int, int, int); } 
# 173
extern "C" { __attribute__((unused)) void __suld_2d_array_v4i8_trap(char *, char *, char *, char *, unsigned long long, int, int, int); } 
# 174
extern "C" { __attribute__((unused)) void __suld_2d_array_v4i16_trap(short *, short *, short *, short *, unsigned long long, int, int, int); } 
# 175
extern "C" { __attribute__((unused)) void __suld_2d_array_v4i32_trap(int *, int *, int *, int *, unsigned long long, int, int, int); } 
# 176
extern "C" { __attribute__((unused)) void __suld_3d_i8_trap(char *, unsigned long long, int, int, int); } 
# 177
extern "C" { __attribute__((unused)) void __suld_3d_i16_trap(short *, unsigned long long, int, int, int); } 
# 178
extern "C" { __attribute__((unused)) void __suld_3d_i32_trap(int *, unsigned long long, int, int, int); } 
# 179
extern "C" { __attribute__((unused)) void __suld_3d_i64_trap(long long *, unsigned long long, int, int, int); } 
# 180
extern "C" { __attribute__((unused)) void __suld_3d_v2i8_trap(char *, char *, unsigned long long, int, int, int); } 
# 181
extern "C" { __attribute__((unused)) void __suld_3d_v2i16_trap(short *, short *, unsigned long long, int, int, int); } 
# 182
extern "C" { __attribute__((unused)) void __suld_3d_v2i32_trap(int *, int *, unsigned long long, int, int, int); } 
# 183
extern "C" { __attribute__((unused)) void __suld_3d_v2i64_trap(long long *, long long *, unsigned long long, int, int, int); } 
# 184
extern "C" { __attribute__((unused)) void __suld_3d_v4i8_trap(char *, char *, char *, char *, unsigned long long, int, int, int); } 
# 185
extern "C" { __attribute__((unused)) void __suld_3d_v4i16_trap(short *, short *, short *, short *, unsigned long long, int, int, int); } 
# 186
extern "C" { __attribute__((unused)) void __suld_3d_v4i32_trap(int *, int *, int *, int *, unsigned long long, int, int, int); } 
# 187
extern "C" { __attribute__((unused)) void __suld_1d_i8_zero(char *, unsigned long long, int); } 
# 188
extern "C" { __attribute__((unused)) void __suld_1d_i16_zero(short *, unsigned long long, int); } 
# 189
extern "C" { __attribute__((unused)) void __suld_1d_i32_zero(int *, unsigned long long, int); } 
# 190
extern "C" { __attribute__((unused)) void __suld_1d_i64_zero(long long *, unsigned long long, int); } 
# 191
extern "C" { __attribute__((unused)) void __suld_1d_v2i8_zero(char *, char *, unsigned long long, int); } 
# 192
extern "C" { __attribute__((unused)) void __suld_1d_v2i16_zero(short *, short *, unsigned long long, int); } 
# 193
extern "C" { __attribute__((unused)) void __suld_1d_v2i32_zero(int *, int *, unsigned long long, int); } 
# 194
extern "C" { __attribute__((unused)) void __suld_1d_v2i64_zero(long long *, long long *, unsigned long long, int); } 
# 195
extern "C" { __attribute__((unused)) void __suld_1d_v4i8_zero(char *, char *, char *, char *, unsigned long long, int); } 
# 196
extern "C" { __attribute__((unused)) void __suld_1d_v4i16_zero(short *, short *, short *, short *, unsigned long long, int); } 
# 197
extern "C" { __attribute__((unused)) void __suld_1d_v4i32_zero(int *, int *, int *, int *, unsigned long long, int); } 
# 198
extern "C" { __attribute__((unused)) void __suld_1d_array_i8_zero(char *, unsigned long long, int, int); } 
# 199
extern "C" { __attribute__((unused)) void __suld_1d_array_i16_zero(short *, unsigned long long, int, int); } 
# 200
extern "C" { __attribute__((unused)) void __suld_1d_array_i32_zero(int *, unsigned long long, int, int); } 
# 201
extern "C" { __attribute__((unused)) void __suld_1d_array_i64_zero(long long *, unsigned long long, int, int); } 
# 202
extern "C" { __attribute__((unused)) void __suld_1d_array_v2i8_zero(char *, char *, unsigned long long, int, int); } 
# 203
extern "C" { __attribute__((unused)) void __suld_1d_array_v2i16_zero(short *, short *, unsigned long long, int, int); } 
# 204
extern "C" { __attribute__((unused)) void __suld_1d_array_v2i32_zero(int *, int *, unsigned long long, int, int); } 
# 205
extern "C" { __attribute__((unused)) void __suld_1d_array_v2i64_zero(long long *, long long *, unsigned long long, int, int); } 
# 206
extern "C" { __attribute__((unused)) void __suld_1d_array_v4i8_zero(char *, char *, char *, char *, unsigned long long, int, int); } 
# 207
extern "C" { __attribute__((unused)) void __suld_1d_array_v4i16_zero(short *, short *, short *, short *, unsigned long long, int, int); } 
# 208
extern "C" { __attribute__((unused)) void __suld_1d_array_v4i32_zero(int *, int *, int *, int *, unsigned long long, int, int); } 
# 209
extern "C" { __attribute__((unused)) void __suld_2d_i8_zero(char *, unsigned long long, int, int); } 
# 210
extern "C" { __attribute__((unused)) void __suld_2d_i16_zero(short *, unsigned long long, int, int); } 
# 211
extern "C" { __attribute__((unused)) void __suld_2d_i32_zero(int *, unsigned long long, int, int); } 
# 212
extern "C" { __attribute__((unused)) void __suld_2d_i64_zero(long long *, unsigned long long, int, int); } 
# 213
extern "C" { __attribute__((unused)) void __suld_2d_v2i8_zero(char *, char *, unsigned long long, int, int); } 
# 214
extern "C" { __attribute__((unused)) void __suld_2d_v2i16_zero(short *, short *, unsigned long long, int, int); } 
# 215
extern "C" { __attribute__((unused)) void __suld_2d_v2i32_zero(int *, int *, unsigned long long, int, int); } 
# 216
extern "C" { __attribute__((unused)) void __suld_2d_v2i64_zero(long long *, long long *, unsigned long long, int, int); } 
# 217
extern "C" { __attribute__((unused)) void __suld_2d_v4i8_zero(char *, char *, char *, char *, unsigned long long, int, int); } 
# 218
extern "C" { __attribute__((unused)) void __suld_2d_v4i16_zero(short *, short *, short *, short *, unsigned long long, int, int); } 
# 219
extern "C" { __attribute__((unused)) void __suld_2d_v4i32_zero(int *, int *, int *, int *, unsigned long long, int, int); } 
# 220
extern "C" { __attribute__((unused)) void __suld_2d_array_i8_zero(char *, unsigned long long, int, int, int); } 
# 221
extern "C" { __attribute__((unused)) void __suld_2d_array_i16_zero(short *, unsigned long long, int, int, int); } 
# 222
extern "C" { __attribute__((unused)) void __suld_2d_array_i32_zero(int *, unsigned long long, int, int, int); } 
# 223
extern "C" { __attribute__((unused)) void __suld_2d_array_i64_zero(long long *, unsigned long long, int, int, int); } 
# 224
extern "C" { __attribute__((unused)) void __suld_2d_array_v2i8_zero(char *, char *, unsigned long long, int, int, int); } 
# 225
extern "C" { __attribute__((unused)) void __suld_2d_array_v2i16_zero(short *, short *, unsigned long long, int, int, int); } 
# 226
extern "C" { __attribute__((unused)) void __suld_2d_array_v2i32_zero(int *, int *, unsigned long long, int, int, int); } 
# 227
extern "C" { __attribute__((unused)) void __suld_2d_array_v2i64_zero(long long *, long long *, unsigned long long, int, int, int); } 
# 228
extern "C" { __attribute__((unused)) void __suld_2d_array_v4i8_zero(char *, char *, char *, char *, unsigned long long, int, int, int); } 
# 229
extern "C" { __attribute__((unused)) void __suld_2d_array_v4i16_zero(short *, short *, short *, short *, unsigned long long, int, int, int); } 
# 230
extern "C" { __attribute__((unused)) void __suld_2d_array_v4i32_zero(int *, int *, int *, int *, unsigned long long, int, int, int); } 
# 231
extern "C" { __attribute__((unused)) void __suld_3d_i8_zero(char *, unsigned long long, int, int, int); } 
# 232
extern "C" { __attribute__((unused)) void __suld_3d_i16_zero(short *, unsigned long long, int, int, int); } 
# 233
extern "C" { __attribute__((unused)) void __suld_3d_i32_zero(int *, unsigned long long, int, int, int); } 
# 234
extern "C" { __attribute__((unused)) void __suld_3d_i64_zero(long long *, unsigned long long, int, int, int); } 
# 235
extern "C" { __attribute__((unused)) void __suld_3d_v2i8_zero(char *, char *, unsigned long long, int, int, int); } 
# 236
extern "C" { __attribute__((unused)) void __suld_3d_v2i16_zero(short *, short *, unsigned long long, int, int, int); } 
# 237
extern "C" { __attribute__((unused)) void __suld_3d_v2i32_zero(int *, int *, unsigned long long, int, int, int); } 
# 238
extern "C" { __attribute__((unused)) void __suld_3d_v2i64_zero(long long *, long long *, unsigned long long, int, int, int); } 
# 239
extern "C" { __attribute__((unused)) void __suld_3d_v4i8_zero(char *, char *, char *, char *, unsigned long long, int, int, int); } 
# 240
extern "C" { __attribute__((unused)) void __suld_3d_v4i16_zero(short *, short *, short *, short *, unsigned long long, int, int, int); } 
# 241
extern "C" { __attribute__((unused)) void __suld_3d_v4i32_zero(int *, int *, int *, int *, unsigned long long, int, int, int); } 
# 243
extern "C" { __attribute__((unused)) void __sust_b_1d_i8_clamp(cudaSurfaceObject_t, int, unsigned char); } 
# 244
extern "C" { __attribute__((unused)) void __sust_b_1d_i16_clamp(cudaSurfaceObject_t, int, unsigned short); } 
# 245
extern "C" { __attribute__((unused)) void __sust_b_1d_i32_clamp(cudaSurfaceObject_t, int, unsigned); } 
# 246
extern "C" { __attribute__((unused)) void __sust_b_1d_i64_clamp(cudaSurfaceObject_t, int, unsigned long long); } 
# 247
extern "C" { __attribute__((unused)) void __sust_b_1d_v2i8_clamp(cudaSurfaceObject_t, int, uchar2); } 
# 248
extern "C" { __attribute__((unused)) void __sust_b_1d_v2i16_clamp(cudaSurfaceObject_t, int, ushort2); } 
# 249
extern "C" { __attribute__((unused)) void __sust_b_1d_v2i32_clamp(cudaSurfaceObject_t, int, uint2); } 
# 250
extern "C" { __attribute__((unused)) void __sust_b_1d_v2i64_clamp(cudaSurfaceObject_t, int, ulonglong2); } 
# 251
extern "C" { __attribute__((unused)) void __sust_b_1d_v4i8_clamp(cudaSurfaceObject_t, int, uchar4); } 
# 252
extern "C" { __attribute__((unused)) void __sust_b_1d_v4i16_clamp(cudaSurfaceObject_t, int, ushort4); } 
# 253
extern "C" { __attribute__((unused)) void __sust_b_1d_v4i32_clamp(cudaSurfaceObject_t, int, uint4); } 
# 254
extern "C" { __attribute__((unused)) void __sust_b_1d_array_i8_clamp(cudaSurfaceObject_t, int, int, unsigned char); } 
# 255
extern "C" { __attribute__((unused)) void __sust_b_1d_array_i16_clamp(cudaSurfaceObject_t, int, int, unsigned short); } 
# 256
extern "C" { __attribute__((unused)) void __sust_b_1d_array_i32_clamp(cudaSurfaceObject_t, int, int, unsigned); } 
# 257
extern "C" { __attribute__((unused)) void __sust_b_1d_array_i64_clamp(cudaSurfaceObject_t, int, int, unsigned long long); } 
# 258
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v2i8_clamp(cudaSurfaceObject_t, int, int, uchar2); } 
# 259
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v2i16_clamp(cudaSurfaceObject_t, int, int, ushort2); } 
# 260
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v2i32_clamp(cudaSurfaceObject_t, int, int, uint2); } 
# 261
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v2i64_clamp(cudaSurfaceObject_t, int, int, ulonglong2); } 
# 262
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v4i8_clamp(cudaSurfaceObject_t, int, int, uchar4); } 
# 263
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v4i16_clamp(cudaSurfaceObject_t, int, int, ushort4); } 
# 264
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v4i32_clamp(cudaSurfaceObject_t, int, int, uint4); } 
# 265
extern "C" { __attribute__((unused)) void __sust_b_2d_i8_clamp(cudaSurfaceObject_t, int, int, unsigned char); } 
# 266
extern "C" { __attribute__((unused)) void __sust_b_2d_i16_clamp(cudaSurfaceObject_t, int, int, unsigned short); } 
# 267
extern "C" { __attribute__((unused)) void __sust_b_2d_i32_clamp(cudaSurfaceObject_t, int, int, unsigned); } 
# 268
extern "C" { __attribute__((unused)) void __sust_b_2d_i64_clamp(cudaSurfaceObject_t, int, int, unsigned long long); } 
# 269
extern "C" { __attribute__((unused)) void __sust_b_2d_v2i8_clamp(cudaSurfaceObject_t, int, int, uchar2); } 
# 270
extern "C" { __attribute__((unused)) void __sust_b_2d_v2i16_clamp(cudaSurfaceObject_t, int, int, ushort2); } 
# 271
extern "C" { __attribute__((unused)) void __sust_b_2d_v2i32_clamp(cudaSurfaceObject_t, int, int, uint2); } 
# 272
extern "C" { __attribute__((unused)) void __sust_b_2d_v2i64_clamp(cudaSurfaceObject_t, int, int, ulonglong2); } 
# 273
extern "C" { __attribute__((unused)) void __sust_b_2d_v4i8_clamp(cudaSurfaceObject_t, int, int, uchar4); } 
# 274
extern "C" { __attribute__((unused)) void __sust_b_2d_v4i16_clamp(cudaSurfaceObject_t, int, int, ushort4); } 
# 275
extern "C" { __attribute__((unused)) void __sust_b_2d_v4i32_clamp(cudaSurfaceObject_t, int, int, uint4); } 
# 276
extern "C" { __attribute__((unused)) void __sust_b_2d_array_i8_clamp(cudaSurfaceObject_t, int, int, int, unsigned char); } 
# 277
extern "C" { __attribute__((unused)) void __sust_b_2d_array_i16_clamp(cudaSurfaceObject_t, int, int, int, unsigned short); } 
# 278
extern "C" { __attribute__((unused)) void __sust_b_2d_array_i32_clamp(cudaSurfaceObject_t, int, int, int, unsigned); } 
# 279
extern "C" { __attribute__((unused)) void __sust_b_2d_array_i64_clamp(cudaSurfaceObject_t, int, int, int, unsigned long long); } 
# 280
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v2i8_clamp(cudaSurfaceObject_t, int, int, int, uchar2); } 
# 281
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v2i16_clamp(cudaSurfaceObject_t, int, int, int, ushort2); } 
# 282
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v2i32_clamp(cudaSurfaceObject_t, int, int, int, uint2); } 
# 283
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v2i64_clamp(cudaSurfaceObject_t, int, int, int, ulonglong2); } 
# 284
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v4i8_clamp(cudaSurfaceObject_t, int, int, int, uchar4); } 
# 285
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v4i16_clamp(cudaSurfaceObject_t, int, int, int, ushort4); } 
# 286
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v4i32_clamp(cudaSurfaceObject_t, int, int, int, uint4); } 
# 287
extern "C" { __attribute__((unused)) void __sust_b_3d_i8_clamp(cudaSurfaceObject_t, int, int, int, unsigned char); } 
# 288
extern "C" { __attribute__((unused)) void __sust_b_3d_i16_clamp(cudaSurfaceObject_t, int, int, int, unsigned short); } 
# 289
extern "C" { __attribute__((unused)) void __sust_b_3d_i32_clamp(cudaSurfaceObject_t, int, int, int, unsigned); } 
# 290
extern "C" { __attribute__((unused)) void __sust_b_3d_i64_clamp(cudaSurfaceObject_t, int, int, int, unsigned long long); } 
# 291
extern "C" { __attribute__((unused)) void __sust_b_3d_v2i8_clamp(cudaSurfaceObject_t, int, int, int, uchar2); } 
# 292
extern "C" { __attribute__((unused)) void __sust_b_3d_v2i16_clamp(cudaSurfaceObject_t, int, int, int, ushort2); } 
# 293
extern "C" { __attribute__((unused)) void __sust_b_3d_v2i32_clamp(cudaSurfaceObject_t, int, int, int, uint2); } 
# 294
extern "C" { __attribute__((unused)) void __sust_b_3d_v2i64_clamp(cudaSurfaceObject_t, int, int, int, ulonglong2); } 
# 295
extern "C" { __attribute__((unused)) void __sust_b_3d_v4i8_clamp(cudaSurfaceObject_t, int, int, int, uchar4); } 
# 296
extern "C" { __attribute__((unused)) void __sust_b_3d_v4i16_clamp(cudaSurfaceObject_t, int, int, int, ushort4); } 
# 297
extern "C" { __attribute__((unused)) void __sust_b_3d_v4i32_clamp(cudaSurfaceObject_t, int, int, int, uint4); } 
# 298
extern "C" { __attribute__((unused)) void __sust_b_1d_i8_trap(cudaSurfaceObject_t, int, unsigned char); } 
# 299
extern "C" { __attribute__((unused)) void __sust_b_1d_i16_trap(cudaSurfaceObject_t, int, unsigned short); } 
# 300
extern "C" { __attribute__((unused)) void __sust_b_1d_i32_trap(cudaSurfaceObject_t, int, unsigned); } 
# 301
extern "C" { __attribute__((unused)) void __sust_b_1d_i64_trap(cudaSurfaceObject_t, int, unsigned long long); } 
# 302
extern "C" { __attribute__((unused)) void __sust_b_1d_v2i8_trap(cudaSurfaceObject_t, int, uchar2); } 
# 303
extern "C" { __attribute__((unused)) void __sust_b_1d_v2i16_trap(cudaSurfaceObject_t, int, ushort2); } 
# 304
extern "C" { __attribute__((unused)) void __sust_b_1d_v2i32_trap(cudaSurfaceObject_t, int, uint2); } 
# 305
extern "C" { __attribute__((unused)) void __sust_b_1d_v2i64_trap(cudaSurfaceObject_t, int, ulonglong2); } 
# 306
extern "C" { __attribute__((unused)) void __sust_b_1d_v4i8_trap(cudaSurfaceObject_t, int, uchar4); } 
# 307
extern "C" { __attribute__((unused)) void __sust_b_1d_v4i16_trap(cudaSurfaceObject_t, int, ushort4); } 
# 308
extern "C" { __attribute__((unused)) void __sust_b_1d_v4i32_trap(cudaSurfaceObject_t, int, uint4); } 
# 309
extern "C" { __attribute__((unused)) void __sust_b_1d_array_i8_trap(cudaSurfaceObject_t, int, int, unsigned char); } 
# 310
extern "C" { __attribute__((unused)) void __sust_b_1d_array_i16_trap(cudaSurfaceObject_t, int, int, unsigned short); } 
# 311
extern "C" { __attribute__((unused)) void __sust_b_1d_array_i32_trap(cudaSurfaceObject_t, int, int, unsigned); } 
# 312
extern "C" { __attribute__((unused)) void __sust_b_1d_array_i64_trap(cudaSurfaceObject_t, int, int, unsigned long long); } 
# 313
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v2i8_trap(cudaSurfaceObject_t, int, int, uchar2); } 
# 314
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v2i16_trap(cudaSurfaceObject_t, int, int, ushort2); } 
# 315
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v2i32_trap(cudaSurfaceObject_t, int, int, uint2); } 
# 316
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v2i64_trap(cudaSurfaceObject_t, int, int, ulonglong2); } 
# 317
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v4i8_trap(cudaSurfaceObject_t, int, int, uchar4); } 
# 318
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v4i16_trap(cudaSurfaceObject_t, int, int, ushort4); } 
# 319
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v4i32_trap(cudaSurfaceObject_t, int, int, uint4); } 
# 320
extern "C" { __attribute__((unused)) void __sust_b_2d_i8_trap(cudaSurfaceObject_t, int, int, unsigned char); } 
# 321
extern "C" { __attribute__((unused)) void __sust_b_2d_i16_trap(cudaSurfaceObject_t, int, int, unsigned short); } 
# 322
extern "C" { __attribute__((unused)) void __sust_b_2d_i32_trap(cudaSurfaceObject_t, int, int, unsigned); } 
# 323
extern "C" { __attribute__((unused)) void __sust_b_2d_i64_trap(cudaSurfaceObject_t, int, int, unsigned long long); } 
# 324
extern "C" { __attribute__((unused)) void __sust_b_2d_v2i8_trap(cudaSurfaceObject_t, int, int, uchar2); } 
# 325
extern "C" { __attribute__((unused)) void __sust_b_2d_v2i16_trap(cudaSurfaceObject_t, int, int, ushort2); } 
# 326
extern "C" { __attribute__((unused)) void __sust_b_2d_v2i32_trap(cudaSurfaceObject_t, int, int, uint2); } 
# 327
extern "C" { __attribute__((unused)) void __sust_b_2d_v2i64_trap(cudaSurfaceObject_t, int, int, ulonglong2); } 
# 328
extern "C" { __attribute__((unused)) void __sust_b_2d_v4i8_trap(cudaSurfaceObject_t, int, int, uchar4); } 
# 329
extern "C" { __attribute__((unused)) void __sust_b_2d_v4i16_trap(cudaSurfaceObject_t, int, int, ushort4); } 
# 330
extern "C" { __attribute__((unused)) void __sust_b_2d_v4i32_trap(cudaSurfaceObject_t, int, int, uint4); } 
# 331
extern "C" { __attribute__((unused)) void __sust_b_2d_array_i8_trap(cudaSurfaceObject_t, int, int, int, unsigned char); } 
# 332
extern "C" { __attribute__((unused)) void __sust_b_2d_array_i16_trap(cudaSurfaceObject_t, int, int, int, unsigned short); } 
# 333
extern "C" { __attribute__((unused)) void __sust_b_2d_array_i32_trap(cudaSurfaceObject_t, int, int, int, unsigned); } 
# 334
extern "C" { __attribute__((unused)) void __sust_b_2d_array_i64_trap(cudaSurfaceObject_t, int, int, int, unsigned long long); } 
# 335
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v2i8_trap(cudaSurfaceObject_t, int, int, int, uchar2); } 
# 336
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v2i16_trap(cudaSurfaceObject_t, int, int, int, ushort2); } 
# 337
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v2i32_trap(cudaSurfaceObject_t, int, int, int, uint2); } 
# 338
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v2i64_trap(cudaSurfaceObject_t, int, int, int, ulonglong2); } 
# 339
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v4i8_trap(cudaSurfaceObject_t, int, int, int, uchar4); } 
# 340
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v4i16_trap(cudaSurfaceObject_t, int, int, int, ushort4); } 
# 341
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v4i32_trap(cudaSurfaceObject_t, int, int, int, uint4); } 
# 342
extern "C" { __attribute__((unused)) void __sust_b_3d_i8_trap(cudaSurfaceObject_t, int, int, int, unsigned char); } 
# 343
extern "C" { __attribute__((unused)) void __sust_b_3d_i16_trap(cudaSurfaceObject_t, int, int, int, unsigned short); } 
# 344
extern "C" { __attribute__((unused)) void __sust_b_3d_i32_trap(cudaSurfaceObject_t, int, int, int, unsigned); } 
# 345
extern "C" { __attribute__((unused)) void __sust_b_3d_i64_trap(cudaSurfaceObject_t, int, int, int, unsigned long long); } 
# 346
extern "C" { __attribute__((unused)) void __sust_b_3d_v2i8_trap(cudaSurfaceObject_t, int, int, int, uchar2); } 
# 347
extern "C" { __attribute__((unused)) void __sust_b_3d_v2i16_trap(cudaSurfaceObject_t, int, int, int, ushort2); } 
# 348
extern "C" { __attribute__((unused)) void __sust_b_3d_v2i32_trap(cudaSurfaceObject_t, int, int, int, uint2); } 
# 349
extern "C" { __attribute__((unused)) void __sust_b_3d_v2i64_trap(cudaSurfaceObject_t, int, int, int, ulonglong2); } 
# 350
extern "C" { __attribute__((unused)) void __sust_b_3d_v4i8_trap(cudaSurfaceObject_t, int, int, int, uchar4); } 
# 351
extern "C" { __attribute__((unused)) void __sust_b_3d_v4i16_trap(cudaSurfaceObject_t, int, int, int, ushort4); } 
# 352
extern "C" { __attribute__((unused)) void __sust_b_3d_v4i32_trap(cudaSurfaceObject_t, int, int, int, uint4); } 
# 353
extern "C" { __attribute__((unused)) void __sust_b_1d_i8_zero(cudaSurfaceObject_t, int, unsigned char); } 
# 354
extern "C" { __attribute__((unused)) void __sust_b_1d_i16_zero(cudaSurfaceObject_t, int, unsigned short); } 
# 355
extern "C" { __attribute__((unused)) void __sust_b_1d_i32_zero(cudaSurfaceObject_t, int, unsigned); } 
# 356
extern "C" { __attribute__((unused)) void __sust_b_1d_i64_zero(cudaSurfaceObject_t, int, unsigned long long); } 
# 357
extern "C" { __attribute__((unused)) void __sust_b_1d_v2i8_zero(cudaSurfaceObject_t, int, uchar2); } 
# 358
extern "C" { __attribute__((unused)) void __sust_b_1d_v2i16_zero(cudaSurfaceObject_t, int, ushort2); } 
# 359
extern "C" { __attribute__((unused)) void __sust_b_1d_v2i32_zero(cudaSurfaceObject_t, int, uint2); } 
# 360
extern "C" { __attribute__((unused)) void __sust_b_1d_v2i64_zero(cudaSurfaceObject_t, int, ulonglong2); } 
# 361
extern "C" { __attribute__((unused)) void __sust_b_1d_v4i8_zero(cudaSurfaceObject_t, int, uchar4); } 
# 362
extern "C" { __attribute__((unused)) void __sust_b_1d_v4i16_zero(cudaSurfaceObject_t, int, ushort4); } 
# 363
extern "C" { __attribute__((unused)) void __sust_b_1d_v4i32_zero(cudaSurfaceObject_t, int, uint4); } 
# 364
extern "C" { __attribute__((unused)) void __sust_b_1d_array_i8_zero(cudaSurfaceObject_t, int, int, unsigned char); } 
# 365
extern "C" { __attribute__((unused)) void __sust_b_1d_array_i16_zero(cudaSurfaceObject_t, int, int, unsigned short); } 
# 366
extern "C" { __attribute__((unused)) void __sust_b_1d_array_i32_zero(cudaSurfaceObject_t, int, int, unsigned); } 
# 367
extern "C" { __attribute__((unused)) void __sust_b_1d_array_i64_zero(cudaSurfaceObject_t, int, int, unsigned long long); } 
# 368
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v2i8_zero(cudaSurfaceObject_t, int, int, uchar2); } 
# 369
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v2i16_zero(cudaSurfaceObject_t, int, int, ushort2); } 
# 370
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v2i32_zero(cudaSurfaceObject_t, int, int, uint2); } 
# 371
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v2i64_zero(cudaSurfaceObject_t, int, int, ulonglong2); } 
# 372
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v4i8_zero(cudaSurfaceObject_t, int, int, uchar4); } 
# 373
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v4i16_zero(cudaSurfaceObject_t, int, int, ushort4); } 
# 374
extern "C" { __attribute__((unused)) void __sust_b_1d_array_v4i32_zero(cudaSurfaceObject_t, int, int, uint4); } 
# 375
extern "C" { __attribute__((unused)) void __sust_b_2d_i8_zero(cudaSurfaceObject_t, int, int, unsigned char); } 
# 376
extern "C" { __attribute__((unused)) void __sust_b_2d_i16_zero(cudaSurfaceObject_t, int, int, unsigned short); } 
# 377
extern "C" { __attribute__((unused)) void __sust_b_2d_i32_zero(cudaSurfaceObject_t, int, int, unsigned); } 
# 378
extern "C" { __attribute__((unused)) void __sust_b_2d_i64_zero(cudaSurfaceObject_t, int, int, unsigned long long); } 
# 379
extern "C" { __attribute__((unused)) void __sust_b_2d_v2i8_zero(cudaSurfaceObject_t, int, int, uchar2); } 
# 380
extern "C" { __attribute__((unused)) void __sust_b_2d_v2i16_zero(cudaSurfaceObject_t, int, int, ushort2); } 
# 381
extern "C" { __attribute__((unused)) void __sust_b_2d_v2i32_zero(cudaSurfaceObject_t, int, int, uint2); } 
# 382
extern "C" { __attribute__((unused)) void __sust_b_2d_v2i64_zero(cudaSurfaceObject_t, int, int, ulonglong2); } 
# 383
extern "C" { __attribute__((unused)) void __sust_b_2d_v4i8_zero(cudaSurfaceObject_t, int, int, uchar4); } 
# 384
extern "C" { __attribute__((unused)) void __sust_b_2d_v4i16_zero(cudaSurfaceObject_t, int, int, ushort4); } 
# 385
extern "C" { __attribute__((unused)) void __sust_b_2d_v4i32_zero(cudaSurfaceObject_t, int, int, uint4); } 
# 386
extern "C" { __attribute__((unused)) void __sust_b_2d_array_i8_zero(cudaSurfaceObject_t, int, int, int, unsigned char); } 
# 387
extern "C" { __attribute__((unused)) void __sust_b_2d_array_i16_zero(cudaSurfaceObject_t, int, int, int, unsigned short); } 
# 388
extern "C" { __attribute__((unused)) void __sust_b_2d_array_i32_zero(cudaSurfaceObject_t, int, int, int, unsigned); } 
# 389
extern "C" { __attribute__((unused)) void __sust_b_2d_array_i64_zero(cudaSurfaceObject_t, int, int, int, unsigned long long); } 
# 390
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v2i8_zero(cudaSurfaceObject_t, int, int, int, uchar2); } 
# 391
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v2i16_zero(cudaSurfaceObject_t, int, int, int, ushort2); } 
# 392
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v2i32_zero(cudaSurfaceObject_t, int, int, int, uint2); } 
# 393
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v2i64_zero(cudaSurfaceObject_t, int, int, int, ulonglong2); } 
# 394
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v4i8_zero(cudaSurfaceObject_t, int, int, int, uchar4); } 
# 395
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v4i16_zero(cudaSurfaceObject_t, int, int, int, ushort4); } 
# 396
extern "C" { __attribute__((unused)) void __sust_b_2d_array_v4i32_zero(cudaSurfaceObject_t, int, int, int, uint4); } 
# 397
extern "C" { __attribute__((unused)) void __sust_b_3d_i8_zero(cudaSurfaceObject_t, int, int, int, unsigned char); } 
# 398
extern "C" { __attribute__((unused)) void __sust_b_3d_i16_zero(cudaSurfaceObject_t, int, int, int, unsigned short); } 
# 399
extern "C" { __attribute__((unused)) void __sust_b_3d_i32_zero(cudaSurfaceObject_t, int, int, int, unsigned); } 
# 400
extern "C" { __attribute__((unused)) void __sust_b_3d_i64_zero(cudaSurfaceObject_t, int, int, int, unsigned long long); } 
# 401
extern "C" { __attribute__((unused)) void __sust_b_3d_v2i8_zero(cudaSurfaceObject_t, int, int, int, uchar2); } 
# 402
extern "C" { __attribute__((unused)) void __sust_b_3d_v2i16_zero(cudaSurfaceObject_t, int, int, int, ushort2); } 
# 403
extern "C" { __attribute__((unused)) void __sust_b_3d_v2i32_zero(cudaSurfaceObject_t, int, int, int, uint2); } 
# 404
extern "C" { __attribute__((unused)) void __sust_b_3d_v2i64_zero(cudaSurfaceObject_t, int, int, int, ulonglong2); } 
# 405
extern "C" { __attribute__((unused)) void __sust_b_3d_v4i8_zero(cudaSurfaceObject_t, int, int, int, uchar4); } 
# 406
extern "C" { __attribute__((unused)) void __sust_b_3d_v4i16_zero(cudaSurfaceObject_t, int, int, int, ushort4); } 
# 407
extern "C" { __attribute__((unused)) void __sust_b_3d_v4i32_zero(cudaSurfaceObject_t, int, int, int, uint4); } 
# 410
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(char * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 412
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(signed char * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 414
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(char1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 416
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(unsigned char * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 418
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uchar1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 420
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(short * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 422
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(short1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 424
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(unsigned short * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 426
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(ushort1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 428
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(int * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 430
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(int1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 432
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(unsigned * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 434
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uint1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 436
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(long long * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 438
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(longlong1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 440
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(unsigned long long * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 442
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(ulonglong1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 444
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(float * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 446
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(float1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 454
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(char2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 456
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uchar2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 458
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(short2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 460
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(ushort2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 462
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(int2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 464
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uint2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 466
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(longlong2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 468
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(ulonglong2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 470
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(float2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 478
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(char4 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 480
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uchar4 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 482
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(short4 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 484
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(ushort4 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 486
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(int4 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 488
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uint4 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 490
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(float4 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 498
template< class T> 
# 499
__attribute((always_inline)) __attribute__((unused)) static inline T surf1Dread(cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 500
{int volatile ___ = 1;(void)surfObject;(void)x;(void)boundaryMode;
# 504
::exit(___);}
#if 0
# 500
{ 
# 501
T ret; 
# 502
surf1Dread(&ret, surfObject, x, boundaryMode); 
# 503
return ret; 
# 504
} 
#endif
# 512 "/usr/include/surface_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(char * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 514
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(signed char * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 516
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(char1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 518
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(unsigned char * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 520
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uchar1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 522
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(short * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 524
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(short1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 526
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(unsigned short * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 528
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(ushort1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 530
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(int * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 532
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(int1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 534
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(unsigned * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 536
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uint1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 538
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(long long * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 540
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(longlong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 542
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(unsigned long long * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 544
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(ulonglong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 546
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(float * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 548
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(float1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 556
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(char2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 558
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uchar2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 560
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(short2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 562
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(ushort2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 564
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(int2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 566
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uint2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 568
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(longlong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 570
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(ulonglong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 572
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(float2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 580
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(char4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 582
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uchar4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 584
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(short4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 586
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(ushort4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 588
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(int4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 590
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uint4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 592
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(float4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 600
template< class T> 
# 601
__attribute((always_inline)) __attribute__((unused)) static inline T surf2Dread(cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 602
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 606
::exit(___);}
#if 0
# 602
{ 
# 603
T ret; 
# 604
surf2Dread(&ret, surfObject, x, y, boundaryMode); 
# 605
return ret; 
# 606
} 
#endif
# 614 "/usr/include/surface_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 616
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(signed char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 618
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(char1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 620
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(unsigned char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 622
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uchar1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 624
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 626
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(short1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 628
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(unsigned short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 630
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(ushort1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 632
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(int * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 634
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(int1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 636
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(unsigned * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 638
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uint1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 640
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(long long * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 642
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(longlong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 644
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(unsigned long long * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 646
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(ulonglong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 648
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(float * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 650
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(float1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 658
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(char2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 660
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uchar2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 662
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(short2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 664
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(ushort2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 666
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(int2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 668
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uint2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 670
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(longlong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 672
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(ulonglong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 674
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(float2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 682
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(char4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 684
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uchar4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 686
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(short4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 688
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(ushort4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 690
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(int4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 692
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uint4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 694
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(float4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 702
template< class T> 
# 703
__attribute((always_inline)) __attribute__((unused)) static inline T surf3Dread(cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 704
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 708
::exit(___);}
#if 0
# 704
{ 
# 705
T ret; 
# 706
surf3Dread(&ret, surfObject, x, y, z, boundaryMode); 
# 707
return ret; 
# 708
} 
#endif
# 716 "/usr/include/surface_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(char * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 718
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(signed char * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 720
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(char1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 722
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(unsigned char * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 724
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uchar1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 726
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(short * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 728
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(short1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 730
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(unsigned short * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 732
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(ushort1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 734
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(int * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 736
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(int1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 738
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(unsigned * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 740
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uint1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 742
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(long long * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 744
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(longlong1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 746
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(unsigned long long * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 748
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(ulonglong1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 750
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(float * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 752
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(float1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 760
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(char2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 762
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uchar2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 764
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(short2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 766
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(ushort2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 768
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(int2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 770
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uint2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 772
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(longlong2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 774
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(ulonglong2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 776
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(float2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 784
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(char4 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 786
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uchar4 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 788
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(short4 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 790
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(ushort4 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 792
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(int4 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 794
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uint4 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 796
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(float4 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 804
template< class T> 
# 805
__attribute((always_inline)) __attribute__((unused)) static inline T surf1DLayeredread(cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 806
{int volatile ___ = 1;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 810
::exit(___);}
#if 0
# 806
{ 
# 807
T ret; 
# 808
surf1DLayeredread(&ret, surfObject, x, layer, boundaryMode); 
# 809
return ret; 
# 810
} 
#endif
# 818 "/usr/include/surface_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 820
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(signed char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 822
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(char1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 824
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(unsigned char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 826
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uchar1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 828
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 830
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(short1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 832
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(unsigned short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 834
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(ushort1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 836
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(int * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 838
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(int1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 840
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(unsigned * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 842
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uint1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 844
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(long long * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 846
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(longlong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 848
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(unsigned long long * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 850
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(ulonglong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 852
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(float * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 854
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(float1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 862
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(char2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 864
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uchar2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 866
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(short2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 868
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(ushort2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 870
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(int2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 872
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uint2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 874
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(longlong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 876
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(ulonglong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 878
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(float2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 886
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(char4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 888
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uchar4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 890
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(short4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 892
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(ushort4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 894
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(int4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 896
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uint4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 898
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(float4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 906
template< class T> 
# 907
__attribute((always_inline)) __attribute__((unused)) static inline T surf2DLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 908
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 912
::exit(___);}
#if 0
# 908
{ 
# 909
T ret; 
# 910
surf2DLayeredread(&ret, surfObject, x, y, layer, boundaryMode); 
# 911
return ret; 
# 912
} 
#endif
# 920 "/usr/include/surface_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 922
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(signed char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 924
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(char1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 926
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(unsigned char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 928
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uchar1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 930
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 932
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(short1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 934
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(unsigned short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 936
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(ushort1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 938
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(int * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 940
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(int1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 942
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(unsigned * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 944
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uint1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 946
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(long long * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 948
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(longlong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 950
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(unsigned long long * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 952
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(ulonglong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 954
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(float * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 956
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(float1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 964
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(char2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 966
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uchar2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 968
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(short2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 970
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(ushort2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 972
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(int2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 974
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uint2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 976
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(longlong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 978
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(ulonglong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 980
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(float2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 988
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(char4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 990
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uchar4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 992
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(short4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 994
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(ushort4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 996
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(int4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 998
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uint4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1000
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(float4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1008
template< class T> 
# 1009
__attribute((always_inline)) __attribute__((unused)) static inline T surfCubemapread(cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1010
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 1014
::exit(___);}
#if 0
# 1010
{ 
# 1011
T ret; 
# 1012
surfCubemapread(&ret, surfObject, face, x, y, boundaryMode); 
# 1013
return ret; 
# 1014
} 
#endif
# 1022 "/usr/include/surface_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1024
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(signed char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1026
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(char1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1028
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(unsigned char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1030
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uchar1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1032
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1034
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(short1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1036
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(unsigned short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1038
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(ushort1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1040
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(int * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1042
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(int1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1044
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(unsigned * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1046
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uint1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1048
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(long long * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1050
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(longlong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1052
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(unsigned long long * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1054
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(ulonglong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1056
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(float * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1058
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(float1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1066
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(char2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1068
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uchar2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1070
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(short2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1072
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(ushort2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1074
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(int2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1076
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uint2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1078
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(longlong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1080
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(ulonglong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1082
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(float2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1090
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(char4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1092
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uchar4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1094
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(short4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1096
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(ushort4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1098
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(int4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1100
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uint4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1102
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(float4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1110
template< class T> 
# 1111
__attribute((always_inline)) __attribute__((unused)) static inline T surfCubemapLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1112
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 1116
::exit(___);}
#if 0
# 1112
{ 
# 1113
T ret; 
# 1114
surfCubemapLayeredread(&ret, surfObject, x, y, layerface, boundaryMode); 
# 1115
return ret; 
# 1116
} 
#endif
# 1124 "/usr/include/surface_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1126
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1128
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1130
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1132
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1134
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1136
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1138
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1140
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1142
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1144
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1146
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1148
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1150
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1152
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1154
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1156
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1158
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1160
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1168
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1170
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1172
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1174
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1176
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1178
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1180
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1182
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1184
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1192
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1194
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1196
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1198
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1200
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1202
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1204
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1212
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1214
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1216
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1218
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1220
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1222
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1224
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1226
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1228
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1230
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1232
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1234
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1236
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1238
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1240
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1242
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1244
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1246
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1248
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1256
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1258
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1260
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1262
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1264
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1266
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1268
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1270
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1272
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1280
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1282
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1284
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1286
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1288
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1290
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1292
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1301 "/usr/include/surface_indirect_functions.h" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1303
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1305
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1307
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1309
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1311
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1313
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1315
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1317
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1319
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1321
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1323
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1325
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1327
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1329
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1331
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1333
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1335
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1337
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1345
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1347
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1349
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1351
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1353
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1355
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1357
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1359
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1361
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1369
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1371
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1373
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1375
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1377
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1379
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1381
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1389
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1391
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1393
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1395
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1397
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1399
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1401
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1403
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1405
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1407
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1409
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1411
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1413
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1415
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1417
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1419
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1421
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1423
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1425
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1433
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1435
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1437
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1439
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1441
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1443
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1445
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1447
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1449
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1457
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1459
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1461
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1463
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1465
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1467
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1469
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1477
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1479
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1481
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1483
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1485
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1487
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1489
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1491
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1493
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1495
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1497
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1499
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1501
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1503
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1505
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1507
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1509
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1511
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1513
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1521
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1523
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1525
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1527
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1529
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1531
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1533
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1535
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1537
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1545
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1547
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1549
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1551
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1553
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1555
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1557
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1565
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1567
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1569
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1571
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1573
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1575
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1577
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1579
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1581
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1583
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1585
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1587
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1589
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1591
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1593
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1595
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1597
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1599
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1601
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1609
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1611
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1613
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1615
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1617
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1619
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1621
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1623
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1625
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1633
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1635
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1637
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1639
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1641
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1643
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1645
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1653
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1655
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1657
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1659
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1661
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1663
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1665
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1667
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1669
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1671
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1673
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1675
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1677
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1679
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1681
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1683
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1685
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1687
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1689
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1697
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1699
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1701
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1703
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1705
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1707
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1709
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1711
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1713
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1721
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1723
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1725
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1727
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1729
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1731
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 1733
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
# 76 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 77
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 89
::exit(___);}
#if 0
# 77
{ 
# 78
char tmp; 
# 79
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 80
__suld_1d_i8_trap(&tmp, surfObject, x); 
# 81
} else { 
# 82
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 83
__suld_1d_i8_clamp(&tmp, surfObject, x); 
# 84
} else { 
# 85
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 86
__suld_1d_i8_zero(&tmp, surfObject, x); 
# 87
}  }  }  
# 88
(*retVal) = tmp; 
# 89
} 
#endif
# 91 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 92
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 104
::exit(___);}
#if 0
# 92
{ 
# 93
signed char tmp; 
# 94
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 95
__suld_1d_i8_trap((char *)(&tmp), surfObject, x); 
# 96
} else { 
# 97
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 98
__suld_1d_i8_clamp((char *)(&tmp), surfObject, x); 
# 99
} else { 
# 100
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 101
__suld_1d_i8_zero((char *)(&tmp), surfObject, x); 
# 102
}  }  }  
# 103
(*retVal) = ((signed char)tmp); 
# 104
} 
#endif
# 106 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 107
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 119
::exit(___);}
#if 0
# 107
{ 
# 108
char1 tmp; 
# 109
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 110
__suld_1d_i8_trap((char *)(&(tmp.x)), surfObject, x); 
# 111
} else { 
# 112
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 113
__suld_1d_i8_clamp((char *)(&(tmp.x)), surfObject, x); 
# 114
} else { 
# 115
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 116
__suld_1d_i8_zero((char *)(&(tmp.x)), surfObject, x); 
# 117
}  }  }  
# 118
(*retVal) = make_char1(tmp.x); 
# 119
} 
#endif
# 121 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 122
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 134
::exit(___);}
#if 0
# 122
{ 
# 123
unsigned char tmp; 
# 124
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 125
__suld_1d_i8_trap((char *)(&tmp), surfObject, x); 
# 126
} else { 
# 127
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 128
__suld_1d_i8_clamp((char *)(&tmp), surfObject, x); 
# 129
} else { 
# 130
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 131
__suld_1d_i8_zero((char *)(&tmp), surfObject, x); 
# 132
}  }  }  
# 133
(*retVal) = ((unsigned char)tmp); 
# 134
} 
#endif
# 136 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 137
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 149
::exit(___);}
#if 0
# 137
{ 
# 138
uchar1 tmp; 
# 139
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 140
__suld_1d_i8_trap((char *)(&(tmp.x)), surfObject, x); 
# 141
} else { 
# 142
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 143
__suld_1d_i8_clamp((char *)(&(tmp.x)), surfObject, x); 
# 144
} else { 
# 145
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 146
__suld_1d_i8_zero((char *)(&(tmp.x)), surfObject, x); 
# 147
}  }  }  
# 148
(*retVal) = make_uchar1(tmp.x); 
# 149
} 
#endif
# 151 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 152
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 164
::exit(___);}
#if 0
# 152
{ 
# 153
short tmp; 
# 154
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 155
__suld_1d_i16_trap(&tmp, surfObject, x); 
# 156
} else { 
# 157
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 158
__suld_1d_i16_clamp(&tmp, surfObject, x); 
# 159
} else { 
# 160
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 161
__suld_1d_i16_zero(&tmp, surfObject, x); 
# 162
}  }  }  
# 163
(*retVal) = tmp; 
# 164
} 
#endif
# 166 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 167
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 179
::exit(___);}
#if 0
# 167
{ 
# 168
short tmp; 
# 169
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 170
__suld_1d_i16_trap(&tmp, surfObject, x); 
# 171
} else { 
# 172
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 173
__suld_1d_i16_clamp(&tmp, surfObject, x); 
# 174
} else { 
# 175
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 176
__suld_1d_i16_zero(&tmp, surfObject, x); 
# 177
}  }  }  
# 178
(*retVal) = make_short1(tmp); 
# 179
} 
#endif
# 181 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 182
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 194
::exit(___);}
#if 0
# 182
{ 
# 183
unsigned short tmp; 
# 184
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 185
__suld_1d_i16_trap((short *)(&tmp), surfObject, x); 
# 186
} else { 
# 187
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 188
__suld_1d_i16_clamp((short *)(&tmp), surfObject, x); 
# 189
} else { 
# 190
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 191
__suld_1d_i16_zero((short *)(&tmp), surfObject, x); 
# 192
}  }  }  
# 193
(*retVal) = tmp; 
# 194
} 
#endif
# 196 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 197
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 209
::exit(___);}
#if 0
# 197
{ 
# 198
unsigned short tmp; 
# 199
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 200
__suld_1d_i16_trap((short *)(&tmp), surfObject, x); 
# 201
} else { 
# 202
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 203
__suld_1d_i16_clamp((short *)(&tmp), surfObject, x); 
# 204
} else { 
# 205
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 206
__suld_1d_i16_zero((short *)(&tmp), surfObject, x); 
# 207
}  }  }  
# 208
(*retVal) = make_ushort1(tmp); 
# 209
} 
#endif
# 211 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 212
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 224
::exit(___);}
#if 0
# 212
{ 
# 213
int tmp; 
# 214
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 215
__suld_1d_i32_trap(&tmp, surfObject, x); 
# 216
} else { 
# 217
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 218
__suld_1d_i32_clamp(&tmp, surfObject, x); 
# 219
} else { 
# 220
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 221
__suld_1d_i32_zero(&tmp, surfObject, x); 
# 222
}  }  }  
# 223
(*retVal) = tmp; 
# 224
} 
#endif
# 226 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 227
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 239
::exit(___);}
#if 0
# 227
{ 
# 228
int tmp; 
# 229
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 230
__suld_1d_i32_trap(&tmp, surfObject, x); 
# 231
} else { 
# 232
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 233
__suld_1d_i32_clamp(&tmp, surfObject, x); 
# 234
} else { 
# 235
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 236
__suld_1d_i32_zero(&tmp, surfObject, x); 
# 237
}  }  }  
# 238
(*retVal) = make_int1(tmp); 
# 239
} 
#endif
# 241 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 242
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 254
::exit(___);}
#if 0
# 242
{ 
# 243
unsigned tmp; 
# 244
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 245
__suld_1d_i32_trap((int *)(&tmp), surfObject, x); 
# 246
} else { 
# 247
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 248
__suld_1d_i32_clamp((int *)(&tmp), surfObject, x); 
# 249
} else { 
# 250
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 251
__suld_1d_i32_zero((int *)(&tmp), surfObject, x); 
# 252
}  }  }  
# 253
(*retVal) = ((unsigned)tmp); 
# 254
} 
#endif
# 256 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 257
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 269
::exit(___);}
#if 0
# 257
{ 
# 258
unsigned tmp; 
# 259
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 260
__suld_1d_i32_trap((int *)(&tmp), surfObject, x); 
# 261
} else { 
# 262
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 263
__suld_1d_i32_clamp((int *)(&tmp), surfObject, x); 
# 264
} else { 
# 265
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 266
__suld_1d_i32_zero((int *)(&tmp), surfObject, x); 
# 267
}  }  }  
# 268
(*retVal) = make_uint1(tmp); 
# 269
} 
#endif
# 271 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(long long *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 272
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 284
::exit(___);}
#if 0
# 272
{ 
# 273
long long tmp; 
# 274
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 275
__suld_1d_i64_trap(&tmp, surfObject, x); 
# 276
} else { 
# 277
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 278
__suld_1d_i64_clamp(&tmp, surfObject, x); 
# 279
} else { 
# 280
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 281
__suld_1d_i64_zero(&tmp, surfObject, x); 
# 282
}  }  }  
# 283
(*retVal) = tmp; 
# 284
} 
#endif
# 286 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 287
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 299
::exit(___);}
#if 0
# 287
{ 
# 288
long long tmp; 
# 289
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 290
__suld_1d_i64_trap(&tmp, surfObject, x); 
# 291
} else { 
# 292
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 293
__suld_1d_i64_clamp(&tmp, surfObject, x); 
# 294
} else { 
# 295
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 296
__suld_1d_i64_zero(&tmp, surfObject, x); 
# 297
}  }  }  
# 298
(*retVal) = make_longlong1(tmp); 
# 299
} 
#endif
# 301 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 302
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 314
::exit(___);}
#if 0
# 302
{ 
# 303
unsigned long long tmp; 
# 304
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 305
__suld_1d_i64_trap((long long *)(&tmp), surfObject, x); 
# 306
} else { 
# 307
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 308
__suld_1d_i64_clamp((long long *)(&tmp), surfObject, x); 
# 309
} else { 
# 310
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 311
__suld_1d_i64_zero((long long *)(&tmp), surfObject, x); 
# 312
}  }  }  
# 313
(*retVal) = tmp; 
# 314
} 
#endif
# 316 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 317
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 329
::exit(___);}
#if 0
# 317
{ 
# 318
unsigned long long tmp; 
# 319
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 320
__suld_1d_i64_trap((long long *)(&tmp), surfObject, x); 
# 321
} else { 
# 322
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 323
__suld_1d_i64_clamp((long long *)(&tmp), surfObject, x); 
# 324
} else { 
# 325
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 326
__suld_1d_i64_zero((long long *)(&tmp), surfObject, x); 
# 327
}  }  }  
# 328
(*retVal) = make_ulonglong1(tmp); 
# 329
} 
#endif
# 331 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 332
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 344
::exit(___);}
#if 0
# 332
{ 
# 333
float tmp; 
# 334
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 335
__suld_1d_i32_trap((int *)(&tmp), surfObject, x); 
# 336
} else { 
# 337
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 338
__suld_1d_i32_clamp((int *)(&tmp), surfObject, x); 
# 339
} else { 
# 340
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 341
__suld_1d_i32_zero((int *)(&tmp), surfObject, x); 
# 342
}  }  }  
# 343
(*retVal) = tmp; 
# 344
} 
#endif
# 346 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 347
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 359
::exit(___);}
#if 0
# 347
{ 
# 348
float tmp; 
# 349
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 350
__suld_1d_i32_trap((int *)(&tmp), surfObject, x); 
# 351
} else { 
# 352
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 353
__suld_1d_i32_clamp((int *)(&tmp), surfObject, x); 
# 354
} else { 
# 355
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 356
__suld_1d_i32_zero((int *)(&tmp), surfObject, x); 
# 357
}  }  }  
# 358
(*retVal) = make_float1(tmp); 
# 359
} 
#endif
# 367 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 368
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 380
::exit(___);}
#if 0
# 368
{ 
# 369
char2 tmp; 
# 370
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 371
__suld_1d_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x); 
# 372
} else { 
# 373
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 374
__suld_1d_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x); 
# 375
} else { 
# 376
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 377
__suld_1d_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x); 
# 378
}  }  }  
# 379
(*retVal) = tmp; 
# 380
} 
#endif
# 382 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 383
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 395
::exit(___);}
#if 0
# 383
{ 
# 384
uchar2 tmp; 
# 385
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 386
__suld_1d_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x); 
# 387
} else { 
# 388
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 389
__suld_1d_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x); 
# 390
} else { 
# 391
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 392
__suld_1d_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x); 
# 393
}  }  }  
# 394
(*retVal) = tmp; 
# 395
} 
#endif
# 397 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 398
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 410
::exit(___);}
#if 0
# 398
{ 
# 399
short2 tmp; 
# 400
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 401
__suld_1d_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x); 
# 402
} else { 
# 403
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 404
__suld_1d_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x); 
# 405
} else { 
# 406
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 407
__suld_1d_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x); 
# 408
}  }  }  
# 409
(*retVal) = tmp; 
# 410
} 
#endif
# 412 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 413
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 425
::exit(___);}
#if 0
# 413
{ 
# 414
ushort2 tmp; 
# 415
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 416
__suld_1d_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x); 
# 417
} else { 
# 418
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 419
__suld_1d_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x); 
# 420
} else { 
# 421
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 422
__suld_1d_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x); 
# 423
}  }  }  
# 424
(*retVal) = tmp; 
# 425
} 
#endif
# 427 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 428
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 440
::exit(___);}
#if 0
# 428
{ 
# 429
int2 tmp; 
# 430
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 431
__suld_1d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
# 432
} else { 
# 433
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 434
__suld_1d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
# 435
} else { 
# 436
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 437
__suld_1d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
# 438
}  }  }  
# 439
(*retVal) = tmp; 
# 440
} 
#endif
# 442 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 443
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 455
::exit(___);}
#if 0
# 443
{ 
# 444
uint2 tmp; 
# 445
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 446
__suld_1d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
# 447
} else { 
# 448
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 449
__suld_1d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
# 450
} else { 
# 451
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 452
__suld_1d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
# 453
}  }  }  
# 454
(*retVal) = tmp; 
# 455
} 
#endif
# 457 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 458
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 470
::exit(___);}
#if 0
# 458
{ 
# 459
longlong2 tmp; 
# 460
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 461
__suld_1d_v2i64_trap((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x); 
# 462
} else { 
# 463
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 464
__suld_1d_v2i64_clamp((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x); 
# 465
} else { 
# 466
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 467
__suld_1d_v2i64_zero((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x); 
# 468
}  }  }  
# 469
(*retVal) = tmp; 
# 470
} 
#endif
# 472 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 473
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 485
::exit(___);}
#if 0
# 473
{ 
# 474
ulonglong2 tmp; 
# 475
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 476
__suld_1d_v2i64_trap((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x); 
# 477
} else { 
# 478
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 479
__suld_1d_v2i64_clamp((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x); 
# 480
} else { 
# 481
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 482
__suld_1d_v2i64_zero((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x); 
# 483
}  }  }  
# 484
(*retVal) = tmp; 
# 485
} 
#endif
# 487 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 488
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 500
::exit(___);}
#if 0
# 488
{ 
# 489
float2 tmp; 
# 490
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 491
__suld_1d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
# 492
} else { 
# 493
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 494
__suld_1d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
# 495
} else { 
# 496
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 497
__suld_1d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
# 498
}  }  }  
# 499
(*retVal) = tmp; 
# 500
} 
#endif
# 508 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 509
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 521
::exit(___);}
#if 0
# 509
{ 
# 510
char4 tmp; 
# 511
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 512
__suld_1d_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x); 
# 513
} else { 
# 514
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 515
__suld_1d_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x); 
# 516
} else { 
# 517
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 518
__suld_1d_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x); 
# 519
}  }  }  
# 520
(*retVal) = tmp; 
# 521
} 
#endif
# 523 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 524
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 536
::exit(___);}
#if 0
# 524
{ 
# 525
uchar4 tmp; 
# 526
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 527
__suld_1d_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x); 
# 528
} else { 
# 529
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 530
__suld_1d_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x); 
# 531
} else { 
# 532
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 533
__suld_1d_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x); 
# 534
}  }  }  
# 535
(*retVal) = tmp; 
# 536
} 
#endif
# 538 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 539
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 551
::exit(___);}
#if 0
# 539
{ 
# 540
short4 tmp; 
# 541
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 542
__suld_1d_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x); 
# 543
} else { 
# 544
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 545
__suld_1d_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x); 
# 546
} else { 
# 547
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 548
__suld_1d_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x); 
# 549
}  }  }  
# 550
(*retVal) = tmp; 
# 551
} 
#endif
# 553 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 554
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 566
::exit(___);}
#if 0
# 554
{ 
# 555
ushort4 tmp; 
# 556
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 557
__suld_1d_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x); 
# 558
} else { 
# 559
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 560
__suld_1d_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x); 
# 561
} else { 
# 562
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 563
__suld_1d_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x); 
# 564
}  }  }  
# 565
(*retVal) = tmp; 
# 566
} 
#endif
# 568 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 569
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 581
::exit(___);}
#if 0
# 569
{ 
# 570
int4 tmp; 
# 571
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 572
__suld_1d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
# 573
} else { 
# 574
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 575
__suld_1d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
# 576
} else { 
# 577
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 578
__suld_1d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
# 579
}  }  }  
# 580
(*retVal) = tmp; 
# 581
} 
#endif
# 583 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 584
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 596
::exit(___);}
#if 0
# 584
{ 
# 585
uint4 tmp; 
# 586
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 587
__suld_1d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
# 588
} else { 
# 589
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 590
__suld_1d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
# 591
} else { 
# 592
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 593
__suld_1d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
# 594
}  }  }  
# 595
(*retVal) = tmp; 
# 596
} 
#endif
# 598 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 599
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 611
::exit(___);}
#if 0
# 599
{ 
# 600
float4 tmp; 
# 601
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 602
__suld_1d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
# 603
} else { 
# 604
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 605
__suld_1d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
# 606
} else { 
# 607
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 608
__suld_1d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
# 609
}  }  }  
# 610
(*retVal) = tmp; 
# 611
} 
#endif
# 619 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 620
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 632
::exit(___);}
#if 0
# 620
{ 
# 621
char tmp; 
# 622
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 623
__suld_2d_i8_trap(&tmp, surfObject, x, y); 
# 624
} else { 
# 625
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 626
__suld_2d_i8_clamp(&tmp, surfObject, x, y); 
# 627
} else { 
# 628
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 629
__suld_2d_i8_zero(&tmp, surfObject, x, y); 
# 630
}  }  }  
# 631
(*retVal) = ((char)tmp); 
# 632
} 
#endif
# 634 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 635
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 647
::exit(___);}
#if 0
# 635
{ 
# 636
signed char tmp; 
# 637
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 638
__suld_2d_i8_trap((char *)(&tmp), surfObject, x, y); 
# 639
} else { 
# 640
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 641
__suld_2d_i8_clamp((char *)(&tmp), surfObject, x, y); 
# 642
} else { 
# 643
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 644
__suld_2d_i8_zero((char *)(&tmp), surfObject, x, y); 
# 645
}  }  }  
# 646
(*retVal) = tmp; 
# 647
} 
#endif
# 649 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 650
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 662
::exit(___);}
#if 0
# 650
{ 
# 651
char tmp; 
# 652
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 653
__suld_2d_i8_trap((char *)(&tmp), surfObject, x, y); 
# 654
} else { 
# 655
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 656
__suld_2d_i8_clamp((char *)(&tmp), surfObject, x, y); 
# 657
} else { 
# 658
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 659
__suld_2d_i8_zero((char *)(&tmp), surfObject, x, y); 
# 660
}  }  }  
# 661
(*retVal) = make_char1(tmp); 
# 662
} 
#endif
# 664 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 665
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 677
::exit(___);}
#if 0
# 665
{ 
# 666
unsigned char tmp; 
# 667
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 668
__suld_2d_i8_trap((char *)(&tmp), surfObject, x, y); 
# 669
} else { 
# 670
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 671
__suld_2d_i8_clamp((char *)(&tmp), surfObject, x, y); 
# 672
} else { 
# 673
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 674
__suld_2d_i8_zero((char *)(&tmp), surfObject, x, y); 
# 675
}  }  }  
# 676
(*retVal) = tmp; 
# 677
} 
#endif
# 679 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 680
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 692
::exit(___);}
#if 0
# 680
{ 
# 681
unsigned char tmp; 
# 682
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 683
__suld_2d_i8_trap((char *)(&tmp), surfObject, x, y); 
# 684
} else { 
# 685
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 686
__suld_2d_i8_clamp((char *)(&tmp), surfObject, x, y); 
# 687
} else { 
# 688
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 689
__suld_2d_i8_zero((char *)(&tmp), surfObject, x, y); 
# 690
}  }  }  
# 691
(*retVal) = make_uchar1(tmp); 
# 692
} 
#endif
# 694 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 695
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 707
::exit(___);}
#if 0
# 695
{ 
# 696
short tmp; 
# 697
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 698
__suld_2d_i16_trap((short *)(&tmp), surfObject, x, y); 
# 699
} else { 
# 700
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 701
__suld_2d_i16_clamp((short *)(&tmp), surfObject, x, y); 
# 702
} else { 
# 703
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 704
__suld_2d_i16_zero((short *)(&tmp), surfObject, x, y); 
# 705
}  }  }  
# 706
(*retVal) = tmp; 
# 707
} 
#endif
# 709 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 710
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 722
::exit(___);}
#if 0
# 710
{ 
# 711
short tmp; 
# 712
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 713
__suld_2d_i16_trap((short *)(&tmp), surfObject, x, y); 
# 714
} else { 
# 715
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 716
__suld_2d_i16_clamp((short *)(&tmp), surfObject, x, y); 
# 717
} else { 
# 718
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 719
__suld_2d_i16_zero((short *)(&tmp), surfObject, x, y); 
# 720
}  }  }  
# 721
(*retVal) = make_short1(tmp); 
# 722
} 
#endif
# 724 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 725
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 737
::exit(___);}
#if 0
# 725
{ 
# 726
unsigned short tmp; 
# 727
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 728
__suld_2d_i16_trap((short *)(&tmp), surfObject, x, y); 
# 729
} else { 
# 730
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 731
__suld_2d_i16_clamp((short *)(&tmp), surfObject, x, y); 
# 732
} else { 
# 733
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 734
__suld_2d_i16_zero((short *)(&tmp), surfObject, x, y); 
# 735
}  }  }  
# 736
(*retVal) = tmp; 
# 737
} 
#endif
# 739 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 740
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 752
::exit(___);}
#if 0
# 740
{ 
# 741
unsigned short tmp; 
# 742
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 743
__suld_2d_i16_trap((short *)(&tmp), surfObject, x, y); 
# 744
} else { 
# 745
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 746
__suld_2d_i16_clamp((short *)(&tmp), surfObject, x, y); 
# 747
} else { 
# 748
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 749
__suld_2d_i16_zero((short *)(&tmp), surfObject, x, y); 
# 750
}  }  }  
# 751
(*retVal) = make_ushort1(tmp); 
# 752
} 
#endif
# 754 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 755
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 767
::exit(___);}
#if 0
# 755
{ 
# 756
int tmp; 
# 757
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 758
__suld_2d_i32_trap((int *)(&tmp), surfObject, x, y); 
# 759
} else { 
# 760
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 761
__suld_2d_i32_clamp((int *)(&tmp), surfObject, x, y); 
# 762
} else { 
# 763
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 764
__suld_2d_i32_zero((int *)(&tmp), surfObject, x, y); 
# 765
}  }  }  
# 766
(*retVal) = tmp; 
# 767
} 
#endif
# 769 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 770
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 782
::exit(___);}
#if 0
# 770
{ 
# 771
int tmp; 
# 772
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 773
__suld_2d_i32_trap((int *)(&tmp), surfObject, x, y); 
# 774
} else { 
# 775
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 776
__suld_2d_i32_clamp((int *)(&tmp), surfObject, x, y); 
# 777
} else { 
# 778
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 779
__suld_2d_i32_zero((int *)(&tmp), surfObject, x, y); 
# 780
}  }  }  
# 781
(*retVal) = make_int1(tmp); 
# 782
} 
#endif
# 784 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 785
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 797
::exit(___);}
#if 0
# 785
{ 
# 786
unsigned tmp; 
# 787
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 788
__suld_2d_i32_trap((int *)(&tmp), surfObject, x, y); 
# 789
} else { 
# 790
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 791
__suld_2d_i32_clamp((int *)(&tmp), surfObject, x, y); 
# 792
} else { 
# 793
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 794
__suld_2d_i32_zero((int *)(&tmp), surfObject, x, y); 
# 795
}  }  }  
# 796
(*retVal) = tmp; 
# 797
} 
#endif
# 799 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 800
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 812
::exit(___);}
#if 0
# 800
{ 
# 801
unsigned tmp; 
# 802
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 803
__suld_2d_i32_trap((int *)(&tmp), surfObject, x, y); 
# 804
} else { 
# 805
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 806
__suld_2d_i32_clamp((int *)(&tmp), surfObject, x, y); 
# 807
} else { 
# 808
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 809
__suld_2d_i32_zero((int *)(&tmp), surfObject, x, y); 
# 810
}  }  }  
# 811
(*retVal) = make_uint1(tmp); 
# 812
} 
#endif
# 814 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 815
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 827
::exit(___);}
#if 0
# 815
{ 
# 816
long long tmp; 
# 817
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 818
__suld_2d_i64_trap((long long *)(&tmp), surfObject, x, y); 
# 819
} else { 
# 820
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 821
__suld_2d_i64_clamp((long long *)(&tmp), surfObject, x, y); 
# 822
} else { 
# 823
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 824
__suld_2d_i64_zero((long long *)(&tmp), surfObject, x, y); 
# 825
}  }  }  
# 826
(*retVal) = tmp; 
# 827
} 
#endif
# 829 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 830
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 842
::exit(___);}
#if 0
# 830
{ 
# 831
long long tmp; 
# 832
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 833
__suld_2d_i64_trap((long long *)(&tmp), surfObject, x, y); 
# 834
} else { 
# 835
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 836
__suld_2d_i64_clamp((long long *)(&tmp), surfObject, x, y); 
# 837
} else { 
# 838
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 839
__suld_2d_i64_zero((long long *)(&tmp), surfObject, x, y); 
# 840
}  }  }  
# 841
(*retVal) = make_longlong1(tmp); 
# 842
} 
#endif
# 844 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 845
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 857
::exit(___);}
#if 0
# 845
{ 
# 846
unsigned long long tmp; 
# 847
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 848
__suld_2d_i64_trap((long long *)(&tmp), surfObject, x, y); 
# 849
} else { 
# 850
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 851
__suld_2d_i64_clamp((long long *)(&tmp), surfObject, x, y); 
# 852
} else { 
# 853
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 854
__suld_2d_i64_zero((long long *)(&tmp), surfObject, x, y); 
# 855
}  }  }  
# 856
(*retVal) = tmp; 
# 857
} 
#endif
# 859 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 860
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 872
::exit(___);}
#if 0
# 860
{ 
# 861
unsigned long long tmp; 
# 862
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 863
__suld_2d_i64_trap((long long *)(&tmp), surfObject, x, y); 
# 864
} else { 
# 865
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 866
__suld_2d_i64_clamp((long long *)(&tmp), surfObject, x, y); 
# 867
} else { 
# 868
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 869
__suld_2d_i64_zero((long long *)(&tmp), surfObject, x, y); 
# 870
}  }  }  
# 871
(*retVal) = make_ulonglong1(tmp); 
# 872
} 
#endif
# 874 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 875
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 887
::exit(___);}
#if 0
# 875
{ 
# 876
float tmp; 
# 877
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 878
__suld_2d_i32_trap((int *)(&tmp), surfObject, x, y); 
# 879
} else { 
# 880
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 881
__suld_2d_i32_clamp((int *)(&tmp), surfObject, x, y); 
# 882
} else { 
# 883
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 884
__suld_2d_i32_zero((int *)(&tmp), surfObject, x, y); 
# 885
}  }  }  
# 886
(*retVal) = tmp; 
# 887
} 
#endif
# 889 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 890
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 902
::exit(___);}
#if 0
# 890
{ 
# 891
float tmp; 
# 892
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 893
__suld_2d_i32_trap((int *)(&tmp), surfObject, x, y); 
# 894
} else { 
# 895
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 896
__suld_2d_i32_clamp((int *)(&tmp), surfObject, x, y); 
# 897
} else { 
# 898
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 899
__suld_2d_i32_zero((int *)(&tmp), surfObject, x, y); 
# 900
}  }  }  
# 901
(*retVal) = make_float1(tmp); 
# 902
} 
#endif
# 910 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 911
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 923
::exit(___);}
#if 0
# 911
{ 
# 912
char2 tmp; 
# 913
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 914
__suld_2d_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y); 
# 915
} else { 
# 916
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 917
__suld_2d_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y); 
# 918
} else { 
# 919
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 920
__suld_2d_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y); 
# 921
}  }  }  
# 922
(*retVal) = tmp; 
# 923
} 
#endif
# 925 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 926
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 938
::exit(___);}
#if 0
# 926
{ 
# 927
uchar2 tmp; 
# 928
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 929
__suld_2d_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y); 
# 930
} else { 
# 931
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 932
__suld_2d_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y); 
# 933
} else { 
# 934
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 935
__suld_2d_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y); 
# 936
}  }  }  
# 937
(*retVal) = tmp; 
# 938
} 
#endif
# 940 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 941
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 953
::exit(___);}
#if 0
# 941
{ 
# 942
short2 tmp; 
# 943
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 944
__suld_2d_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y); 
# 945
} else { 
# 946
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 947
__suld_2d_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y); 
# 948
} else { 
# 949
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 950
__suld_2d_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y); 
# 951
}  }  }  
# 952
(*retVal) = tmp; 
# 953
} 
#endif
# 955 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 956
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 968
::exit(___);}
#if 0
# 956
{ 
# 957
ushort2 tmp; 
# 958
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 959
__suld_2d_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y); 
# 960
} else { 
# 961
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 962
__suld_2d_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y); 
# 963
} else { 
# 964
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 965
__suld_2d_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y); 
# 966
}  }  }  
# 967
(*retVal) = tmp; 
# 968
} 
#endif
# 970 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 971
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 983
::exit(___);}
#if 0
# 971
{ 
# 972
int2 tmp; 
# 973
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 974
__suld_2d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
# 975
} else { 
# 976
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 977
__suld_2d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
# 978
} else { 
# 979
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 980
__suld_2d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
# 981
}  }  }  
# 982
(*retVal) = tmp; 
# 983
} 
#endif
# 985 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 986
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 998
::exit(___);}
#if 0
# 986
{ 
# 987
uint2 tmp; 
# 988
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 989
__suld_2d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
# 990
} else { 
# 991
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 992
__suld_2d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
# 993
} else { 
# 994
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 995
__suld_2d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
# 996
}  }  }  
# 997
(*retVal) = tmp; 
# 998
} 
#endif
# 1000 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 1001
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1013
::exit(___);}
#if 0
# 1001
{ 
# 1002
longlong2 tmp; 
# 1003
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1004
__suld_2d_v2i64_trap((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x, y); 
# 1005
} else { 
# 1006
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1007
__suld_2d_v2i64_clamp((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x, y); 
# 1008
} else { 
# 1009
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1010
__suld_2d_v2i64_zero((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x, y); 
# 1011
}  }  }  
# 1012
(*retVal) = tmp; 
# 1013
} 
#endif
# 1015 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 1016
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1028
::exit(___);}
#if 0
# 1016
{ 
# 1017
ulonglong2 tmp; 
# 1018
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1019
__suld_2d_v2i64_trap((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x, y); 
# 1020
} else { 
# 1021
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1022
__suld_2d_v2i64_clamp((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x, y); 
# 1023
} else { 
# 1024
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1025
__suld_2d_v2i64_zero((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x, y); 
# 1026
}  }  }  
# 1027
(*retVal) = tmp; 
# 1028
} 
#endif
# 1030 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 1031
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1043
::exit(___);}
#if 0
# 1031
{ 
# 1032
float2 tmp; 
# 1033
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1034
__suld_2d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
# 1035
} else { 
# 1036
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1037
__suld_2d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
# 1038
} else { 
# 1039
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1040
__suld_2d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
# 1041
}  }  }  
# 1042
(*retVal) = tmp; 
# 1043
} 
#endif
# 1051 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 1052
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1064
::exit(___);}
#if 0
# 1052
{ 
# 1053
char4 tmp; 
# 1054
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1055
__suld_2d_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y); 
# 1056
} else { 
# 1057
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1058
__suld_2d_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y); 
# 1059
} else { 
# 1060
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1061
__suld_2d_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y); 
# 1062
}  }  }  
# 1063
(*retVal) = tmp; 
# 1064
} 
#endif
# 1066 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 1067
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1079
::exit(___);}
#if 0
# 1067
{ 
# 1068
uchar4 tmp; 
# 1069
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1070
__suld_2d_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y); 
# 1071
} else { 
# 1072
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1073
__suld_2d_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y); 
# 1074
} else { 
# 1075
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1076
__suld_2d_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y); 
# 1077
}  }  }  
# 1078
(*retVal) = tmp; 
# 1079
} 
#endif
# 1081 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 1082
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1094
::exit(___);}
#if 0
# 1082
{ 
# 1083
short4 tmp; 
# 1084
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1085
__suld_2d_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y); 
# 1086
} else { 
# 1087
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1088
__suld_2d_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y); 
# 1089
} else { 
# 1090
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1091
__suld_2d_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y); 
# 1092
}  }  }  
# 1093
(*retVal) = tmp; 
# 1094
} 
#endif
# 1096 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 1097
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1109
::exit(___);}
#if 0
# 1097
{ 
# 1098
ushort4 tmp; 
# 1099
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1100
__suld_2d_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y); 
# 1101
} else { 
# 1102
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1103
__suld_2d_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y); 
# 1104
} else { 
# 1105
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1106
__suld_2d_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y); 
# 1107
}  }  }  
# 1108
(*retVal) = tmp; 
# 1109
} 
#endif
# 1111 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 1112
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1124
::exit(___);}
#if 0
# 1112
{ 
# 1113
int4 tmp; 
# 1114
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1115
__suld_2d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
# 1116
} else { 
# 1117
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1118
__suld_2d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
# 1119
} else { 
# 1120
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1121
__suld_2d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
# 1122
}  }  }  
# 1123
(*retVal) = tmp; 
# 1124
} 
#endif
# 1126 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 1127
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1139
::exit(___);}
#if 0
# 1127
{ 
# 1128
uint4 tmp; 
# 1129
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1130
__suld_2d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
# 1131
} else { 
# 1132
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1133
__suld_2d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
# 1134
} else { 
# 1135
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1136
__suld_2d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
# 1137
}  }  }  
# 1138
(*retVal) = tmp; 
# 1139
} 
#endif
# 1141 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 1142
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1154
::exit(___);}
#if 0
# 1142
{ 
# 1143
float4 tmp; 
# 1144
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1145
__suld_2d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
# 1146
} else { 
# 1147
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1148
__suld_2d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
# 1149
} else { 
# 1150
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1151
__suld_2d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
# 1152
}  }  }  
# 1153
(*retVal) = tmp; 
# 1154
} 
#endif
# 1162 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1163
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1175
::exit(___);}
#if 0
# 1163
{ 
# 1164
char tmp; 
# 1165
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1166
__suld_3d_i8_trap((char *)(&tmp), surfObject, x, y, z); 
# 1167
} else { 
# 1168
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1169
__suld_3d_i8_clamp((char *)(&tmp), surfObject, x, y, z); 
# 1170
} else { 
# 1171
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1172
__suld_3d_i8_zero((char *)(&tmp), surfObject, x, y, z); 
# 1173
}  }  }  
# 1174
(*retVal) = tmp; 
# 1175
} 
#endif
# 1177 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1178
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1190
::exit(___);}
#if 0
# 1178
{ 
# 1179
signed char tmp; 
# 1180
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1181
__suld_3d_i8_trap((char *)(&tmp), surfObject, x, y, z); 
# 1182
} else { 
# 1183
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1184
__suld_3d_i8_clamp((char *)(&tmp), surfObject, x, y, z); 
# 1185
} else { 
# 1186
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1187
__suld_3d_i8_zero((char *)(&tmp), surfObject, x, y, z); 
# 1188
}  }  }  
# 1189
(*retVal) = tmp; 
# 1190
} 
#endif
# 1192 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1193
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1205
::exit(___);}
#if 0
# 1193
{ 
# 1194
char tmp; 
# 1195
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1196
__suld_3d_i8_trap((char *)(&tmp), surfObject, x, y, z); 
# 1197
} else { 
# 1198
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1199
__suld_3d_i8_clamp((char *)(&tmp), surfObject, x, y, z); 
# 1200
} else { 
# 1201
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1202
__suld_3d_i8_zero((char *)(&tmp), surfObject, x, y, z); 
# 1203
}  }  }  
# 1204
(*retVal) = make_char1(tmp); 
# 1205
} 
#endif
# 1207 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1208
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1220
::exit(___);}
#if 0
# 1208
{ 
# 1209
unsigned char tmp; 
# 1210
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1211
__suld_3d_i8_trap((char *)(&tmp), surfObject, x, y, z); 
# 1212
} else { 
# 1213
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1214
__suld_3d_i8_clamp((char *)(&tmp), surfObject, x, y, z); 
# 1215
} else { 
# 1216
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1217
__suld_3d_i8_zero((char *)(&tmp), surfObject, x, y, z); 
# 1218
}  }  }  
# 1219
(*retVal) = tmp; 
# 1220
} 
#endif
# 1222 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1223
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1235
::exit(___);}
#if 0
# 1223
{ 
# 1224
unsigned char tmp; 
# 1225
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1226
__suld_3d_i8_trap((char *)(&tmp), surfObject, x, y, z); 
# 1227
} else { 
# 1228
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1229
__suld_3d_i8_clamp((char *)(&tmp), surfObject, x, y, z); 
# 1230
} else { 
# 1231
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1232
__suld_3d_i8_zero((char *)(&tmp), surfObject, x, y, z); 
# 1233
}  }  }  
# 1234
(*retVal) = make_uchar1(tmp); 
# 1235
} 
#endif
# 1237 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1238
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1250
::exit(___);}
#if 0
# 1238
{ 
# 1239
short tmp; 
# 1240
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1241
__suld_3d_i16_trap((short *)(&tmp), surfObject, x, y, z); 
# 1242
} else { 
# 1243
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1244
__suld_3d_i16_clamp((short *)(&tmp), surfObject, x, y, z); 
# 1245
} else { 
# 1246
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1247
__suld_3d_i16_zero((short *)(&tmp), surfObject, x, y, z); 
# 1248
}  }  }  
# 1249
(*retVal) = tmp; 
# 1250
} 
#endif
# 1252 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1253
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1265
::exit(___);}
#if 0
# 1253
{ 
# 1254
short tmp; 
# 1255
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1256
__suld_3d_i16_trap((short *)(&tmp), surfObject, x, y, z); 
# 1257
} else { 
# 1258
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1259
__suld_3d_i16_clamp((short *)(&tmp), surfObject, x, y, z); 
# 1260
} else { 
# 1261
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1262
__suld_3d_i16_zero((short *)(&tmp), surfObject, x, y, z); 
# 1263
}  }  }  
# 1264
(*retVal) = make_short1(tmp); 
# 1265
} 
#endif
# 1267 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1268
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1280
::exit(___);}
#if 0
# 1268
{ 
# 1269
unsigned short tmp; 
# 1270
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1271
__suld_3d_i16_trap((short *)(&tmp), surfObject, x, y, z); 
# 1272
} else { 
# 1273
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1274
__suld_3d_i16_clamp((short *)(&tmp), surfObject, x, y, z); 
# 1275
} else { 
# 1276
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1277
__suld_3d_i16_zero((short *)(&tmp), surfObject, x, y, z); 
# 1278
}  }  }  
# 1279
(*retVal) = tmp; 
# 1280
} 
#endif
# 1282 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1283
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1295
::exit(___);}
#if 0
# 1283
{ 
# 1284
unsigned short tmp; 
# 1285
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1286
__suld_3d_i16_trap((short *)(&tmp), surfObject, x, y, z); 
# 1287
} else { 
# 1288
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1289
__suld_3d_i16_clamp((short *)(&tmp), surfObject, x, y, z); 
# 1290
} else { 
# 1291
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1292
__suld_3d_i16_zero((short *)(&tmp), surfObject, x, y, z); 
# 1293
}  }  }  
# 1294
(*retVal) = make_ushort1(tmp); 
# 1295
} 
#endif
# 1297 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1298
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1310
::exit(___);}
#if 0
# 1298
{ 
# 1299
int tmp; 
# 1300
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1301
__suld_3d_i32_trap((int *)(&tmp), surfObject, x, y, z); 
# 1302
} else { 
# 1303
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1304
__suld_3d_i32_clamp((int *)(&tmp), surfObject, x, y, z); 
# 1305
} else { 
# 1306
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1307
__suld_3d_i32_zero((int *)(&tmp), surfObject, x, y, z); 
# 1308
}  }  }  
# 1309
(*retVal) = tmp; 
# 1310
} 
#endif
# 1312 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1313
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1325
::exit(___);}
#if 0
# 1313
{ 
# 1314
int tmp; 
# 1315
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1316
__suld_3d_i32_trap((int *)(&tmp), surfObject, x, y, z); 
# 1317
} else { 
# 1318
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1319
__suld_3d_i32_clamp((int *)(&tmp), surfObject, x, y, z); 
# 1320
} else { 
# 1321
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1322
__suld_3d_i32_zero((int *)(&tmp), surfObject, x, y, z); 
# 1323
}  }  }  
# 1324
(*retVal) = make_int1(tmp); 
# 1325
} 
#endif
# 1327 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1328
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1340
::exit(___);}
#if 0
# 1328
{ 
# 1329
unsigned tmp; 
# 1330
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1331
__suld_3d_i32_trap((int *)(&tmp), surfObject, x, y, z); 
# 1332
} else { 
# 1333
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1334
__suld_3d_i32_clamp((int *)(&tmp), surfObject, x, y, z); 
# 1335
} else { 
# 1336
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1337
__suld_3d_i32_zero((int *)(&tmp), surfObject, x, y, z); 
# 1338
}  }  }  
# 1339
(*retVal) = tmp; 
# 1340
} 
#endif
# 1342 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1343
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1355
::exit(___);}
#if 0
# 1343
{ 
# 1344
unsigned tmp; 
# 1345
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1346
__suld_3d_i32_trap((int *)(&tmp), surfObject, x, y, z); 
# 1347
} else { 
# 1348
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1349
__suld_3d_i32_clamp((int *)(&tmp), surfObject, x, y, z); 
# 1350
} else { 
# 1351
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1352
__suld_3d_i32_zero((int *)(&tmp), surfObject, x, y, z); 
# 1353
}  }  }  
# 1354
(*retVal) = make_uint1(tmp); 
# 1355
} 
#endif
# 1357 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1358
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1370
::exit(___);}
#if 0
# 1358
{ 
# 1359
long long tmp; 
# 1360
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1361
__suld_3d_i64_trap((long long *)(&tmp), surfObject, x, y, z); 
# 1362
} else { 
# 1363
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1364
__suld_3d_i64_clamp((long long *)(&tmp), surfObject, x, y, z); 
# 1365
} else { 
# 1366
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1367
__suld_3d_i64_zero((long long *)(&tmp), surfObject, x, y, z); 
# 1368
}  }  }  
# 1369
(*retVal) = tmp; 
# 1370
} 
#endif
# 1372 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1373
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1385
::exit(___);}
#if 0
# 1373
{ 
# 1374
long long tmp; 
# 1375
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1376
__suld_3d_i64_trap((long long *)(&tmp), surfObject, x, y, z); 
# 1377
} else { 
# 1378
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1379
__suld_3d_i64_clamp((long long *)(&tmp), surfObject, x, y, z); 
# 1380
} else { 
# 1381
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1382
__suld_3d_i64_zero((long long *)(&tmp), surfObject, x, y, z); 
# 1383
}  }  }  
# 1384
(*retVal) = make_longlong1(tmp); 
# 1385
} 
#endif
# 1387 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1388
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1400
::exit(___);}
#if 0
# 1388
{ 
# 1389
unsigned long long tmp; 
# 1390
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1391
__suld_3d_i64_trap((long long *)(&tmp), surfObject, x, y, z); 
# 1392
} else { 
# 1393
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1394
__suld_3d_i64_clamp((long long *)(&tmp), surfObject, x, y, z); 
# 1395
} else { 
# 1396
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1397
__suld_3d_i64_zero((long long *)(&tmp), surfObject, x, y, z); 
# 1398
}  }  }  
# 1399
(*retVal) = tmp; 
# 1400
} 
#endif
# 1402 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1403
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1415
::exit(___);}
#if 0
# 1403
{ 
# 1404
unsigned long long tmp; 
# 1405
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1406
__suld_3d_i64_trap((long long *)(&tmp), surfObject, x, y, z); 
# 1407
} else { 
# 1408
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1409
__suld_3d_i64_clamp((long long *)(&tmp), surfObject, x, y, z); 
# 1410
} else { 
# 1411
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1412
__suld_3d_i64_zero((long long *)(&tmp), surfObject, x, y, z); 
# 1413
}  }  }  
# 1414
(*retVal) = make_ulonglong1(tmp); 
# 1415
} 
#endif
# 1417 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1418
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1430
::exit(___);}
#if 0
# 1418
{ 
# 1419
float tmp; 
# 1420
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1421
__suld_3d_i32_trap((int *)(&tmp), surfObject, x, y, z); 
# 1422
} else { 
# 1423
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1424
__suld_3d_i32_clamp((int *)(&tmp), surfObject, x, y, z); 
# 1425
} else { 
# 1426
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1427
__suld_3d_i32_zero((int *)(&tmp), surfObject, x, y, z); 
# 1428
}  }  }  
# 1429
(*retVal) = tmp; 
# 1430
} 
#endif
# 1432 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1433
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1445
::exit(___);}
#if 0
# 1433
{ 
# 1434
float tmp; 
# 1435
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1436
__suld_3d_i32_trap((int *)(&tmp), surfObject, x, y, z); 
# 1437
} else { 
# 1438
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1439
__suld_3d_i32_clamp((int *)(&tmp), surfObject, x, y, z); 
# 1440
} else { 
# 1441
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1442
__suld_3d_i32_zero((int *)(&tmp), surfObject, x, y, z); 
# 1443
}  }  }  
# 1444
(*retVal) = make_float1(tmp); 
# 1445
} 
#endif
# 1453 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1454
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1466
::exit(___);}
#if 0
# 1454
{ 
# 1455
char2 tmp; 
# 1456
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1457
__suld_3d_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y, z); 
# 1458
} else { 
# 1459
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1460
__suld_3d_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y, z); 
# 1461
} else { 
# 1462
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1463
__suld_3d_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y, z); 
# 1464
}  }  }  
# 1465
(*retVal) = tmp; 
# 1466
} 
#endif
# 1468 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1469
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1481
::exit(___);}
#if 0
# 1469
{ 
# 1470
uchar2 tmp; 
# 1471
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1472
__suld_3d_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y, z); 
# 1473
} else { 
# 1474
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1475
__suld_3d_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y, z); 
# 1476
} else { 
# 1477
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1478
__suld_3d_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y, z); 
# 1479
}  }  }  
# 1480
(*retVal) = tmp; 
# 1481
} 
#endif
# 1483 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1484
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1496
::exit(___);}
#if 0
# 1484
{ 
# 1485
short2 tmp; 
# 1486
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1487
__suld_3d_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y, z); 
# 1488
} else { 
# 1489
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1490
__suld_3d_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y, z); 
# 1491
} else { 
# 1492
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1493
__suld_3d_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y, z); 
# 1494
}  }  }  
# 1495
(*retVal) = tmp; 
# 1496
} 
#endif
# 1498 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1499
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1511
::exit(___);}
#if 0
# 1499
{ 
# 1500
ushort2 tmp; 
# 1501
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1502
__suld_3d_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y, z); 
# 1503
} else { 
# 1504
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1505
__suld_3d_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y, z); 
# 1506
} else { 
# 1507
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1508
__suld_3d_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y, z); 
# 1509
}  }  }  
# 1510
(*retVal) = tmp; 
# 1511
} 
#endif
# 1513 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1514
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1526
::exit(___);}
#if 0
# 1514
{ 
# 1515
int2 tmp; 
# 1516
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1517
__suld_3d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
# 1518
} else { 
# 1519
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1520
__suld_3d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
# 1521
} else { 
# 1522
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1523
__suld_3d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
# 1524
}  }  }  
# 1525
(*retVal) = tmp; 
# 1526
} 
#endif
# 1528 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1529
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1541
::exit(___);}
#if 0
# 1529
{ 
# 1530
uint2 tmp; 
# 1531
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1532
__suld_3d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
# 1533
} else { 
# 1534
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1535
__suld_3d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
# 1536
} else { 
# 1537
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1538
__suld_3d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
# 1539
}  }  }  
# 1540
(*retVal) = tmp; 
# 1541
} 
#endif
# 1543 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1544
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1556
::exit(___);}
#if 0
# 1544
{ 
# 1545
longlong2 tmp; 
# 1546
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1547
__suld_3d_v2i64_trap((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x, y, z); 
# 1548
} else { 
# 1549
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1550
__suld_3d_v2i64_clamp((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x, y, z); 
# 1551
} else { 
# 1552
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1553
__suld_3d_v2i64_zero((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x, y, z); 
# 1554
}  }  }  
# 1555
(*retVal) = tmp; 
# 1556
} 
#endif
# 1558 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1559
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1571
::exit(___);}
#if 0
# 1559
{ 
# 1560
ulonglong2 tmp; 
# 1561
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1562
__suld_3d_v2i64_trap((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x, y, z); 
# 1563
} else { 
# 1564
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1565
__suld_3d_v2i64_clamp((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x, y, z); 
# 1566
} else { 
# 1567
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1568
__suld_3d_v2i64_zero((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, x, y, z); 
# 1569
}  }  }  
# 1570
(*retVal) = tmp; 
# 1571
} 
#endif
# 1573 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1574
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1586
::exit(___);}
#if 0
# 1574
{ 
# 1575
float2 tmp; 
# 1576
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1577
__suld_3d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
# 1578
} else { 
# 1579
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1580
__suld_3d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
# 1581
} else { 
# 1582
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1583
__suld_3d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
# 1584
}  }  }  
# 1585
(*retVal) = tmp; 
# 1586
} 
#endif
# 1594 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1595
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1607
::exit(___);}
#if 0
# 1595
{ 
# 1596
char4 tmp; 
# 1597
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1598
__suld_3d_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y, z); 
# 1599
} else { 
# 1600
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1601
__suld_3d_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y, z); 
# 1602
} else { 
# 1603
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1604
__suld_3d_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y, z); 
# 1605
}  }  }  
# 1606
(*retVal) = tmp; 
# 1607
} 
#endif
# 1609 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1610
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1622
::exit(___);}
#if 0
# 1610
{ 
# 1611
uchar4 tmp; 
# 1612
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1613
__suld_3d_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y, z); 
# 1614
} else { 
# 1615
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1616
__suld_3d_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y, z); 
# 1617
} else { 
# 1618
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1619
__suld_3d_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y, z); 
# 1620
}  }  }  
# 1621
(*retVal) = tmp; 
# 1622
} 
#endif
# 1624 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1625
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1637
::exit(___);}
#if 0
# 1625
{ 
# 1626
short4 tmp; 
# 1627
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1628
__suld_3d_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y, z); 
# 1629
} else { 
# 1630
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1631
__suld_3d_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y, z); 
# 1632
} else { 
# 1633
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1634
__suld_3d_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y, z); 
# 1635
}  }  }  
# 1636
(*retVal) = tmp; 
# 1637
} 
#endif
# 1639 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1640
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1652
::exit(___);}
#if 0
# 1640
{ 
# 1641
ushort4 tmp; 
# 1642
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1643
__suld_3d_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y, z); 
# 1644
} else { 
# 1645
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1646
__suld_3d_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y, z); 
# 1647
} else { 
# 1648
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1649
__suld_3d_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y, z); 
# 1650
}  }  }  
# 1651
(*retVal) = tmp; 
# 1652
} 
#endif
# 1654 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1655
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1667
::exit(___);}
#if 0
# 1655
{ 
# 1656
int4 tmp; 
# 1657
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1658
__suld_3d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
# 1659
} else { 
# 1660
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1661
__suld_3d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
# 1662
} else { 
# 1663
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1664
__suld_3d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
# 1665
}  }  }  
# 1666
(*retVal) = tmp; 
# 1667
} 
#endif
# 1669 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1670
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1682
::exit(___);}
#if 0
# 1670
{ 
# 1671
uint4 tmp; 
# 1672
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1673
__suld_3d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
# 1674
} else { 
# 1675
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1676
__suld_3d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
# 1677
} else { 
# 1678
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1679
__suld_3d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
# 1680
}  }  }  
# 1681
(*retVal) = tmp; 
# 1682
} 
#endif
# 1684 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 1685
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1697
::exit(___);}
#if 0
# 1685
{ 
# 1686
float4 tmp; 
# 1687
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1688
__suld_3d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
# 1689
} else { 
# 1690
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1691
__suld_3d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
# 1692
} else { 
# 1693
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1694
__suld_3d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
# 1695
}  }  }  
# 1696
(*retVal) = tmp; 
# 1697
} 
#endif
# 1705 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1706
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1718
::exit(___);}
#if 0
# 1706
{ 
# 1707
char tmp; 
# 1708
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1709
__suld_1d_array_i8_trap((char *)(&tmp), surfObject, layer, x); 
# 1710
} else { 
# 1711
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1712
__suld_1d_array_i8_clamp((char *)(&tmp), surfObject, layer, x); 
# 1713
} else { 
# 1714
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1715
__suld_1d_array_i8_zero((char *)(&tmp), surfObject, layer, x); 
# 1716
}  }  }  
# 1717
(*retVal) = tmp; 
# 1718
} 
#endif
# 1720 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1721
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1733
::exit(___);}
#if 0
# 1721
{ 
# 1722
signed char tmp; 
# 1723
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1724
__suld_1d_array_i8_trap((char *)(&tmp), surfObject, layer, x); 
# 1725
} else { 
# 1726
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1727
__suld_1d_array_i8_clamp((char *)(&tmp), surfObject, layer, x); 
# 1728
} else { 
# 1729
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1730
__suld_1d_array_i8_zero((char *)(&tmp), surfObject, layer, x); 
# 1731
}  }  }  
# 1732
(*retVal) = tmp; 
# 1733
} 
#endif
# 1735 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1736
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1748
::exit(___);}
#if 0
# 1736
{ 
# 1737
char tmp; 
# 1738
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1739
__suld_1d_array_i8_trap((char *)(&tmp), surfObject, layer, x); 
# 1740
} else { 
# 1741
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1742
__suld_1d_array_i8_clamp((char *)(&tmp), surfObject, layer, x); 
# 1743
} else { 
# 1744
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1745
__suld_1d_array_i8_zero((char *)(&tmp), surfObject, layer, x); 
# 1746
}  }  }  
# 1747
(*retVal) = make_char1(tmp); 
# 1748
} 
#endif
# 1750 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1751
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1763
::exit(___);}
#if 0
# 1751
{ 
# 1752
unsigned char tmp; 
# 1753
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1754
__suld_1d_array_i8_trap((char *)(&tmp), surfObject, layer, x); 
# 1755
} else { 
# 1756
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1757
__suld_1d_array_i8_clamp((char *)(&tmp), surfObject, layer, x); 
# 1758
} else { 
# 1759
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1760
__suld_1d_array_i8_zero((char *)(&tmp), surfObject, layer, x); 
# 1761
}  }  }  
# 1762
(*retVal) = tmp; 
# 1763
} 
#endif
# 1765 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1766
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1778
::exit(___);}
#if 0
# 1766
{ 
# 1767
unsigned char tmp; 
# 1768
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1769
__suld_1d_array_i8_trap((char *)(&tmp), surfObject, layer, x); 
# 1770
} else { 
# 1771
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1772
__suld_1d_array_i8_clamp((char *)(&tmp), surfObject, layer, x); 
# 1773
} else { 
# 1774
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1775
__suld_1d_array_i8_zero((char *)(&tmp), surfObject, layer, x); 
# 1776
}  }  }  
# 1777
(*retVal) = make_uchar1(tmp); 
# 1778
} 
#endif
# 1780 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1781
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1793
::exit(___);}
#if 0
# 1781
{ 
# 1782
short tmp; 
# 1783
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1784
__suld_1d_array_i16_trap((short *)(&tmp), surfObject, layer, x); 
# 1785
} else { 
# 1786
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1787
__suld_1d_array_i16_clamp((short *)(&tmp), surfObject, layer, x); 
# 1788
} else { 
# 1789
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1790
__suld_1d_array_i16_zero((short *)(&tmp), surfObject, layer, x); 
# 1791
}  }  }  
# 1792
(*retVal) = tmp; 
# 1793
} 
#endif
# 1795 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1796
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1808
::exit(___);}
#if 0
# 1796
{ 
# 1797
short tmp; 
# 1798
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1799
__suld_1d_array_i16_trap((short *)(&tmp), surfObject, layer, x); 
# 1800
} else { 
# 1801
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1802
__suld_1d_array_i16_clamp((short *)(&tmp), surfObject, layer, x); 
# 1803
} else { 
# 1804
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1805
__suld_1d_array_i16_zero((short *)(&tmp), surfObject, layer, x); 
# 1806
}  }  }  
# 1807
(*retVal) = make_short1(tmp); 
# 1808
} 
#endif
# 1810 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1811
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1823
::exit(___);}
#if 0
# 1811
{ 
# 1812
unsigned short tmp; 
# 1813
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1814
__suld_1d_array_i16_trap((short *)(&tmp), surfObject, layer, x); 
# 1815
} else { 
# 1816
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1817
__suld_1d_array_i16_clamp((short *)(&tmp), surfObject, layer, x); 
# 1818
} else { 
# 1819
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1820
__suld_1d_array_i16_zero((short *)(&tmp), surfObject, layer, x); 
# 1821
}  }  }  
# 1822
(*retVal) = tmp; 
# 1823
} 
#endif
# 1825 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1826
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1838
::exit(___);}
#if 0
# 1826
{ 
# 1827
unsigned short tmp; 
# 1828
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1829
__suld_1d_array_i16_trap((short *)(&tmp), surfObject, layer, x); 
# 1830
} else { 
# 1831
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1832
__suld_1d_array_i16_clamp((short *)(&tmp), surfObject, layer, x); 
# 1833
} else { 
# 1834
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1835
__suld_1d_array_i16_zero((short *)(&tmp), surfObject, layer, x); 
# 1836
}  }  }  
# 1837
(*retVal) = make_ushort1(tmp); 
# 1838
} 
#endif
# 1840 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1841
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1853
::exit(___);}
#if 0
# 1841
{ 
# 1842
int tmp; 
# 1843
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1844
__suld_1d_array_i32_trap((int *)(&tmp), surfObject, layer, x); 
# 1845
} else { 
# 1846
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1847
__suld_1d_array_i32_clamp((int *)(&tmp), surfObject, layer, x); 
# 1848
} else { 
# 1849
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1850
__suld_1d_array_i32_zero((int *)(&tmp), surfObject, layer, x); 
# 1851
}  }  }  
# 1852
(*retVal) = tmp; 
# 1853
} 
#endif
# 1855 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1856
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1868
::exit(___);}
#if 0
# 1856
{ 
# 1857
int tmp; 
# 1858
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1859
__suld_1d_array_i32_trap((int *)(&tmp), surfObject, layer, x); 
# 1860
} else { 
# 1861
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1862
__suld_1d_array_i32_clamp((int *)(&tmp), surfObject, layer, x); 
# 1863
} else { 
# 1864
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1865
__suld_1d_array_i32_zero((int *)(&tmp), surfObject, layer, x); 
# 1866
}  }  }  
# 1867
(*retVal) = make_int1(tmp); 
# 1868
} 
#endif
# 1870 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1871
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1883
::exit(___);}
#if 0
# 1871
{ 
# 1872
unsigned tmp; 
# 1873
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1874
__suld_1d_array_i32_trap((int *)(&tmp), surfObject, layer, x); 
# 1875
} else { 
# 1876
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1877
__suld_1d_array_i32_clamp((int *)(&tmp), surfObject, layer, x); 
# 1878
} else { 
# 1879
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1880
__suld_1d_array_i32_zero((int *)(&tmp), surfObject, layer, x); 
# 1881
}  }  }  
# 1882
(*retVal) = tmp; 
# 1883
} 
#endif
# 1885 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1886
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1898
::exit(___);}
#if 0
# 1886
{ 
# 1887
unsigned tmp; 
# 1888
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1889
__suld_1d_array_i32_trap((int *)(&tmp), surfObject, layer, x); 
# 1890
} else { 
# 1891
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1892
__suld_1d_array_i32_clamp((int *)(&tmp), surfObject, layer, x); 
# 1893
} else { 
# 1894
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1895
__suld_1d_array_i32_zero((int *)(&tmp), surfObject, layer, x); 
# 1896
}  }  }  
# 1897
(*retVal) = make_uint1(tmp); 
# 1898
} 
#endif
# 1900 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1901
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1913
::exit(___);}
#if 0
# 1901
{ 
# 1902
long long tmp; 
# 1903
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1904
__suld_1d_array_i64_trap((long long *)(&tmp), surfObject, layer, x); 
# 1905
} else { 
# 1906
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1907
__suld_1d_array_i64_clamp((long long *)(&tmp), surfObject, layer, x); 
# 1908
} else { 
# 1909
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1910
__suld_1d_array_i64_zero((long long *)(&tmp), surfObject, layer, x); 
# 1911
}  }  }  
# 1912
(*retVal) = tmp; 
# 1913
} 
#endif
# 1915 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1916
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1928
::exit(___);}
#if 0
# 1916
{ 
# 1917
long long tmp; 
# 1918
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1919
__suld_1d_array_i64_trap((long long *)(&tmp), surfObject, layer, x); 
# 1920
} else { 
# 1921
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1922
__suld_1d_array_i64_clamp((long long *)(&tmp), surfObject, layer, x); 
# 1923
} else { 
# 1924
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1925
__suld_1d_array_i64_zero((long long *)(&tmp), surfObject, layer, x); 
# 1926
}  }  }  
# 1927
(*retVal) = make_longlong1(tmp); 
# 1928
} 
#endif
# 1930 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1931
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1943
::exit(___);}
#if 0
# 1931
{ 
# 1932
unsigned long long tmp; 
# 1933
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1934
__suld_1d_array_i64_trap((long long *)(&tmp), surfObject, layer, x); 
# 1935
} else { 
# 1936
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1937
__suld_1d_array_i64_clamp((long long *)(&tmp), surfObject, layer, x); 
# 1938
} else { 
# 1939
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1940
__suld_1d_array_i64_zero((long long *)(&tmp), surfObject, layer, x); 
# 1941
}  }  }  
# 1942
(*retVal) = tmp; 
# 1943
} 
#endif
# 1945 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1946
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1958
::exit(___);}
#if 0
# 1946
{ 
# 1947
unsigned long long tmp; 
# 1948
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1949
__suld_1d_array_i64_trap((long long *)(&tmp), surfObject, layer, x); 
# 1950
} else { 
# 1951
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1952
__suld_1d_array_i64_clamp((long long *)(&tmp), surfObject, layer, x); 
# 1953
} else { 
# 1954
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1955
__suld_1d_array_i64_zero((long long *)(&tmp), surfObject, layer, x); 
# 1956
}  }  }  
# 1957
(*retVal) = make_ulonglong1(tmp); 
# 1958
} 
#endif
# 1960 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1961
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1973
::exit(___);}
#if 0
# 1961
{ 
# 1962
float tmp; 
# 1963
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1964
__suld_1d_array_i32_trap((int *)(&tmp), surfObject, layer, x); 
# 1965
} else { 
# 1966
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1967
__suld_1d_array_i32_clamp((int *)(&tmp), surfObject, layer, x); 
# 1968
} else { 
# 1969
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1970
__suld_1d_array_i32_zero((int *)(&tmp), surfObject, layer, x); 
# 1971
}  }  }  
# 1972
(*retVal) = tmp; 
# 1973
} 
#endif
# 1975 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1976
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1988
::exit(___);}
#if 0
# 1976
{ 
# 1977
float tmp; 
# 1978
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1979
__suld_1d_array_i32_trap((int *)(&tmp), surfObject, layer, x); 
# 1980
} else { 
# 1981
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1982
__suld_1d_array_i32_clamp((int *)(&tmp), surfObject, layer, x); 
# 1983
} else { 
# 1984
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1985
__suld_1d_array_i32_zero((int *)(&tmp), surfObject, layer, x); 
# 1986
}  }  }  
# 1987
(*retVal) = make_float1(tmp); 
# 1988
} 
#endif
# 1996 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 1997
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2009
::exit(___);}
#if 0
# 1997
{ 
# 1998
char2 tmp; 
# 1999
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2000
__suld_1d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x); 
# 2001
} else { 
# 2002
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2003
__suld_1d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x); 
# 2004
} else { 
# 2005
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2006
__suld_1d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x); 
# 2007
}  }  }  
# 2008
(*retVal) = tmp; 
# 2009
} 
#endif
# 2011 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2012
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2024
::exit(___);}
#if 0
# 2012
{ 
# 2013
uchar2 tmp; 
# 2014
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2015
__suld_1d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x); 
# 2016
} else { 
# 2017
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2018
__suld_1d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x); 
# 2019
} else { 
# 2020
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2021
__suld_1d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x); 
# 2022
}  }  }  
# 2023
(*retVal) = tmp; 
# 2024
} 
#endif
# 2026 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2027
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2039
::exit(___);}
#if 0
# 2027
{ 
# 2028
short2 tmp; 
# 2029
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2030
__suld_1d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x); 
# 2031
} else { 
# 2032
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2033
__suld_1d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x); 
# 2034
} else { 
# 2035
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2036
__suld_1d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x); 
# 2037
}  }  }  
# 2038
(*retVal) = tmp; 
# 2039
} 
#endif
# 2041 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2042
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2054
::exit(___);}
#if 0
# 2042
{ 
# 2043
ushort2 tmp; 
# 2044
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2045
__suld_1d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x); 
# 2046
} else { 
# 2047
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2048
__suld_1d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x); 
# 2049
} else { 
# 2050
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2051
__suld_1d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x); 
# 2052
}  }  }  
# 2053
(*retVal) = tmp; 
# 2054
} 
#endif
# 2056 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2057
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2069
::exit(___);}
#if 0
# 2057
{ 
# 2058
int2 tmp; 
# 2059
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2060
__suld_1d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
# 2061
} else { 
# 2062
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2063
__suld_1d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
# 2064
} else { 
# 2065
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2066
__suld_1d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
# 2067
}  }  }  
# 2068
(*retVal) = tmp; 
# 2069
} 
#endif
# 2071 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2072
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2084
::exit(___);}
#if 0
# 2072
{ 
# 2073
uint2 tmp; 
# 2074
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2075
__suld_1d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
# 2076
} else { 
# 2077
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2078
__suld_1d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
# 2079
} else { 
# 2080
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2081
__suld_1d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
# 2082
}  }  }  
# 2083
(*retVal) = tmp; 
# 2084
} 
#endif
# 2086 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2087
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2099
::exit(___);}
#if 0
# 2087
{ 
# 2088
longlong2 tmp; 
# 2089
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2090
__suld_1d_array_v2i64_trap((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layer, x); 
# 2091
} else { 
# 2092
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2093
__suld_1d_array_v2i64_clamp((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layer, x); 
# 2094
} else { 
# 2095
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2096
__suld_1d_array_v2i64_zero((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layer, x); 
# 2097
}  }  }  
# 2098
(*retVal) = tmp; 
# 2099
} 
#endif
# 2101 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2102
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2114
::exit(___);}
#if 0
# 2102
{ 
# 2103
ulonglong2 tmp; 
# 2104
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2105
__suld_1d_array_v2i64_trap((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layer, x); 
# 2106
} else { 
# 2107
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2108
__suld_1d_array_v2i64_clamp((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layer, x); 
# 2109
} else { 
# 2110
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2111
__suld_1d_array_v2i64_zero((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layer, x); 
# 2112
}  }  }  
# 2113
(*retVal) = tmp; 
# 2114
} 
#endif
# 2116 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2117
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2129
::exit(___);}
#if 0
# 2117
{ 
# 2118
float2 tmp; 
# 2119
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2120
__suld_1d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
# 2121
} else { 
# 2122
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2123
__suld_1d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
# 2124
} else { 
# 2125
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2126
__suld_1d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
# 2127
}  }  }  
# 2128
(*retVal) = tmp; 
# 2129
} 
#endif
# 2137 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2138
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2150
::exit(___);}
#if 0
# 2138
{ 
# 2139
char4 tmp; 
# 2140
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2141
__suld_1d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x); 
# 2142
} else { 
# 2143
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2144
__suld_1d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x); 
# 2145
} else { 
# 2146
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2147
__suld_1d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x); 
# 2148
}  }  }  
# 2149
(*retVal) = tmp; 
# 2150
} 
#endif
# 2152 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2153
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2165
::exit(___);}
#if 0
# 2153
{ 
# 2154
uchar4 tmp; 
# 2155
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2156
__suld_1d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x); 
# 2157
} else { 
# 2158
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2159
__suld_1d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x); 
# 2160
} else { 
# 2161
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2162
__suld_1d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x); 
# 2163
}  }  }  
# 2164
(*retVal) = tmp; 
# 2165
} 
#endif
# 2167 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2168
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2180
::exit(___);}
#if 0
# 2168
{ 
# 2169
short4 tmp; 
# 2170
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2171
__suld_1d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x); 
# 2172
} else { 
# 2173
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2174
__suld_1d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x); 
# 2175
} else { 
# 2176
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2177
__suld_1d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x); 
# 2178
}  }  }  
# 2179
(*retVal) = tmp; 
# 2180
} 
#endif
# 2182 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2183
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2195
::exit(___);}
#if 0
# 2183
{ 
# 2184
ushort4 tmp; 
# 2185
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2186
__suld_1d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x); 
# 2187
} else { 
# 2188
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2189
__suld_1d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x); 
# 2190
} else { 
# 2191
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2192
__suld_1d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x); 
# 2193
}  }  }  
# 2194
(*retVal) = tmp; 
# 2195
} 
#endif
# 2197 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2198
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2210
::exit(___);}
#if 0
# 2198
{ 
# 2199
int4 tmp; 
# 2200
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2201
__suld_1d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
# 2202
} else { 
# 2203
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2204
__suld_1d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
# 2205
} else { 
# 2206
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2207
__suld_1d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
# 2208
}  }  }  
# 2209
(*retVal) = tmp; 
# 2210
} 
#endif
# 2212 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2213
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2225
::exit(___);}
#if 0
# 2213
{ 
# 2214
uint4 tmp; 
# 2215
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2216
__suld_1d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
# 2217
} else { 
# 2218
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2219
__suld_1d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
# 2220
} else { 
# 2221
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2222
__suld_1d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
# 2223
}  }  }  
# 2224
(*retVal) = tmp; 
# 2225
} 
#endif
# 2227 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2228
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2240
::exit(___);}
#if 0
# 2228
{ 
# 2229
float4 tmp; 
# 2230
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2231
__suld_1d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
# 2232
} else { 
# 2233
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2234
__suld_1d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
# 2235
} else { 
# 2236
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2237
__suld_1d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
# 2238
}  }  }  
# 2239
(*retVal) = tmp; 
# 2240
} 
#endif
# 2248 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2249
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2261
::exit(___);}
#if 0
# 2249
{ 
# 2250
char tmp; 
# 2251
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2252
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layer, x, y); 
# 2253
} else { 
# 2254
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2255
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layer, x, y); 
# 2256
} else { 
# 2257
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2258
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layer, x, y); 
# 2259
}  }  }  
# 2260
(*retVal) = tmp; 
# 2261
} 
#endif
# 2263 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2264
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2276
::exit(___);}
#if 0
# 2264
{ 
# 2265
signed char tmp; 
# 2266
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2267
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layer, x, y); 
# 2268
} else { 
# 2269
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2270
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layer, x, y); 
# 2271
} else { 
# 2272
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2273
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layer, x, y); 
# 2274
}  }  }  
# 2275
(*retVal) = tmp; 
# 2276
} 
#endif
# 2278 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2279
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2291
::exit(___);}
#if 0
# 2279
{ 
# 2280
char tmp; 
# 2281
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2282
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layer, x, y); 
# 2283
} else { 
# 2284
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2285
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layer, x, y); 
# 2286
} else { 
# 2287
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2288
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layer, x, y); 
# 2289
}  }  }  
# 2290
(*retVal) = make_char1(tmp); 
# 2291
} 
#endif
# 2293 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2294
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2306
::exit(___);}
#if 0
# 2294
{ 
# 2295
unsigned char tmp; 
# 2296
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2297
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layer, x, y); 
# 2298
} else { 
# 2299
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2300
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layer, x, y); 
# 2301
} else { 
# 2302
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2303
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layer, x, y); 
# 2304
}  }  }  
# 2305
(*retVal) = tmp; 
# 2306
} 
#endif
# 2308 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2309
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2321
::exit(___);}
#if 0
# 2309
{ 
# 2310
unsigned char tmp; 
# 2311
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2312
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layer, x, y); 
# 2313
} else { 
# 2314
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2315
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layer, x, y); 
# 2316
} else { 
# 2317
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2318
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layer, x, y); 
# 2319
}  }  }  
# 2320
(*retVal) = make_uchar1(tmp); 
# 2321
} 
#endif
# 2323 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2324
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2336
::exit(___);}
#if 0
# 2324
{ 
# 2325
short tmp; 
# 2326
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2327
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layer, x, y); 
# 2328
} else { 
# 2329
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2330
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layer, x, y); 
# 2331
} else { 
# 2332
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2333
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layer, x, y); 
# 2334
}  }  }  
# 2335
(*retVal) = tmp; 
# 2336
} 
#endif
# 2338 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2339
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2351
::exit(___);}
#if 0
# 2339
{ 
# 2340
short tmp; 
# 2341
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2342
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layer, x, y); 
# 2343
} else { 
# 2344
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2345
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layer, x, y); 
# 2346
} else { 
# 2347
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2348
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layer, x, y); 
# 2349
}  }  }  
# 2350
(*retVal) = make_short1(tmp); 
# 2351
} 
#endif
# 2353 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2354
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2366
::exit(___);}
#if 0
# 2354
{ 
# 2355
unsigned short tmp; 
# 2356
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2357
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layer, x, y); 
# 2358
} else { 
# 2359
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2360
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layer, x, y); 
# 2361
} else { 
# 2362
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2363
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layer, x, y); 
# 2364
}  }  }  
# 2365
(*retVal) = tmp; 
# 2366
} 
#endif
# 2368 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2369
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2381
::exit(___);}
#if 0
# 2369
{ 
# 2370
unsigned short tmp; 
# 2371
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2372
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layer, x, y); 
# 2373
} else { 
# 2374
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2375
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layer, x, y); 
# 2376
} else { 
# 2377
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2378
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layer, x, y); 
# 2379
}  }  }  
# 2380
(*retVal) = make_ushort1(tmp); 
# 2381
} 
#endif
# 2383 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2384
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2396
::exit(___);}
#if 0
# 2384
{ 
# 2385
int tmp; 
# 2386
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2387
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layer, x, y); 
# 2388
} else { 
# 2389
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2390
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layer, x, y); 
# 2391
} else { 
# 2392
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2393
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layer, x, y); 
# 2394
}  }  }  
# 2395
(*retVal) = tmp; 
# 2396
} 
#endif
# 2398 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2399
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2411
::exit(___);}
#if 0
# 2399
{ 
# 2400
int tmp; 
# 2401
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2402
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layer, x, y); 
# 2403
} else { 
# 2404
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2405
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layer, x, y); 
# 2406
} else { 
# 2407
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2408
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layer, x, y); 
# 2409
}  }  }  
# 2410
(*retVal) = make_int1(tmp); 
# 2411
} 
#endif
# 2413 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2414
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2426
::exit(___);}
#if 0
# 2414
{ 
# 2415
unsigned tmp; 
# 2416
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2417
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layer, x, y); 
# 2418
} else { 
# 2419
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2420
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layer, x, y); 
# 2421
} else { 
# 2422
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2423
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layer, x, y); 
# 2424
}  }  }  
# 2425
(*retVal) = tmp; 
# 2426
} 
#endif
# 2428 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2429
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2441
::exit(___);}
#if 0
# 2429
{ 
# 2430
unsigned tmp; 
# 2431
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2432
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layer, x, y); 
# 2433
} else { 
# 2434
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2435
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layer, x, y); 
# 2436
} else { 
# 2437
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2438
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layer, x, y); 
# 2439
}  }  }  
# 2440
(*retVal) = make_uint1(tmp); 
# 2441
} 
#endif
# 2443 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2444
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2456
::exit(___);}
#if 0
# 2444
{ 
# 2445
long long tmp; 
# 2446
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2447
__suld_2d_array_i64_trap((long long *)(&tmp), surfObject, layer, x, y); 
# 2448
} else { 
# 2449
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2450
__suld_2d_array_i64_clamp((long long *)(&tmp), surfObject, layer, x, y); 
# 2451
} else { 
# 2452
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2453
__suld_2d_array_i64_zero((long long *)(&tmp), surfObject, layer, x, y); 
# 2454
}  }  }  
# 2455
(*retVal) = tmp; 
# 2456
} 
#endif
# 2458 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2459
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2471
::exit(___);}
#if 0
# 2459
{ 
# 2460
long long tmp; 
# 2461
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2462
__suld_2d_array_i64_trap((long long *)(&tmp), surfObject, layer, x, y); 
# 2463
} else { 
# 2464
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2465
__suld_2d_array_i64_clamp((long long *)(&tmp), surfObject, layer, x, y); 
# 2466
} else { 
# 2467
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2468
__suld_2d_array_i64_zero((long long *)(&tmp), surfObject, layer, x, y); 
# 2469
}  }  }  
# 2470
(*retVal) = make_longlong1(tmp); 
# 2471
} 
#endif
# 2473 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2474
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2486
::exit(___);}
#if 0
# 2474
{ 
# 2475
unsigned long long tmp; 
# 2476
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2477
__suld_2d_array_i64_trap((long long *)(&tmp), surfObject, layer, x, y); 
# 2478
} else { 
# 2479
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2480
__suld_2d_array_i64_clamp((long long *)(&tmp), surfObject, layer, x, y); 
# 2481
} else { 
# 2482
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2483
__suld_2d_array_i64_zero((long long *)(&tmp), surfObject, layer, x, y); 
# 2484
}  }  }  
# 2485
(*retVal) = tmp; 
# 2486
} 
#endif
# 2488 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2489
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2501
::exit(___);}
#if 0
# 2489
{ 
# 2490
unsigned long long tmp; 
# 2491
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2492
__suld_2d_array_i64_trap((long long *)(&tmp), surfObject, layer, x, y); 
# 2493
} else { 
# 2494
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2495
__suld_2d_array_i64_clamp((long long *)(&tmp), surfObject, layer, x, y); 
# 2496
} else { 
# 2497
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2498
__suld_2d_array_i64_zero((long long *)(&tmp), surfObject, layer, x, y); 
# 2499
}  }  }  
# 2500
(*retVal) = make_ulonglong1(tmp); 
# 2501
} 
#endif
# 2503 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2504
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2516
::exit(___);}
#if 0
# 2504
{ 
# 2505
float tmp; 
# 2506
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2507
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layer, x, y); 
# 2508
} else { 
# 2509
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2510
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layer, x, y); 
# 2511
} else { 
# 2512
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2513
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layer, x, y); 
# 2514
}  }  }  
# 2515
(*retVal) = tmp; 
# 2516
} 
#endif
# 2518 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2519
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2531
::exit(___);}
#if 0
# 2519
{ 
# 2520
float tmp; 
# 2521
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2522
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layer, x, y); 
# 2523
} else { 
# 2524
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2525
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layer, x, y); 
# 2526
} else { 
# 2527
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2528
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layer, x, y); 
# 2529
}  }  }  
# 2530
(*retVal) = make_float1(tmp); 
# 2531
} 
#endif
# 2539 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2540
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2552
::exit(___);}
#if 0
# 2540
{ 
# 2541
char2 tmp; 
# 2542
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2543
__suld_2d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x, y); 
# 2544
} else { 
# 2545
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2546
__suld_2d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x, y); 
# 2547
} else { 
# 2548
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2549
__suld_2d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x, y); 
# 2550
}  }  }  
# 2551
(*retVal) = tmp; 
# 2552
} 
#endif
# 2554 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2555
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2567
::exit(___);}
#if 0
# 2555
{ 
# 2556
uchar2 tmp; 
# 2557
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2558
__suld_2d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x, y); 
# 2559
} else { 
# 2560
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2561
__suld_2d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x, y); 
# 2562
} else { 
# 2563
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2564
__suld_2d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x, y); 
# 2565
}  }  }  
# 2566
(*retVal) = tmp; 
# 2567
} 
#endif
# 2569 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2570
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2582
::exit(___);}
#if 0
# 2570
{ 
# 2571
short2 tmp; 
# 2572
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2573
__suld_2d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x, y); 
# 2574
} else { 
# 2575
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2576
__suld_2d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x, y); 
# 2577
} else { 
# 2578
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2579
__suld_2d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x, y); 
# 2580
}  }  }  
# 2581
(*retVal) = tmp; 
# 2582
} 
#endif
# 2584 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2585
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2597
::exit(___);}
#if 0
# 2585
{ 
# 2586
ushort2 tmp; 
# 2587
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2588
__suld_2d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x, y); 
# 2589
} else { 
# 2590
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2591
__suld_2d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x, y); 
# 2592
} else { 
# 2593
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2594
__suld_2d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x, y); 
# 2595
}  }  }  
# 2596
(*retVal) = tmp; 
# 2597
} 
#endif
# 2599 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2600
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2612
::exit(___);}
#if 0
# 2600
{ 
# 2601
int2 tmp; 
# 2602
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2603
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
# 2604
} else { 
# 2605
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2606
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
# 2607
} else { 
# 2608
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2609
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
# 2610
}  }  }  
# 2611
(*retVal) = tmp; 
# 2612
} 
#endif
# 2614 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2615
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2627
::exit(___);}
#if 0
# 2615
{ 
# 2616
uint2 tmp; 
# 2617
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2618
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
# 2619
} else { 
# 2620
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2621
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
# 2622
} else { 
# 2623
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2624
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
# 2625
}  }  }  
# 2626
(*retVal) = tmp; 
# 2627
} 
#endif
# 2629 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2630
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2642
::exit(___);}
#if 0
# 2630
{ 
# 2631
longlong2 tmp; 
# 2632
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2633
__suld_2d_array_v2i64_trap((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layer, x, y); 
# 2634
} else { 
# 2635
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2636
__suld_2d_array_v2i64_clamp((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layer, x, y); 
# 2637
} else { 
# 2638
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2639
__suld_2d_array_v2i64_zero((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layer, x, y); 
# 2640
}  }  }  
# 2641
(*retVal) = tmp; 
# 2642
} 
#endif
# 2644 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2645
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2657
::exit(___);}
#if 0
# 2645
{ 
# 2646
ulonglong2 tmp; 
# 2647
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2648
__suld_2d_array_v2i64_trap((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layer, x, y); 
# 2649
} else { 
# 2650
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2651
__suld_2d_array_v2i64_clamp((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layer, x, y); 
# 2652
} else { 
# 2653
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2654
__suld_2d_array_v2i64_zero((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layer, x, y); 
# 2655
}  }  }  
# 2656
(*retVal) = tmp; 
# 2657
} 
#endif
# 2659 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2660
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2672
::exit(___);}
#if 0
# 2660
{ 
# 2661
float2 tmp; 
# 2662
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2663
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
# 2664
} else { 
# 2665
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2666
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
# 2667
} else { 
# 2668
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2669
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
# 2670
}  }  }  
# 2671
(*retVal) = tmp; 
# 2672
} 
#endif
# 2680 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2681
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2693
::exit(___);}
#if 0
# 2681
{ 
# 2682
char4 tmp; 
# 2683
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2684
__suld_2d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x, y); 
# 2685
} else { 
# 2686
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2687
__suld_2d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x, y); 
# 2688
} else { 
# 2689
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2690
__suld_2d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x, y); 
# 2691
}  }  }  
# 2692
(*retVal) = tmp; 
# 2693
} 
#endif
# 2695 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2696
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2708
::exit(___);}
#if 0
# 2696
{ 
# 2697
uchar4 tmp; 
# 2698
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2699
__suld_2d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x, y); 
# 2700
} else { 
# 2701
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2702
__suld_2d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x, y); 
# 2703
} else { 
# 2704
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2705
__suld_2d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x, y); 
# 2706
}  }  }  
# 2707
(*retVal) = tmp; 
# 2708
} 
#endif
# 2710 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2711
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2723
::exit(___);}
#if 0
# 2711
{ 
# 2712
short4 tmp; 
# 2713
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2714
__suld_2d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x, y); 
# 2715
} else { 
# 2716
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2717
__suld_2d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x, y); 
# 2718
} else { 
# 2719
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2720
__suld_2d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x, y); 
# 2721
}  }  }  
# 2722
(*retVal) = tmp; 
# 2723
} 
#endif
# 2725 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2726
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2738
::exit(___);}
#if 0
# 2726
{ 
# 2727
ushort4 tmp; 
# 2728
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2729
__suld_2d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x, y); 
# 2730
} else { 
# 2731
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2732
__suld_2d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x, y); 
# 2733
} else { 
# 2734
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2735
__suld_2d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x, y); 
# 2736
}  }  }  
# 2737
(*retVal) = tmp; 
# 2738
} 
#endif
# 2740 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2741
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2753
::exit(___);}
#if 0
# 2741
{ 
# 2742
int4 tmp; 
# 2743
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2744
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
# 2745
} else { 
# 2746
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2747
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
# 2748
} else { 
# 2749
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2750
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
# 2751
}  }  }  
# 2752
(*retVal) = tmp; 
# 2753
} 
#endif
# 2755 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2756
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2768
::exit(___);}
#if 0
# 2756
{ 
# 2757
uint4 tmp; 
# 2758
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2759
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
# 2760
} else { 
# 2761
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2762
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
# 2763
} else { 
# 2764
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2765
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
# 2766
}  }  }  
# 2767
(*retVal) = tmp; 
# 2768
} 
#endif
# 2770 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 2771
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2783
::exit(___);}
#if 0
# 2771
{ 
# 2772
float4 tmp; 
# 2773
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2774
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
# 2775
} else { 
# 2776
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2777
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
# 2778
} else { 
# 2779
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2780
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
# 2781
}  }  }  
# 2782
(*retVal) = tmp; 
# 2783
} 
#endif
# 2791 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 2792
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2804
::exit(___);}
#if 0
# 2792
{ 
# 2793
char tmp; 
# 2794
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2795
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, face, x, y); 
# 2796
} else { 
# 2797
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2798
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, face, x, y); 
# 2799
} else { 
# 2800
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2801
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, face, x, y); 
# 2802
}  }  }  
# 2803
(*retVal) = tmp; 
# 2804
} 
#endif
# 2806 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 2807
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2819
::exit(___);}
#if 0
# 2807
{ 
# 2808
signed char tmp; 
# 2809
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2810
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, face, x, y); 
# 2811
} else { 
# 2812
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2813
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, face, x, y); 
# 2814
} else { 
# 2815
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2816
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, face, x, y); 
# 2817
}  }  }  
# 2818
(*retVal) = tmp; 
# 2819
} 
#endif
# 2821 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 2822
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2834
::exit(___);}
#if 0
# 2822
{ 
# 2823
char tmp; 
# 2824
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2825
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, face, x, y); 
# 2826
} else { 
# 2827
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2828
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, face, x, y); 
# 2829
} else { 
# 2830
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2831
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, face, x, y); 
# 2832
}  }  }  
# 2833
(*retVal) = make_char1(tmp); 
# 2834
} 
#endif
# 2836 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 2837
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2849
::exit(___);}
#if 0
# 2837
{ 
# 2838
unsigned char tmp; 
# 2839
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2840
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, face, x, y); 
# 2841
} else { 
# 2842
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2843
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, face, x, y); 
# 2844
} else { 
# 2845
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2846
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, face, x, y); 
# 2847
}  }  }  
# 2848
(*retVal) = tmp; 
# 2849
} 
#endif
# 2851 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 2852
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2864
::exit(___);}
#if 0
# 2852
{ 
# 2853
unsigned char tmp; 
# 2854
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2855
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, face, x, y); 
# 2856
} else { 
# 2857
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2858
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, face, x, y); 
# 2859
} else { 
# 2860
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2861
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, face, x, y); 
# 2862
}  }  }  
# 2863
(*retVal) = make_uchar1(tmp); 
# 2864
} 
#endif
# 2866 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 2867
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2879
::exit(___);}
#if 0
# 2867
{ 
# 2868
short tmp; 
# 2869
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2870
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, face, x, y); 
# 2871
} else { 
# 2872
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2873
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, face, x, y); 
# 2874
} else { 
# 2875
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2876
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, face, x, y); 
# 2877
}  }  }  
# 2878
(*retVal) = tmp; 
# 2879
} 
#endif
# 2881 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 2882
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2894
::exit(___);}
#if 0
# 2882
{ 
# 2883
short tmp; 
# 2884
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2885
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, face, x, y); 
# 2886
} else { 
# 2887
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2888
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, face, x, y); 
# 2889
} else { 
# 2890
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2891
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, face, x, y); 
# 2892
}  }  }  
# 2893
(*retVal) = make_short1(tmp); 
# 2894
} 
#endif
# 2896 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 2897
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2909
::exit(___);}
#if 0
# 2897
{ 
# 2898
unsigned short tmp; 
# 2899
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2900
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, face, x, y); 
# 2901
} else { 
# 2902
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2903
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, face, x, y); 
# 2904
} else { 
# 2905
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2906
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, face, x, y); 
# 2907
}  }  }  
# 2908
(*retVal) = tmp; 
# 2909
} 
#endif
# 2911 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 2912
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2924
::exit(___);}
#if 0
# 2912
{ 
# 2913
unsigned short tmp; 
# 2914
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2915
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, face, x, y); 
# 2916
} else { 
# 2917
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2918
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, face, x, y); 
# 2919
} else { 
# 2920
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2921
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, face, x, y); 
# 2922
}  }  }  
# 2923
(*retVal) = make_ushort1(tmp); 
# 2924
} 
#endif
# 2926 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 2927
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2939
::exit(___);}
#if 0
# 2927
{ 
# 2928
int tmp; 
# 2929
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2930
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, face, x, y); 
# 2931
} else { 
# 2932
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2933
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, face, x, y); 
# 2934
} else { 
# 2935
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2936
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, face, x, y); 
# 2937
}  }  }  
# 2938
(*retVal) = tmp; 
# 2939
} 
#endif
# 2941 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 2942
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2954
::exit(___);}
#if 0
# 2942
{ 
# 2943
int tmp; 
# 2944
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2945
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, face, x, y); 
# 2946
} else { 
# 2947
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2948
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, face, x, y); 
# 2949
} else { 
# 2950
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2951
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, face, x, y); 
# 2952
}  }  }  
# 2953
(*retVal) = make_int1(tmp); 
# 2954
} 
#endif
# 2956 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 2957
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2969
::exit(___);}
#if 0
# 2957
{ 
# 2958
unsigned tmp; 
# 2959
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2960
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, face, x, y); 
# 2961
} else { 
# 2962
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2963
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, face, x, y); 
# 2964
} else { 
# 2965
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2966
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, face, x, y); 
# 2967
}  }  }  
# 2968
(*retVal) = tmp; 
# 2969
} 
#endif
# 2971 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 2972
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2984
::exit(___);}
#if 0
# 2972
{ 
# 2973
unsigned tmp; 
# 2974
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2975
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, face, x, y); 
# 2976
} else { 
# 2977
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2978
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, face, x, y); 
# 2979
} else { 
# 2980
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2981
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, face, x, y); 
# 2982
}  }  }  
# 2983
(*retVal) = make_uint1(tmp); 
# 2984
} 
#endif
# 2986 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 2987
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2999
::exit(___);}
#if 0
# 2987
{ 
# 2988
long long tmp; 
# 2989
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2990
__suld_2d_array_i64_trap((long long *)(&tmp), surfObject, face, x, y); 
# 2991
} else { 
# 2992
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2993
__suld_2d_array_i64_clamp((long long *)(&tmp), surfObject, face, x, y); 
# 2994
} else { 
# 2995
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2996
__suld_2d_array_i64_zero((long long *)(&tmp), surfObject, face, x, y); 
# 2997
}  }  }  
# 2998
(*retVal) = tmp; 
# 2999
} 
#endif
# 3001 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3002
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3014
::exit(___);}
#if 0
# 3002
{ 
# 3003
long long tmp; 
# 3004
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3005
__suld_2d_array_i64_trap((long long *)(&tmp), surfObject, face, x, y); 
# 3006
} else { 
# 3007
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3008
__suld_2d_array_i64_clamp((long long *)(&tmp), surfObject, face, x, y); 
# 3009
} else { 
# 3010
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3011
__suld_2d_array_i64_zero((long long *)(&tmp), surfObject, face, x, y); 
# 3012
}  }  }  
# 3013
(*retVal) = make_longlong1(tmp); 
# 3014
} 
#endif
# 3016 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3017
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3029
::exit(___);}
#if 0
# 3017
{ 
# 3018
unsigned long long tmp; 
# 3019
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3020
__suld_2d_array_i64_trap((long long *)(&tmp), surfObject, face, x, y); 
# 3021
} else { 
# 3022
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3023
__suld_2d_array_i64_clamp((long long *)(&tmp), surfObject, face, x, y); 
# 3024
} else { 
# 3025
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3026
__suld_2d_array_i64_zero((long long *)(&tmp), surfObject, face, x, y); 
# 3027
}  }  }  
# 3028
(*retVal) = tmp; 
# 3029
} 
#endif
# 3031 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3032
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3044
::exit(___);}
#if 0
# 3032
{ 
# 3033
unsigned long long tmp; 
# 3034
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3035
__suld_2d_array_i64_trap((long long *)(&tmp), surfObject, face, x, y); 
# 3036
} else { 
# 3037
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3038
__suld_2d_array_i64_clamp((long long *)(&tmp), surfObject, face, x, y); 
# 3039
} else { 
# 3040
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3041
__suld_2d_array_i64_zero((long long *)(&tmp), surfObject, face, x, y); 
# 3042
}  }  }  
# 3043
(*retVal) = make_ulonglong1(tmp); 
# 3044
} 
#endif
# 3046 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3047
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3059
::exit(___);}
#if 0
# 3047
{ 
# 3048
float tmp; 
# 3049
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3050
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, face, x, y); 
# 3051
} else { 
# 3052
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3053
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, face, x, y); 
# 3054
} else { 
# 3055
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3056
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, face, x, y); 
# 3057
}  }  }  
# 3058
(*retVal) = tmp; 
# 3059
} 
#endif
# 3061 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3062
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3074
::exit(___);}
#if 0
# 3062
{ 
# 3063
float tmp; 
# 3064
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3065
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, face, x, y); 
# 3066
} else { 
# 3067
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3068
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, face, x, y); 
# 3069
} else { 
# 3070
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3071
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, face, x, y); 
# 3072
}  }  }  
# 3073
(*retVal) = make_float1(tmp); 
# 3074
} 
#endif
# 3082 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3083
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3095
::exit(___);}
#if 0
# 3083
{ 
# 3084
char2 tmp; 
# 3085
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3086
__suld_2d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, face, x, y); 
# 3087
} else { 
# 3088
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3089
__suld_2d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, face, x, y); 
# 3090
} else { 
# 3091
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3092
__suld_2d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, face, x, y); 
# 3093
}  }  }  
# 3094
(*retVal) = tmp; 
# 3095
} 
#endif
# 3097 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3098
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3110
::exit(___);}
#if 0
# 3098
{ 
# 3099
uchar2 tmp; 
# 3100
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3101
__suld_2d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, face, x, y); 
# 3102
} else { 
# 3103
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3104
__suld_2d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, face, x, y); 
# 3105
} else { 
# 3106
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3107
__suld_2d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, face, x, y); 
# 3108
}  }  }  
# 3109
(*retVal) = tmp; 
# 3110
} 
#endif
# 3112 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3113
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3125
::exit(___);}
#if 0
# 3113
{ 
# 3114
short2 tmp; 
# 3115
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3116
__suld_2d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, face, x, y); 
# 3117
} else { 
# 3118
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3119
__suld_2d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, face, x, y); 
# 3120
} else { 
# 3121
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3122
__suld_2d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, face, x, y); 
# 3123
}  }  }  
# 3124
(*retVal) = tmp; 
# 3125
} 
#endif
# 3127 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3128
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3140
::exit(___);}
#if 0
# 3128
{ 
# 3129
ushort2 tmp; 
# 3130
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3131
__suld_2d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, face, x, y); 
# 3132
} else { 
# 3133
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3134
__suld_2d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, face, x, y); 
# 3135
} else { 
# 3136
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3137
__suld_2d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, face, x, y); 
# 3138
}  }  }  
# 3139
(*retVal) = tmp; 
# 3140
} 
#endif
# 3142 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3143
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3155
::exit(___);}
#if 0
# 3143
{ 
# 3144
int2 tmp; 
# 3145
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3146
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
# 3147
} else { 
# 3148
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3149
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
# 3150
} else { 
# 3151
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3152
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
# 3153
}  }  }  
# 3154
(*retVal) = tmp; 
# 3155
} 
#endif
# 3157 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3158
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3170
::exit(___);}
#if 0
# 3158
{ 
# 3159
uint2 tmp; 
# 3160
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3161
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
# 3162
} else { 
# 3163
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3164
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
# 3165
} else { 
# 3166
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3167
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
# 3168
}  }  }  
# 3169
(*retVal) = tmp; 
# 3170
} 
#endif
# 3172 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3173
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3185
::exit(___);}
#if 0
# 3173
{ 
# 3174
longlong2 tmp; 
# 3175
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3176
__suld_2d_array_v2i64_trap((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, face, x, y); 
# 3177
} else { 
# 3178
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3179
__suld_2d_array_v2i64_clamp((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, face, x, y); 
# 3180
} else { 
# 3181
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3182
__suld_2d_array_v2i64_zero((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, face, x, y); 
# 3183
}  }  }  
# 3184
(*retVal) = tmp; 
# 3185
} 
#endif
# 3187 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3188
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3200
::exit(___);}
#if 0
# 3188
{ 
# 3189
ulonglong2 tmp; 
# 3190
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3191
__suld_2d_array_v2i64_trap((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, face, x, y); 
# 3192
} else { 
# 3193
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3194
__suld_2d_array_v2i64_clamp((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, face, x, y); 
# 3195
} else { 
# 3196
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3197
__suld_2d_array_v2i64_zero((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, face, x, y); 
# 3198
}  }  }  
# 3199
(*retVal) = tmp; 
# 3200
} 
#endif
# 3202 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3203
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3215
::exit(___);}
#if 0
# 3203
{ 
# 3204
float2 tmp; 
# 3205
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3206
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
# 3207
} else { 
# 3208
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3209
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
# 3210
} else { 
# 3211
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3212
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
# 3213
}  }  }  
# 3214
(*retVal) = tmp; 
# 3215
} 
#endif
# 3223 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3224
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3236
::exit(___);}
#if 0
# 3224
{ 
# 3225
char4 tmp; 
# 3226
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3227
__suld_2d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, face, x, y); 
# 3228
} else { 
# 3229
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3230
__suld_2d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, face, x, y); 
# 3231
} else { 
# 3232
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3233
__suld_2d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, face, x, y); 
# 3234
}  }  }  
# 3235
(*retVal) = tmp; 
# 3236
} 
#endif
# 3238 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3239
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3251
::exit(___);}
#if 0
# 3239
{ 
# 3240
uchar4 tmp; 
# 3241
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3242
__suld_2d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, face, x, y); 
# 3243
} else { 
# 3244
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3245
__suld_2d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, face, x, y); 
# 3246
} else { 
# 3247
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3248
__suld_2d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, face, x, y); 
# 3249
}  }  }  
# 3250
(*retVal) = tmp; 
# 3251
} 
#endif
# 3253 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3254
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3266
::exit(___);}
#if 0
# 3254
{ 
# 3255
short4 tmp; 
# 3256
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3257
__suld_2d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, face, x, y); 
# 3258
} else { 
# 3259
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3260
__suld_2d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, face, x, y); 
# 3261
} else { 
# 3262
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3263
__suld_2d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, face, x, y); 
# 3264
}  }  }  
# 3265
(*retVal) = tmp; 
# 3266
} 
#endif
# 3268 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3269
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3281
::exit(___);}
#if 0
# 3269
{ 
# 3270
ushort4 tmp; 
# 3271
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3272
__suld_2d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, face, x, y); 
# 3273
} else { 
# 3274
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3275
__suld_2d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, face, x, y); 
# 3276
} else { 
# 3277
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3278
__suld_2d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, face, x, y); 
# 3279
}  }  }  
# 3280
(*retVal) = tmp; 
# 3281
} 
#endif
# 3283 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3284
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3296
::exit(___);}
#if 0
# 3284
{ 
# 3285
int4 tmp; 
# 3286
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3287
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
# 3288
} else { 
# 3289
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3290
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
# 3291
} else { 
# 3292
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3293
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
# 3294
}  }  }  
# 3295
(*retVal) = tmp; 
# 3296
} 
#endif
# 3298 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3299
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3311
::exit(___);}
#if 0
# 3299
{ 
# 3300
uint4 tmp; 
# 3301
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3302
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
# 3303
} else { 
# 3304
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3305
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
# 3306
} else { 
# 3307
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3308
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
# 3309
}  }  }  
# 3310
(*retVal) = tmp; 
# 3311
} 
#endif
# 3313 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 3314
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3326
::exit(___);}
#if 0
# 3314
{ 
# 3315
float4 tmp; 
# 3316
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3317
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
# 3318
} else { 
# 3319
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3320
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
# 3321
} else { 
# 3322
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3323
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
# 3324
}  }  }  
# 3325
(*retVal) = tmp; 
# 3326
} 
#endif
# 3334 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3335
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3347
::exit(___);}
#if 0
# 3335
{ 
# 3336
char tmp; 
# 3337
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3338
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layerface, x, y); 
# 3339
} else { 
# 3340
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3341
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layerface, x, y); 
# 3342
} else { 
# 3343
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3344
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layerface, x, y); 
# 3345
}  }  }  
# 3346
(*retVal) = tmp; 
# 3347
} 
#endif
# 3349 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3350
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3362
::exit(___);}
#if 0
# 3350
{ 
# 3351
signed char tmp; 
# 3352
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3353
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layerface, x, y); 
# 3354
} else { 
# 3355
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3356
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layerface, x, y); 
# 3357
} else { 
# 3358
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3359
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layerface, x, y); 
# 3360
}  }  }  
# 3361
(*retVal) = tmp; 
# 3362
} 
#endif
# 3364 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3365
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3377
::exit(___);}
#if 0
# 3365
{ 
# 3366
char tmp; 
# 3367
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3368
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layerface, x, y); 
# 3369
} else { 
# 3370
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3371
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layerface, x, y); 
# 3372
} else { 
# 3373
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3374
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layerface, x, y); 
# 3375
}  }  }  
# 3376
(*retVal) = make_char1(tmp); 
# 3377
} 
#endif
# 3379 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3380
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3392
::exit(___);}
#if 0
# 3380
{ 
# 3381
unsigned char tmp; 
# 3382
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3383
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layerface, x, y); 
# 3384
} else { 
# 3385
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3386
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layerface, x, y); 
# 3387
} else { 
# 3388
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3389
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layerface, x, y); 
# 3390
}  }  }  
# 3391
(*retVal) = tmp; 
# 3392
} 
#endif
# 3394 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3395
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3407
::exit(___);}
#if 0
# 3395
{ 
# 3396
unsigned char tmp; 
# 3397
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3398
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layerface, x, y); 
# 3399
} else { 
# 3400
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3401
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layerface, x, y); 
# 3402
} else { 
# 3403
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3404
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layerface, x, y); 
# 3405
}  }  }  
# 3406
(*retVal) = make_uchar1(tmp); 
# 3407
} 
#endif
# 3409 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3410
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3422
::exit(___);}
#if 0
# 3410
{ 
# 3411
short tmp; 
# 3412
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3413
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layerface, x, y); 
# 3414
} else { 
# 3415
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3416
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layerface, x, y); 
# 3417
} else { 
# 3418
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3419
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layerface, x, y); 
# 3420
}  }  }  
# 3421
(*retVal) = tmp; 
# 3422
} 
#endif
# 3424 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3425
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3437
::exit(___);}
#if 0
# 3425
{ 
# 3426
short tmp; 
# 3427
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3428
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layerface, x, y); 
# 3429
} else { 
# 3430
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3431
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layerface, x, y); 
# 3432
} else { 
# 3433
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3434
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layerface, x, y); 
# 3435
}  }  }  
# 3436
(*retVal) = make_short1(tmp); 
# 3437
} 
#endif
# 3439 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3440
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3452
::exit(___);}
#if 0
# 3440
{ 
# 3441
unsigned short tmp; 
# 3442
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3443
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layerface, x, y); 
# 3444
} else { 
# 3445
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3446
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layerface, x, y); 
# 3447
} else { 
# 3448
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3449
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layerface, x, y); 
# 3450
}  }  }  
# 3451
(*retVal) = tmp; 
# 3452
} 
#endif
# 3454 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3455
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3467
::exit(___);}
#if 0
# 3455
{ 
# 3456
unsigned short tmp; 
# 3457
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3458
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layerface, x, y); 
# 3459
} else { 
# 3460
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3461
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layerface, x, y); 
# 3462
} else { 
# 3463
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3464
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layerface, x, y); 
# 3465
}  }  }  
# 3466
(*retVal) = make_ushort1(tmp); 
# 3467
} 
#endif
# 3469 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3470
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3482
::exit(___);}
#if 0
# 3470
{ 
# 3471
int tmp; 
# 3472
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3473
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layerface, x, y); 
# 3474
} else { 
# 3475
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3476
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layerface, x, y); 
# 3477
} else { 
# 3478
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3479
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layerface, x, y); 
# 3480
}  }  }  
# 3481
(*retVal) = tmp; 
# 3482
} 
#endif
# 3484 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3485
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3497
::exit(___);}
#if 0
# 3485
{ 
# 3486
int tmp; 
# 3487
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3488
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layerface, x, y); 
# 3489
} else { 
# 3490
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3491
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layerface, x, y); 
# 3492
} else { 
# 3493
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3494
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layerface, x, y); 
# 3495
}  }  }  
# 3496
(*retVal) = make_int1(tmp); 
# 3497
} 
#endif
# 3499 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3500
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3512
::exit(___);}
#if 0
# 3500
{ 
# 3501
unsigned tmp; 
# 3502
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3503
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layerface, x, y); 
# 3504
} else { 
# 3505
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3506
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layerface, x, y); 
# 3507
} else { 
# 3508
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3509
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layerface, x, y); 
# 3510
}  }  }  
# 3511
(*retVal) = tmp; 
# 3512
} 
#endif
# 3514 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3515
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3527
::exit(___);}
#if 0
# 3515
{ 
# 3516
unsigned tmp; 
# 3517
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3518
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layerface, x, y); 
# 3519
} else { 
# 3520
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3521
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layerface, x, y); 
# 3522
} else { 
# 3523
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3524
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layerface, x, y); 
# 3525
}  }  }  
# 3526
(*retVal) = make_uint1(tmp); 
# 3527
} 
#endif
# 3529 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3530
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3542
::exit(___);}
#if 0
# 3530
{ 
# 3531
long long tmp; 
# 3532
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3533
__suld_2d_array_i64_trap((long long *)(&tmp), surfObject, layerface, x, y); 
# 3534
} else { 
# 3535
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3536
__suld_2d_array_i64_clamp((long long *)(&tmp), surfObject, layerface, x, y); 
# 3537
} else { 
# 3538
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3539
__suld_2d_array_i64_zero((long long *)(&tmp), surfObject, layerface, x, y); 
# 3540
}  }  }  
# 3541
(*retVal) = tmp; 
# 3542
} 
#endif
# 3544 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3545
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3557
::exit(___);}
#if 0
# 3545
{ 
# 3546
long long tmp; 
# 3547
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3548
__suld_2d_array_i64_trap((long long *)(&tmp), surfObject, layerface, x, y); 
# 3549
} else { 
# 3550
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3551
__suld_2d_array_i64_clamp((long long *)(&tmp), surfObject, layerface, x, y); 
# 3552
} else { 
# 3553
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3554
__suld_2d_array_i64_zero((long long *)(&tmp), surfObject, layerface, x, y); 
# 3555
}  }  }  
# 3556
(*retVal) = make_longlong1(tmp); 
# 3557
} 
#endif
# 3559 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3560
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3572
::exit(___);}
#if 0
# 3560
{ 
# 3561
unsigned long long tmp; 
# 3562
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3563
__suld_2d_array_i64_trap((long long *)(&tmp), surfObject, layerface, x, y); 
# 3564
} else { 
# 3565
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3566
__suld_2d_array_i64_clamp((long long *)(&tmp), surfObject, layerface, x, y); 
# 3567
} else { 
# 3568
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3569
__suld_2d_array_i64_zero((long long *)(&tmp), surfObject, layerface, x, y); 
# 3570
}  }  }  
# 3571
(*retVal) = tmp; 
# 3572
} 
#endif
# 3574 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3575
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3587
::exit(___);}
#if 0
# 3575
{ 
# 3576
unsigned long long tmp; 
# 3577
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3578
__suld_2d_array_i64_trap((long long *)(&tmp), surfObject, layerface, x, y); 
# 3579
} else { 
# 3580
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3581
__suld_2d_array_i64_clamp((long long *)(&tmp), surfObject, layerface, x, y); 
# 3582
} else { 
# 3583
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3584
__suld_2d_array_i64_zero((long long *)(&tmp), surfObject, layerface, x, y); 
# 3585
}  }  }  
# 3586
(*retVal) = make_ulonglong1(tmp); 
# 3587
} 
#endif
# 3589 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3590
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3602
::exit(___);}
#if 0
# 3590
{ 
# 3591
float tmp; 
# 3592
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3593
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layerface, x, y); 
# 3594
} else { 
# 3595
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3596
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layerface, x, y); 
# 3597
} else { 
# 3598
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3599
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layerface, x, y); 
# 3600
}  }  }  
# 3601
(*retVal) = tmp; 
# 3602
} 
#endif
# 3604 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3605
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3617
::exit(___);}
#if 0
# 3605
{ 
# 3606
float tmp; 
# 3607
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3608
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layerface, x, y); 
# 3609
} else { 
# 3610
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3611
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layerface, x, y); 
# 3612
} else { 
# 3613
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3614
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layerface, x, y); 
# 3615
}  }  }  
# 3616
(*retVal) = make_float1(tmp); 
# 3617
} 
#endif
# 3625 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3626
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3638
::exit(___);}
#if 0
# 3626
{ 
# 3627
char2 tmp; 
# 3628
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3629
__suld_2d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3630
} else { 
# 3631
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3632
__suld_2d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3633
} else { 
# 3634
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3635
__suld_2d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3636
}  }  }  
# 3637
(*retVal) = tmp; 
# 3638
} 
#endif
# 3640 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3641
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3653
::exit(___);}
#if 0
# 3641
{ 
# 3642
uchar2 tmp; 
# 3643
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3644
__suld_2d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3645
} else { 
# 3646
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3647
__suld_2d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3648
} else { 
# 3649
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3650
__suld_2d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3651
}  }  }  
# 3652
(*retVal) = tmp; 
# 3653
} 
#endif
# 3655 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3656
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3668
::exit(___);}
#if 0
# 3656
{ 
# 3657
short2 tmp; 
# 3658
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3659
__suld_2d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3660
} else { 
# 3661
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3662
__suld_2d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3663
} else { 
# 3664
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3665
__suld_2d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3666
}  }  }  
# 3667
(*retVal) = tmp; 
# 3668
} 
#endif
# 3670 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3671
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3683
::exit(___);}
#if 0
# 3671
{ 
# 3672
ushort2 tmp; 
# 3673
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3674
__suld_2d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3675
} else { 
# 3676
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3677
__suld_2d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3678
} else { 
# 3679
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3680
__suld_2d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3681
}  }  }  
# 3682
(*retVal) = tmp; 
# 3683
} 
#endif
# 3685 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3686
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3698
::exit(___);}
#if 0
# 3686
{ 
# 3687
int2 tmp; 
# 3688
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3689
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3690
} else { 
# 3691
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3692
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3693
} else { 
# 3694
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3695
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3696
}  }  }  
# 3697
(*retVal) = tmp; 
# 3698
} 
#endif
# 3700 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3701
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3713
::exit(___);}
#if 0
# 3701
{ 
# 3702
uint2 tmp; 
# 3703
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3704
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3705
} else { 
# 3706
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3707
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3708
} else { 
# 3709
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3710
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3711
}  }  }  
# 3712
(*retVal) = tmp; 
# 3713
} 
#endif
# 3715 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3716
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3728
::exit(___);}
#if 0
# 3716
{ 
# 3717
longlong2 tmp; 
# 3718
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3719
__suld_2d_array_v2i64_trap((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3720
} else { 
# 3721
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3722
__suld_2d_array_v2i64_clamp((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3723
} else { 
# 3724
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3725
__suld_2d_array_v2i64_zero((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3726
}  }  }  
# 3727
(*retVal) = tmp; 
# 3728
} 
#endif
# 3730 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3731
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3743
::exit(___);}
#if 0
# 3731
{ 
# 3732
ulonglong2 tmp; 
# 3733
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3734
__suld_2d_array_v2i64_trap((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3735
} else { 
# 3736
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3737
__suld_2d_array_v2i64_clamp((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3738
} else { 
# 3739
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3740
__suld_2d_array_v2i64_zero((long long *)(&(tmp.x)), (long long *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3741
}  }  }  
# 3742
(*retVal) = tmp; 
# 3743
} 
#endif
# 3745 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3746
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3758
::exit(___);}
#if 0
# 3746
{ 
# 3747
float2 tmp; 
# 3748
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3749
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3750
} else { 
# 3751
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3752
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3753
} else { 
# 3754
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3755
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
# 3756
}  }  }  
# 3757
(*retVal) = tmp; 
# 3758
} 
#endif
# 3766 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3767
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3779
::exit(___);}
#if 0
# 3767
{ 
# 3768
char4 tmp; 
# 3769
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3770
__suld_2d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3771
} else { 
# 3772
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3773
__suld_2d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3774
} else { 
# 3775
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3776
__suld_2d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3777
}  }  }  
# 3778
(*retVal) = tmp; 
# 3779
} 
#endif
# 3781 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3782
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3794
::exit(___);}
#if 0
# 3782
{ 
# 3783
uchar4 tmp; 
# 3784
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3785
__suld_2d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3786
} else { 
# 3787
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3788
__suld_2d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3789
} else { 
# 3790
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3791
__suld_2d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3792
}  }  }  
# 3793
(*retVal) = tmp; 
# 3794
} 
#endif
# 3796 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3797
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3809
::exit(___);}
#if 0
# 3797
{ 
# 3798
short4 tmp; 
# 3799
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3800
__suld_2d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3801
} else { 
# 3802
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3803
__suld_2d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3804
} else { 
# 3805
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3806
__suld_2d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3807
}  }  }  
# 3808
(*retVal) = tmp; 
# 3809
} 
#endif
# 3811 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3812
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3824
::exit(___);}
#if 0
# 3812
{ 
# 3813
ushort4 tmp; 
# 3814
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3815
__suld_2d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3816
} else { 
# 3817
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3818
__suld_2d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3819
} else { 
# 3820
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3821
__suld_2d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3822
}  }  }  
# 3823
(*retVal) = tmp; 
# 3824
} 
#endif
# 3826 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3827
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3839
::exit(___);}
#if 0
# 3827
{ 
# 3828
int4 tmp; 
# 3829
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3830
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3831
} else { 
# 3832
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3833
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3834
} else { 
# 3835
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3836
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3837
}  }  }  
# 3838
(*retVal) = tmp; 
# 3839
} 
#endif
# 3841 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3842
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3854
::exit(___);}
#if 0
# 3842
{ 
# 3843
uint4 tmp; 
# 3844
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3845
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3846
} else { 
# 3847
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3848
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3849
} else { 
# 3850
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3851
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3852
}  }  }  
# 3853
(*retVal) = tmp; 
# 3854
} 
#endif
# 3856 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 3857
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 3869
::exit(___);}
#if 0
# 3857
{ 
# 3858
float4 tmp; 
# 3859
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3860
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3861
} else { 
# 3862
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3863
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3864
} else { 
# 3865
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3866
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
# 3867
}  }  }  
# 3868
(*retVal) = tmp; 
# 3869
} 
#endif
# 3877 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 3878
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 3888
::exit(___);}
#if 0
# 3878
{ 
# 3879
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3880
__sust_b_1d_i8_trap(surfObject, x, data); 
# 3881
} else { 
# 3882
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3883
__sust_b_1d_i8_clamp(surfObject, x, data); 
# 3884
} else { 
# 3885
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3886
__sust_b_1d_i8_zero(surfObject, x, data); 
# 3887
}  }  }  
# 3888
} 
#endif
# 3890 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 3891
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 3901
::exit(___);}
#if 0
# 3891
{ 
# 3892
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3893
__sust_b_1d_i8_trap(surfObject, x, data); 
# 3894
} else { 
# 3895
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3896
__sust_b_1d_i8_clamp(surfObject, x, data); 
# 3897
} else { 
# 3898
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3899
__sust_b_1d_i8_zero(surfObject, x, data); 
# 3900
}  }  }  
# 3901
} 
#endif
# 3903 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 3904
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 3914
::exit(___);}
#if 0
# 3904
{ 
# 3905
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3906
__sust_b_1d_i8_trap(surfObject, x, data.x); 
# 3907
} else { 
# 3908
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3909
__sust_b_1d_i8_clamp(surfObject, x, data.x); 
# 3910
} else { 
# 3911
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3912
__sust_b_1d_i8_zero(surfObject, x, data.x); 
# 3913
}  }  }  
# 3914
} 
#endif
# 3916 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 3917
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 3927
::exit(___);}
#if 0
# 3917
{ 
# 3918
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3919
__sust_b_1d_i8_trap(surfObject, x, data); 
# 3920
} else { 
# 3921
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3922
__sust_b_1d_i8_clamp(surfObject, x, data); 
# 3923
} else { 
# 3924
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3925
__sust_b_1d_i8_zero(surfObject, x, data); 
# 3926
}  }  }  
# 3927
} 
#endif
# 3929 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 3930
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 3940
::exit(___);}
#if 0
# 3930
{ 
# 3931
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3932
__sust_b_1d_i8_trap(surfObject, x, data.x); 
# 3933
} else { 
# 3934
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3935
__sust_b_1d_i8_clamp(surfObject, x, data.x); 
# 3936
} else { 
# 3937
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3938
__sust_b_1d_i8_zero(surfObject, x, data.x); 
# 3939
}  }  }  
# 3940
} 
#endif
# 3942 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 3943
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 3953
::exit(___);}
#if 0
# 3943
{ 
# 3944
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3945
__sust_b_1d_i16_trap(surfObject, x, data); 
# 3946
} else { 
# 3947
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3948
__sust_b_1d_i16_clamp(surfObject, x, data); 
# 3949
} else { 
# 3950
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3951
__sust_b_1d_i16_zero(surfObject, x, data); 
# 3952
}  }  }  
# 3953
} 
#endif
# 3955 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 3956
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 3966
::exit(___);}
#if 0
# 3956
{ 
# 3957
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3958
__sust_b_1d_i16_trap(surfObject, x, data.x); 
# 3959
} else { 
# 3960
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3961
__sust_b_1d_i16_clamp(surfObject, x, data.x); 
# 3962
} else { 
# 3963
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3964
__sust_b_1d_i16_zero(surfObject, x, data.x); 
# 3965
}  }  }  
# 3966
} 
#endif
# 3968 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 3969
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 3979
::exit(___);}
#if 0
# 3969
{ 
# 3970
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3971
__sust_b_1d_i16_trap(surfObject, x, data); 
# 3972
} else { 
# 3973
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3974
__sust_b_1d_i16_clamp(surfObject, x, data); 
# 3975
} else { 
# 3976
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3977
__sust_b_1d_i16_zero(surfObject, x, data); 
# 3978
}  }  }  
# 3979
} 
#endif
# 3981 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 3982
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 3992
::exit(___);}
#if 0
# 3982
{ 
# 3983
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3984
__sust_b_1d_i16_trap(surfObject, x, data.x); 
# 3985
} else { 
# 3986
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3987
__sust_b_1d_i16_clamp(surfObject, x, data.x); 
# 3988
} else { 
# 3989
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3990
__sust_b_1d_i16_zero(surfObject, x, data.x); 
# 3991
}  }  }  
# 3992
} 
#endif
# 3994 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 3995
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4005
::exit(___);}
#if 0
# 3995
{ 
# 3996
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3997
__sust_b_1d_i32_trap(surfObject, x, data); 
# 3998
} else { 
# 3999
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4000
__sust_b_1d_i32_clamp(surfObject, x, data); 
# 4001
} else { 
# 4002
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4003
__sust_b_1d_i32_zero(surfObject, x, data); 
# 4004
}  }  }  
# 4005
} 
#endif
# 4007 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4008
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4018
::exit(___);}
#if 0
# 4008
{ 
# 4009
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4010
__sust_b_1d_i32_trap(surfObject, x, data.x); 
# 4011
} else { 
# 4012
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4013
__sust_b_1d_i32_clamp(surfObject, x, data.x); 
# 4014
} else { 
# 4015
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4016
__sust_b_1d_i32_zero(surfObject, x, data.x); 
# 4017
}  }  }  
# 4018
} 
#endif
# 4020 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4021
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4031
::exit(___);}
#if 0
# 4021
{ 
# 4022
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4023
__sust_b_1d_i32_trap(surfObject, x, data); 
# 4024
} else { 
# 4025
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4026
__sust_b_1d_i32_clamp(surfObject, x, data); 
# 4027
} else { 
# 4028
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4029
__sust_b_1d_i32_zero(surfObject, x, data); 
# 4030
}  }  }  
# 4031
} 
#endif
# 4033 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4034
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4044
::exit(___);}
#if 0
# 4034
{ 
# 4035
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4036
__sust_b_1d_i32_trap(surfObject, x, data.x); 
# 4037
} else { 
# 4038
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4039
__sust_b_1d_i32_clamp(surfObject, x, data.x); 
# 4040
} else { 
# 4041
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4042
__sust_b_1d_i32_zero(surfObject, x, data.x); 
# 4043
}  }  }  
# 4044
} 
#endif
# 4046 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4047
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4057
::exit(___);}
#if 0
# 4047
{ 
# 4048
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4049
__sust_b_1d_i64_trap(surfObject, x, data); 
# 4050
} else { 
# 4051
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4052
__sust_b_1d_i64_clamp(surfObject, x, data); 
# 4053
} else { 
# 4054
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4055
__sust_b_1d_i64_zero(surfObject, x, data); 
# 4056
}  }  }  
# 4057
} 
#endif
# 4059 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4060
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4070
::exit(___);}
#if 0
# 4060
{ 
# 4061
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4062
__sust_b_1d_i64_trap(surfObject, x, data.x); 
# 4063
} else { 
# 4064
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4065
__sust_b_1d_i64_clamp(surfObject, x, data.x); 
# 4066
} else { 
# 4067
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4068
__sust_b_1d_i64_zero(surfObject, x, data.x); 
# 4069
}  }  }  
# 4070
} 
#endif
# 4072 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4073
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4083
::exit(___);}
#if 0
# 4073
{ 
# 4074
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4075
__sust_b_1d_i64_trap(surfObject, x, data); 
# 4076
} else { 
# 4077
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4078
__sust_b_1d_i64_clamp(surfObject, x, data); 
# 4079
} else { 
# 4080
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4081
__sust_b_1d_i64_zero(surfObject, x, data); 
# 4082
}  }  }  
# 4083
} 
#endif
# 4085 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4086
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4096
::exit(___);}
#if 0
# 4086
{ 
# 4087
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4088
__sust_b_1d_i64_trap(surfObject, x, data.x); 
# 4089
} else { 
# 4090
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4091
__sust_b_1d_i64_clamp(surfObject, x, data.x); 
# 4092
} else { 
# 4093
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4094
__sust_b_1d_i64_zero(surfObject, x, data.x); 
# 4095
}  }  }  
# 4096
} 
#endif
# 4098 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4099
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4112
::exit(___);}
#if 0
# 4099
{ 
# 4100
union { float f; unsigned i; } cvt; 
# 4101
(cvt.f) = data; 
# 4103
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4104
__sust_b_1d_i32_trap(surfObject, x, cvt.i); 
# 4105
} else { 
# 4106
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4107
__sust_b_1d_i32_clamp(surfObject, x, cvt.i); 
# 4108
} else { 
# 4109
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4110
__sust_b_1d_i32_zero(surfObject, x, cvt.i); 
# 4111
}  }  }  
# 4112
} 
#endif
# 4114 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4115
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4128
::exit(___);}
#if 0
# 4115
{ 
# 4116
union { float f; unsigned i; } cvt; 
# 4117
(cvt.f) = (data.x); 
# 4119
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4120
__sust_b_1d_i32_trap(surfObject, x, cvt.i); 
# 4121
} else { 
# 4122
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4123
__sust_b_1d_i32_clamp(surfObject, x, cvt.i); 
# 4124
} else { 
# 4125
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4126
__sust_b_1d_i32_zero(surfObject, x, cvt.i); 
# 4127
}  }  }  
# 4128
} 
#endif
# 4136 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4137
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4147
::exit(___);}
#if 0
# 4137
{ 
# 4138
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4139
__sust_b_1d_v2i8_trap(surfObject, x, make_uchar2(data.x, data.y)); 
# 4140
} else { 
# 4141
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4142
__sust_b_1d_v2i8_clamp(surfObject, x, make_uchar2(data.x, data.y)); 
# 4143
} else { 
# 4144
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4145
__sust_b_1d_v2i8_zero(surfObject, x, make_uchar2(data.x, data.y)); 
# 4146
}  }  }  
# 4147
} 
#endif
# 4149 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4150
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4160
::exit(___);}
#if 0
# 4150
{ 
# 4151
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4152
__sust_b_1d_v2i8_trap(surfObject, x, data); 
# 4153
} else { 
# 4154
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4155
__sust_b_1d_v2i8_clamp(surfObject, x, data); 
# 4156
} else { 
# 4157
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4158
__sust_b_1d_v2i8_zero(surfObject, x, data); 
# 4159
}  }  }  
# 4160
} 
#endif
# 4162 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4163
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4173
::exit(___);}
#if 0
# 4163
{ 
# 4164
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4165
__sust_b_1d_v2i16_trap(surfObject, x, make_ushort2(data.x, data.y)); 
# 4166
} else { 
# 4167
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4168
__sust_b_1d_v2i16_clamp(surfObject, x, make_ushort2(data.x, data.y)); 
# 4169
} else { 
# 4170
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4171
__sust_b_1d_v2i16_zero(surfObject, x, make_ushort2(data.x, data.y)); 
# 4172
}  }  }  
# 4173
} 
#endif
# 4175 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4176
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4186
::exit(___);}
#if 0
# 4176
{ 
# 4177
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4178
__sust_b_1d_v2i16_trap(surfObject, x, data); 
# 4179
} else { 
# 4180
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4181
__sust_b_1d_v2i16_clamp(surfObject, x, data); 
# 4182
} else { 
# 4183
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4184
__sust_b_1d_v2i16_zero(surfObject, x, data); 
# 4185
}  }  }  
# 4186
} 
#endif
# 4188 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4189
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4199
::exit(___);}
#if 0
# 4189
{ 
# 4190
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4191
__sust_b_1d_v2i32_trap(surfObject, x, make_uint2(data.x, data.y)); 
# 4192
} else { 
# 4193
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4194
__sust_b_1d_v2i32_clamp(surfObject, x, make_uint2(data.x, data.y)); 
# 4195
} else { 
# 4196
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4197
__sust_b_1d_v2i32_zero(surfObject, x, make_uint2(data.x, data.y)); 
# 4198
}  }  }  
# 4199
} 
#endif
# 4201 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4202
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4212
::exit(___);}
#if 0
# 4202
{ 
# 4203
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4204
__sust_b_1d_v2i32_trap(surfObject, x, data); 
# 4205
} else { 
# 4206
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4207
__sust_b_1d_v2i32_clamp(surfObject, x, data); 
# 4208
} else { 
# 4209
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4210
__sust_b_1d_v2i32_zero(surfObject, x, data); 
# 4211
}  }  }  
# 4212
} 
#endif
# 4214 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4215
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4225
::exit(___);}
#if 0
# 4215
{ 
# 4216
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4217
__sust_b_1d_v2i64_trap(surfObject, x, make_ulonglong2(data.x, data.y)); 
# 4218
} else { 
# 4219
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4220
__sust_b_1d_v2i64_clamp(surfObject, x, make_ulonglong2(data.x, data.y)); 
# 4221
} else { 
# 4222
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4223
__sust_b_1d_v2i64_zero(surfObject, x, make_ulonglong2(data.x, data.y)); 
# 4224
}  }  }  
# 4225
} 
#endif
# 4227 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4228
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4238
::exit(___);}
#if 0
# 4228
{ 
# 4229
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4230
__sust_b_1d_v2i64_trap(surfObject, x, data); 
# 4231
} else { 
# 4232
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4233
__sust_b_1d_v2i64_clamp(surfObject, x, data); 
# 4234
} else { 
# 4235
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4236
__sust_b_1d_v2i64_zero(surfObject, x, data); 
# 4237
}  }  }  
# 4238
} 
#endif
# 4240 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4241
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4254
::exit(___);}
#if 0
# 4241
{ 
# 4242
union { float2 f; uint2 i; } cvt; 
# 4243
(cvt.f) = data; 
# 4245
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4246
__sust_b_1d_v2i32_trap(surfObject, x, cvt.i); 
# 4247
} else { 
# 4248
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4249
__sust_b_1d_v2i32_clamp(surfObject, x, cvt.i); 
# 4250
} else { 
# 4251
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4252
__sust_b_1d_v2i32_zero(surfObject, x, cvt.i); 
# 4253
}  }  }  
# 4254
} 
#endif
# 4262 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4263
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4273
::exit(___);}
#if 0
# 4263
{ 
# 4264
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4265
__sust_b_1d_v4i8_trap(surfObject, x, make_uchar4(data.x, data.y, data.z, data.w)); 
# 4266
} else { 
# 4267
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4268
__sust_b_1d_v4i8_clamp(surfObject, x, make_uchar4(data.x, data.y, data.z, data.w)); 
# 4269
} else { 
# 4270
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4271
__sust_b_1d_v4i8_zero(surfObject, x, make_uchar4(data.x, data.y, data.z, data.w)); 
# 4272
}  }  }  
# 4273
} 
#endif
# 4275 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4276
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4286
::exit(___);}
#if 0
# 4276
{ 
# 4277
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4278
__sust_b_1d_v4i8_trap(surfObject, x, data); 
# 4279
} else { 
# 4280
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4281
__sust_b_1d_v4i8_clamp(surfObject, x, data); 
# 4282
} else { 
# 4283
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4284
__sust_b_1d_v4i8_zero(surfObject, x, data); 
# 4285
}  }  }  
# 4286
} 
#endif
# 4288 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4289
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4299
::exit(___);}
#if 0
# 4289
{ 
# 4290
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4291
__sust_b_1d_v4i16_trap(surfObject, x, make_ushort4(data.x, data.y, data.z, data.w)); 
# 4292
} else { 
# 4293
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4294
__sust_b_1d_v4i16_clamp(surfObject, x, make_ushort4(data.x, data.y, data.z, data.w)); 
# 4295
} else { 
# 4296
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4297
__sust_b_1d_v4i16_zero(surfObject, x, make_ushort4(data.x, data.y, data.z, data.w)); 
# 4298
}  }  }  
# 4299
} 
#endif
# 4301 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4302
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4312
::exit(___);}
#if 0
# 4302
{ 
# 4303
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4304
__sust_b_1d_v4i16_trap(surfObject, x, data); 
# 4305
} else { 
# 4306
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4307
__sust_b_1d_v4i16_clamp(surfObject, x, data); 
# 4308
} else { 
# 4309
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4310
__sust_b_1d_v4i16_zero(surfObject, x, data); 
# 4311
}  }  }  
# 4312
} 
#endif
# 4314 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4315
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4325
::exit(___);}
#if 0
# 4315
{ 
# 4316
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4317
__sust_b_1d_v4i32_trap(surfObject, x, make_uint4(data.x, data.y, data.z, data.w)); 
# 4318
} else { 
# 4319
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4320
__sust_b_1d_v4i32_clamp(surfObject, x, make_uint4(data.x, data.y, data.z, data.w)); 
# 4321
} else { 
# 4322
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4323
__sust_b_1d_v4i32_zero(surfObject, x, make_uint4(data.x, data.y, data.z, data.w)); 
# 4324
}  }  }  
# 4325
} 
#endif
# 4327 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4328
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4338
::exit(___);}
#if 0
# 4328
{ 
# 4329
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4330
__sust_b_1d_v4i32_trap(surfObject, x, data); 
# 4331
} else { 
# 4332
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4333
__sust_b_1d_v4i32_clamp(surfObject, x, data); 
# 4334
} else { 
# 4335
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4336
__sust_b_1d_v4i32_zero(surfObject, x, data); 
# 4337
}  }  }  
# 4338
} 
#endif
# 4340 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
# 4341
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4354
::exit(___);}
#if 0
# 4341
{ 
# 4342
union { float4 f; uint4 i; } cvt; 
# 4343
(cvt.f) = data; 
# 4345
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4346
__sust_b_1d_v4i32_trap(surfObject, x, cvt.i); 
# 4347
} else { 
# 4348
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4349
__sust_b_1d_v4i32_clamp(surfObject, x, cvt.i); 
# 4350
} else { 
# 4351
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4352
__sust_b_1d_v4i32_zero(surfObject, x, cvt.i); 
# 4353
}  }  }  
# 4354
} 
#endif
# 4362 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4363
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4373
::exit(___);}
#if 0
# 4363
{ 
# 4364
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4365
__sust_b_2d_i8_trap(surfObject, x, y, data); 
# 4366
} else { 
# 4367
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4368
__sust_b_2d_i8_clamp(surfObject, x, y, data); 
# 4369
} else { 
# 4370
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4371
__sust_b_2d_i8_zero(surfObject, x, y, data); 
# 4372
}  }  }  
# 4373
} 
#endif
# 4375 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4376
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4386
::exit(___);}
#if 0
# 4376
{ 
# 4377
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4378
__sust_b_2d_i8_trap(surfObject, x, y, data); 
# 4379
} else { 
# 4380
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4381
__sust_b_2d_i8_clamp(surfObject, x, y, data); 
# 4382
} else { 
# 4383
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4384
__sust_b_2d_i8_zero(surfObject, x, y, data); 
# 4385
}  }  }  
# 4386
} 
#endif
# 4388 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4389
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4399
::exit(___);}
#if 0
# 4389
{ 
# 4390
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4391
__sust_b_2d_i8_trap(surfObject, x, y, data.x); 
# 4392
} else { 
# 4393
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4394
__sust_b_2d_i8_clamp(surfObject, x, y, data.x); 
# 4395
} else { 
# 4396
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4397
__sust_b_2d_i8_zero(surfObject, x, y, data.x); 
# 4398
}  }  }  
# 4399
} 
#endif
# 4401 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4402
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4412
::exit(___);}
#if 0
# 4402
{ 
# 4403
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4404
__sust_b_2d_i8_trap(surfObject, x, y, data); 
# 4405
} else { 
# 4406
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4407
__sust_b_2d_i8_clamp(surfObject, x, y, data); 
# 4408
} else { 
# 4409
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4410
__sust_b_2d_i8_zero(surfObject, x, y, data); 
# 4411
}  }  }  
# 4412
} 
#endif
# 4414 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4415
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4425
::exit(___);}
#if 0
# 4415
{ 
# 4416
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4417
__sust_b_2d_i8_trap(surfObject, x, y, data.x); 
# 4418
} else { 
# 4419
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4420
__sust_b_2d_i8_clamp(surfObject, x, y, data.x); 
# 4421
} else { 
# 4422
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4423
__sust_b_2d_i8_zero(surfObject, x, y, data.x); 
# 4424
}  }  }  
# 4425
} 
#endif
# 4427 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4428
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4438
::exit(___);}
#if 0
# 4428
{ 
# 4429
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4430
__sust_b_2d_i16_trap(surfObject, x, y, data); 
# 4431
} else { 
# 4432
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4433
__sust_b_2d_i16_clamp(surfObject, x, y, data); 
# 4434
} else { 
# 4435
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4436
__sust_b_2d_i16_zero(surfObject, x, y, data); 
# 4437
}  }  }  
# 4438
} 
#endif
# 4440 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4441
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4451
::exit(___);}
#if 0
# 4441
{ 
# 4442
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4443
__sust_b_2d_i16_trap(surfObject, x, y, data.x); 
# 4444
} else { 
# 4445
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4446
__sust_b_2d_i16_clamp(surfObject, x, y, data.x); 
# 4447
} else { 
# 4448
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4449
__sust_b_2d_i16_zero(surfObject, x, y, data.x); 
# 4450
}  }  }  
# 4451
} 
#endif
# 4453 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4454
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4464
::exit(___);}
#if 0
# 4454
{ 
# 4455
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4456
__sust_b_2d_i16_trap(surfObject, x, y, data); 
# 4457
} else { 
# 4458
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4459
__sust_b_2d_i16_clamp(surfObject, x, y, data); 
# 4460
} else { 
# 4461
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4462
__sust_b_2d_i16_zero(surfObject, x, y, data); 
# 4463
}  }  }  
# 4464
} 
#endif
# 4466 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4467
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4477
::exit(___);}
#if 0
# 4467
{ 
# 4468
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4469
__sust_b_2d_i16_trap(surfObject, x, y, data.x); 
# 4470
} else { 
# 4471
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4472
__sust_b_2d_i16_clamp(surfObject, x, y, data.x); 
# 4473
} else { 
# 4474
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4475
__sust_b_2d_i16_zero(surfObject, x, y, data.x); 
# 4476
}  }  }  
# 4477
} 
#endif
# 4479 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4480
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4490
::exit(___);}
#if 0
# 4480
{ 
# 4481
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4482
__sust_b_2d_i32_trap(surfObject, x, y, data); 
# 4483
} else { 
# 4484
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4485
__sust_b_2d_i32_clamp(surfObject, x, y, data); 
# 4486
} else { 
# 4487
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4488
__sust_b_2d_i32_zero(surfObject, x, y, data); 
# 4489
}  }  }  
# 4490
} 
#endif
# 4492 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4493
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4503
::exit(___);}
#if 0
# 4493
{ 
# 4494
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4495
__sust_b_2d_i32_trap(surfObject, x, y, data.x); 
# 4496
} else { 
# 4497
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4498
__sust_b_2d_i32_clamp(surfObject, x, y, data.x); 
# 4499
} else { 
# 4500
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4501
__sust_b_2d_i32_zero(surfObject, x, y, data.x); 
# 4502
}  }  }  
# 4503
} 
#endif
# 4505 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4506
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4516
::exit(___);}
#if 0
# 4506
{ 
# 4507
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4508
__sust_b_2d_i32_trap(surfObject, x, y, data); 
# 4509
} else { 
# 4510
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4511
__sust_b_2d_i32_clamp(surfObject, x, y, data); 
# 4512
} else { 
# 4513
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4514
__sust_b_2d_i32_zero(surfObject, x, y, data); 
# 4515
}  }  }  
# 4516
} 
#endif
# 4518 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4519
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4529
::exit(___);}
#if 0
# 4519
{ 
# 4520
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4521
__sust_b_2d_i32_trap(surfObject, x, y, data.x); 
# 4522
} else { 
# 4523
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4524
__sust_b_2d_i32_clamp(surfObject, x, y, data.x); 
# 4525
} else { 
# 4526
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4527
__sust_b_2d_i32_zero(surfObject, x, y, data.x); 
# 4528
}  }  }  
# 4529
} 
#endif
# 4531 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4532
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4542
::exit(___);}
#if 0
# 4532
{ 
# 4533
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4534
__sust_b_2d_i64_trap(surfObject, x, y, data); 
# 4535
} else { 
# 4536
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4537
__sust_b_2d_i64_clamp(surfObject, x, y, data); 
# 4538
} else { 
# 4539
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4540
__sust_b_2d_i64_zero(surfObject, x, y, data); 
# 4541
}  }  }  
# 4542
} 
#endif
# 4544 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4545
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4555
::exit(___);}
#if 0
# 4545
{ 
# 4546
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4547
__sust_b_2d_i64_trap(surfObject, x, y, data.x); 
# 4548
} else { 
# 4549
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4550
__sust_b_2d_i64_clamp(surfObject, x, y, data.x); 
# 4551
} else { 
# 4552
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4553
__sust_b_2d_i64_zero(surfObject, x, y, data.x); 
# 4554
}  }  }  
# 4555
} 
#endif
# 4557 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4558
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4568
::exit(___);}
#if 0
# 4558
{ 
# 4559
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4560
__sust_b_2d_i64_trap(surfObject, x, y, data); 
# 4561
} else { 
# 4562
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4563
__sust_b_2d_i64_clamp(surfObject, x, y, data); 
# 4564
} else { 
# 4565
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4566
__sust_b_2d_i64_zero(surfObject, x, y, data); 
# 4567
}  }  }  
# 4568
} 
#endif
# 4570 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4571
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4581
::exit(___);}
#if 0
# 4571
{ 
# 4572
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4573
__sust_b_2d_i64_trap(surfObject, x, y, data.x); 
# 4574
} else { 
# 4575
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4576
__sust_b_2d_i64_clamp(surfObject, x, y, data.x); 
# 4577
} else { 
# 4578
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4579
__sust_b_2d_i64_zero(surfObject, x, y, data.x); 
# 4580
}  }  }  
# 4581
} 
#endif
# 4583 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4584
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4597
::exit(___);}
#if 0
# 4584
{ 
# 4585
union { float f; unsigned i; } cvt; 
# 4586
(cvt.f) = data; 
# 4588
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4589
__sust_b_2d_i32_trap(surfObject, x, y, cvt.i); 
# 4590
} else { 
# 4591
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4592
__sust_b_2d_i32_clamp(surfObject, x, y, cvt.i); 
# 4593
} else { 
# 4594
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4595
__sust_b_2d_i32_zero(surfObject, x, y, cvt.i); 
# 4596
}  }  }  
# 4597
} 
#endif
# 4599 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4600
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4613
::exit(___);}
#if 0
# 4600
{ 
# 4601
union { float f; unsigned i; } cvt; 
# 4602
(cvt.f) = (data.x); 
# 4604
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4605
__sust_b_2d_i32_trap(surfObject, x, y, cvt.i); 
# 4606
} else { 
# 4607
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4608
__sust_b_2d_i32_clamp(surfObject, x, y, cvt.i); 
# 4609
} else { 
# 4610
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4611
__sust_b_2d_i32_zero(surfObject, x, y, cvt.i); 
# 4612
}  }  }  
# 4613
} 
#endif
# 4621 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4622
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4632
::exit(___);}
#if 0
# 4622
{ 
# 4623
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4624
__sust_b_2d_v2i8_trap(surfObject, x, y, make_uchar2(data.x, data.y)); 
# 4625
} else { 
# 4626
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4627
__sust_b_2d_v2i8_clamp(surfObject, x, y, make_uchar2(data.x, data.y)); 
# 4628
} else { 
# 4629
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4630
__sust_b_2d_v2i8_zero(surfObject, x, y, make_uchar2(data.x, data.y)); 
# 4631
}  }  }  
# 4632
} 
#endif
# 4634 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4635
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4645
::exit(___);}
#if 0
# 4635
{ 
# 4636
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4637
__sust_b_2d_v2i8_trap(surfObject, x, y, data); 
# 4638
} else { 
# 4639
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4640
__sust_b_2d_v2i8_clamp(surfObject, x, y, data); 
# 4641
} else { 
# 4642
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4643
__sust_b_2d_v2i8_zero(surfObject, x, y, data); 
# 4644
}  }  }  
# 4645
} 
#endif
# 4647 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4648
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4658
::exit(___);}
#if 0
# 4648
{ 
# 4649
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4650
__sust_b_2d_v2i16_trap(surfObject, x, y, make_ushort2(data.x, data.y)); 
# 4651
} else { 
# 4652
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4653
__sust_b_2d_v2i16_clamp(surfObject, x, y, make_ushort2(data.x, data.y)); 
# 4654
} else { 
# 4655
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4656
__sust_b_2d_v2i16_zero(surfObject, x, y, make_ushort2(data.x, data.y)); 
# 4657
}  }  }  
# 4658
} 
#endif
# 4660 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4661
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4671
::exit(___);}
#if 0
# 4661
{ 
# 4662
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4663
__sust_b_2d_v2i16_trap(surfObject, x, y, data); 
# 4664
} else { 
# 4665
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4666
__sust_b_2d_v2i16_clamp(surfObject, x, y, data); 
# 4667
} else { 
# 4668
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4669
__sust_b_2d_v2i16_zero(surfObject, x, y, data); 
# 4670
}  }  }  
# 4671
} 
#endif
# 4673 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4674
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4684
::exit(___);}
#if 0
# 4674
{ 
# 4675
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4676
__sust_b_2d_v2i32_trap(surfObject, x, y, make_uint2(data.x, data.y)); 
# 4677
} else { 
# 4678
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4679
__sust_b_2d_v2i32_clamp(surfObject, x, y, make_uint2(data.x, data.y)); 
# 4680
} else { 
# 4681
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4682
__sust_b_2d_v2i32_zero(surfObject, x, y, make_uint2(data.x, data.y)); 
# 4683
}  }  }  
# 4684
} 
#endif
# 4686 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4687
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4697
::exit(___);}
#if 0
# 4687
{ 
# 4688
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4689
__sust_b_2d_v2i32_trap(surfObject, x, y, data); 
# 4690
} else { 
# 4691
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4692
__sust_b_2d_v2i32_clamp(surfObject, x, y, data); 
# 4693
} else { 
# 4694
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4695
__sust_b_2d_v2i32_zero(surfObject, x, y, data); 
# 4696
}  }  }  
# 4697
} 
#endif
# 4699 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4700
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4710
::exit(___);}
#if 0
# 4700
{ 
# 4701
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4702
__sust_b_2d_v2i64_trap(surfObject, x, y, make_ulonglong2(data.x, data.y)); 
# 4703
} else { 
# 4704
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4705
__sust_b_2d_v2i64_clamp(surfObject, x, y, make_ulonglong2(data.x, data.y)); 
# 4706
} else { 
# 4707
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4708
__sust_b_2d_v2i64_zero(surfObject, x, y, make_ulonglong2(data.x, data.y)); 
# 4709
}  }  }  
# 4710
} 
#endif
# 4712 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4713
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4723
::exit(___);}
#if 0
# 4713
{ 
# 4714
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4715
__sust_b_2d_v2i64_trap(surfObject, x, y, data); 
# 4716
} else { 
# 4717
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4718
__sust_b_2d_v2i64_clamp(surfObject, x, y, data); 
# 4719
} else { 
# 4720
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4721
__sust_b_2d_v2i64_zero(surfObject, x, y, data); 
# 4722
}  }  }  
# 4723
} 
#endif
# 4725 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4726
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4739
::exit(___);}
#if 0
# 4726
{ 
# 4727
union { float2 f; uint2 i; } cvt; 
# 4728
(cvt.f) = data; 
# 4730
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4731
__sust_b_2d_v2i32_trap(surfObject, x, y, cvt.i); 
# 4732
} else { 
# 4733
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4734
__sust_b_2d_v2i32_clamp(surfObject, x, y, cvt.i); 
# 4735
} else { 
# 4736
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4737
__sust_b_2d_v2i32_zero(surfObject, x, y, cvt.i); 
# 4738
}  }  }  
# 4739
} 
#endif
# 4747 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4748
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4758
::exit(___);}
#if 0
# 4748
{ 
# 4749
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4750
__sust_b_2d_v4i8_trap(surfObject, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
# 4751
} else { 
# 4752
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4753
__sust_b_2d_v4i8_clamp(surfObject, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
# 4754
} else { 
# 4755
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4756
__sust_b_2d_v4i8_zero(surfObject, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
# 4757
}  }  }  
# 4758
} 
#endif
# 4760 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4761
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4771
::exit(___);}
#if 0
# 4761
{ 
# 4762
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4763
__sust_b_2d_v4i8_trap(surfObject, x, y, data); 
# 4764
} else { 
# 4765
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4766
__sust_b_2d_v4i8_clamp(surfObject, x, y, data); 
# 4767
} else { 
# 4768
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4769
__sust_b_2d_v4i8_zero(surfObject, x, y, data); 
# 4770
}  }  }  
# 4771
} 
#endif
# 4773 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4774
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4784
::exit(___);}
#if 0
# 4774
{ 
# 4775
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4776
__sust_b_2d_v4i16_trap(surfObject, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
# 4777
} else { 
# 4778
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4779
__sust_b_2d_v4i16_clamp(surfObject, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
# 4780
} else { 
# 4781
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4782
__sust_b_2d_v4i16_zero(surfObject, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
# 4783
}  }  }  
# 4784
} 
#endif
# 4786 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4787
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4797
::exit(___);}
#if 0
# 4787
{ 
# 4788
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4789
__sust_b_2d_v4i16_trap(surfObject, x, y, data); 
# 4790
} else { 
# 4791
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4792
__sust_b_2d_v4i16_clamp(surfObject, x, y, data); 
# 4793
} else { 
# 4794
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4795
__sust_b_2d_v4i16_zero(surfObject, x, y, data); 
# 4796
}  }  }  
# 4797
} 
#endif
# 4799 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4800
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4810
::exit(___);}
#if 0
# 4800
{ 
# 4801
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4802
__sust_b_2d_v4i32_trap(surfObject, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
# 4803
} else { 
# 4804
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4805
__sust_b_2d_v4i32_clamp(surfObject, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
# 4806
} else { 
# 4807
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4808
__sust_b_2d_v4i32_zero(surfObject, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
# 4809
}  }  }  
# 4810
} 
#endif
# 4812 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4813
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4823
::exit(___);}
#if 0
# 4813
{ 
# 4814
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4815
__sust_b_2d_v4i32_trap(surfObject, x, y, data); 
# 4816
} else { 
# 4817
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4818
__sust_b_2d_v4i32_clamp(surfObject, x, y, data); 
# 4819
} else { 
# 4820
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4821
__sust_b_2d_v4i32_zero(surfObject, x, y, data); 
# 4822
}  }  }  
# 4823
} 
#endif
# 4825 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
# 4826
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4839
::exit(___);}
#if 0
# 4826
{ 
# 4827
union { float4 f; uint4 i; } cvt; 
# 4828
(cvt.f) = data; 
# 4830
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4831
__sust_b_2d_v4i32_trap(surfObject, x, y, cvt.i); 
# 4832
} else { 
# 4833
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4834
__sust_b_2d_v4i32_clamp(surfObject, x, y, cvt.i); 
# 4835
} else { 
# 4836
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4837
__sust_b_2d_v4i32_zero(surfObject, x, y, cvt.i); 
# 4838
}  }  }  
# 4839
} 
#endif
# 4848 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 4849
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4859
::exit(___);}
#if 0
# 4849
{ 
# 4850
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4851
__sust_b_3d_i8_trap(surfObject, x, y, z, data); 
# 4852
} else { 
# 4853
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4854
__sust_b_3d_i8_clamp(surfObject, x, y, z, data); 
# 4855
} else { 
# 4856
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4857
__sust_b_3d_i8_zero(surfObject, x, y, z, data); 
# 4858
}  }  }  
# 4859
} 
#endif
# 4861 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 4862
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4872
::exit(___);}
#if 0
# 4862
{ 
# 4863
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4864
__sust_b_3d_i8_trap(surfObject, x, y, z, data); 
# 4865
} else { 
# 4866
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4867
__sust_b_3d_i8_clamp(surfObject, x, y, z, data); 
# 4868
} else { 
# 4869
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4870
__sust_b_3d_i8_zero(surfObject, x, y, z, data); 
# 4871
}  }  }  
# 4872
} 
#endif
# 4874 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 4875
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4885
::exit(___);}
#if 0
# 4875
{ 
# 4876
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4877
__sust_b_3d_i8_trap(surfObject, x, y, z, data.x); 
# 4878
} else { 
# 4879
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4880
__sust_b_3d_i8_clamp(surfObject, x, y, z, data.x); 
# 4881
} else { 
# 4882
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4883
__sust_b_3d_i8_zero(surfObject, x, y, z, data.x); 
# 4884
}  }  }  
# 4885
} 
#endif
# 4887 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 4888
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4898
::exit(___);}
#if 0
# 4888
{ 
# 4889
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4890
__sust_b_3d_i8_trap(surfObject, x, y, z, data); 
# 4891
} else { 
# 4892
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4893
__sust_b_3d_i8_clamp(surfObject, x, y, z, data); 
# 4894
} else { 
# 4895
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4896
__sust_b_3d_i8_zero(surfObject, x, y, z, data); 
# 4897
}  }  }  
# 4898
} 
#endif
# 4900 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 4901
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4911
::exit(___);}
#if 0
# 4901
{ 
# 4902
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4903
__sust_b_3d_i8_trap(surfObject, x, y, z, data.x); 
# 4904
} else { 
# 4905
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4906
__sust_b_3d_i8_clamp(surfObject, x, y, z, data.x); 
# 4907
} else { 
# 4908
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4909
__sust_b_3d_i8_zero(surfObject, x, y, z, data.x); 
# 4910
}  }  }  
# 4911
} 
#endif
# 4913 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 4914
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4924
::exit(___);}
#if 0
# 4914
{ 
# 4915
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4916
__sust_b_3d_i16_trap(surfObject, x, y, z, data); 
# 4917
} else { 
# 4918
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4919
__sust_b_3d_i16_clamp(surfObject, x, y, z, data); 
# 4920
} else { 
# 4921
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4922
__sust_b_3d_i16_zero(surfObject, x, y, z, data); 
# 4923
}  }  }  
# 4924
} 
#endif
# 4926 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 4927
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4937
::exit(___);}
#if 0
# 4927
{ 
# 4928
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4929
__sust_b_3d_i16_trap(surfObject, x, y, z, data.x); 
# 4930
} else { 
# 4931
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4932
__sust_b_3d_i16_clamp(surfObject, x, y, z, data.x); 
# 4933
} else { 
# 4934
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4935
__sust_b_3d_i16_zero(surfObject, x, y, z, data.x); 
# 4936
}  }  }  
# 4937
} 
#endif
# 4939 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 4940
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4950
::exit(___);}
#if 0
# 4940
{ 
# 4941
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4942
__sust_b_3d_i16_trap(surfObject, x, y, z, data); 
# 4943
} else { 
# 4944
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4945
__sust_b_3d_i16_clamp(surfObject, x, y, z, data); 
# 4946
} else { 
# 4947
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4948
__sust_b_3d_i16_zero(surfObject, x, y, z, data); 
# 4949
}  }  }  
# 4950
} 
#endif
# 4952 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 4953
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4963
::exit(___);}
#if 0
# 4953
{ 
# 4954
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4955
__sust_b_3d_i16_trap(surfObject, x, y, z, data.x); 
# 4956
} else { 
# 4957
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4958
__sust_b_3d_i16_clamp(surfObject, x, y, z, data.x); 
# 4959
} else { 
# 4960
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4961
__sust_b_3d_i16_zero(surfObject, x, y, z, data.x); 
# 4962
}  }  }  
# 4963
} 
#endif
# 4965 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 4966
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4976
::exit(___);}
#if 0
# 4966
{ 
# 4967
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4968
__sust_b_3d_i32_trap(surfObject, x, y, z, data); 
# 4969
} else { 
# 4970
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4971
__sust_b_3d_i32_clamp(surfObject, x, y, z, data); 
# 4972
} else { 
# 4973
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4974
__sust_b_3d_i32_zero(surfObject, x, y, z, data); 
# 4975
}  }  }  
# 4976
} 
#endif
# 4978 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 4979
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4989
::exit(___);}
#if 0
# 4979
{ 
# 4980
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4981
__sust_b_3d_i32_trap(surfObject, x, y, z, data.x); 
# 4982
} else { 
# 4983
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4984
__sust_b_3d_i32_clamp(surfObject, x, y, z, data.x); 
# 4985
} else { 
# 4986
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4987
__sust_b_3d_i32_zero(surfObject, x, y, z, data.x); 
# 4988
}  }  }  
# 4989
} 
#endif
# 4991 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 4992
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5002
::exit(___);}
#if 0
# 4992
{ 
# 4993
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4994
__sust_b_3d_i32_trap(surfObject, x, y, z, data); 
# 4995
} else { 
# 4996
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4997
__sust_b_3d_i32_clamp(surfObject, x, y, z, data); 
# 4998
} else { 
# 4999
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5000
__sust_b_3d_i32_zero(surfObject, x, y, z, data); 
# 5001
}  }  }  
# 5002
} 
#endif
# 5004 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5005
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5015
::exit(___);}
#if 0
# 5005
{ 
# 5006
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5007
__sust_b_3d_i32_trap(surfObject, x, y, z, data.x); 
# 5008
} else { 
# 5009
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5010
__sust_b_3d_i32_clamp(surfObject, x, y, z, data.x); 
# 5011
} else { 
# 5012
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5013
__sust_b_3d_i32_zero(surfObject, x, y, z, data.x); 
# 5014
}  }  }  
# 5015
} 
#endif
# 5017 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5018
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5028
::exit(___);}
#if 0
# 5018
{ 
# 5019
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5020
__sust_b_3d_i64_trap(surfObject, x, y, z, data); 
# 5021
} else { 
# 5022
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5023
__sust_b_3d_i64_clamp(surfObject, x, y, z, data); 
# 5024
} else { 
# 5025
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5026
__sust_b_3d_i64_zero(surfObject, x, y, z, data); 
# 5027
}  }  }  
# 5028
} 
#endif
# 5030 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5031
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5041
::exit(___);}
#if 0
# 5031
{ 
# 5032
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5033
__sust_b_3d_i64_trap(surfObject, x, y, z, data.x); 
# 5034
} else { 
# 5035
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5036
__sust_b_3d_i64_clamp(surfObject, x, y, z, data.x); 
# 5037
} else { 
# 5038
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5039
__sust_b_3d_i64_zero(surfObject, x, y, z, data.x); 
# 5040
}  }  }  
# 5041
} 
#endif
# 5043 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5044
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5054
::exit(___);}
#if 0
# 5044
{ 
# 5045
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5046
__sust_b_3d_i64_trap(surfObject, x, y, z, data); 
# 5047
} else { 
# 5048
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5049
__sust_b_3d_i64_clamp(surfObject, x, y, z, data); 
# 5050
} else { 
# 5051
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5052
__sust_b_3d_i64_zero(surfObject, x, y, z, data); 
# 5053
}  }  }  
# 5054
} 
#endif
# 5056 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5057
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5067
::exit(___);}
#if 0
# 5057
{ 
# 5058
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5059
__sust_b_3d_i64_trap(surfObject, x, y, z, data.x); 
# 5060
} else { 
# 5061
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5062
__sust_b_3d_i64_clamp(surfObject, x, y, z, data.x); 
# 5063
} else { 
# 5064
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5065
__sust_b_3d_i64_zero(surfObject, x, y, z, data.x); 
# 5066
}  }  }  
# 5067
} 
#endif
# 5069 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5070
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5083
::exit(___);}
#if 0
# 5070
{ 
# 5071
union { float f; unsigned i; } cvt; 
# 5072
(cvt.f) = data; 
# 5074
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5075
__sust_b_3d_i32_trap(surfObject, x, y, z, cvt.i); 
# 5076
} else { 
# 5077
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5078
__sust_b_3d_i32_clamp(surfObject, x, y, z, cvt.i); 
# 5079
} else { 
# 5080
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5081
__sust_b_3d_i32_zero(surfObject, x, y, z, cvt.i); 
# 5082
}  }  }  
# 5083
} 
#endif
# 5085 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5086
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5099
::exit(___);}
#if 0
# 5086
{ 
# 5087
union { float f; unsigned i; } cvt; 
# 5088
(cvt.f) = (data.x); 
# 5090
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5091
__sust_b_3d_i32_trap(surfObject, x, y, z, cvt.i); 
# 5092
} else { 
# 5093
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5094
__sust_b_3d_i32_clamp(surfObject, x, y, z, cvt.i); 
# 5095
} else { 
# 5096
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5097
__sust_b_3d_i32_zero(surfObject, x, y, z, cvt.i); 
# 5098
}  }  }  
# 5099
} 
#endif
# 5107 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5108
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5118
::exit(___);}
#if 0
# 5108
{ 
# 5109
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5110
__sust_b_3d_v2i8_trap(surfObject, x, y, z, make_uchar2(data.x, data.y)); 
# 5111
} else { 
# 5112
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5113
__sust_b_3d_v2i8_clamp(surfObject, x, y, z, make_uchar2(data.x, data.y)); 
# 5114
} else { 
# 5115
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5116
__sust_b_3d_v2i8_zero(surfObject, x, y, z, make_uchar2(data.x, data.y)); 
# 5117
}  }  }  
# 5118
} 
#endif
# 5120 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5121
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5131
::exit(___);}
#if 0
# 5121
{ 
# 5122
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5123
__sust_b_3d_v2i8_trap(surfObject, x, y, z, data); 
# 5124
} else { 
# 5125
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5126
__sust_b_3d_v2i8_clamp(surfObject, x, y, z, data); 
# 5127
} else { 
# 5128
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5129
__sust_b_3d_v2i8_zero(surfObject, x, y, z, data); 
# 5130
}  }  }  
# 5131
} 
#endif
# 5133 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5134
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5144
::exit(___);}
#if 0
# 5134
{ 
# 5135
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5136
__sust_b_3d_v2i16_trap(surfObject, x, y, z, make_ushort2(data.x, data.y)); 
# 5137
} else { 
# 5138
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5139
__sust_b_3d_v2i16_clamp(surfObject, x, y, z, make_ushort2(data.x, data.y)); 
# 5140
} else { 
# 5141
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5142
__sust_b_3d_v2i16_zero(surfObject, x, y, z, make_ushort2(data.x, data.y)); 
# 5143
}  }  }  
# 5144
} 
#endif
# 5146 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5147
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5157
::exit(___);}
#if 0
# 5147
{ 
# 5148
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5149
__sust_b_3d_v2i16_trap(surfObject, x, y, z, data); 
# 5150
} else { 
# 5151
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5152
__sust_b_3d_v2i16_clamp(surfObject, x, y, z, data); 
# 5153
} else { 
# 5154
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5155
__sust_b_3d_v2i16_zero(surfObject, x, y, z, data); 
# 5156
}  }  }  
# 5157
} 
#endif
# 5159 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5160
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5170
::exit(___);}
#if 0
# 5160
{ 
# 5161
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5162
__sust_b_3d_v2i32_trap(surfObject, x, y, z, make_uint2(data.x, data.y)); 
# 5163
} else { 
# 5164
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5165
__sust_b_3d_v2i32_clamp(surfObject, x, y, z, make_uint2(data.x, data.y)); 
# 5166
} else { 
# 5167
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5168
__sust_b_3d_v2i32_zero(surfObject, x, y, z, make_uint2(data.x, data.y)); 
# 5169
}  }  }  
# 5170
} 
#endif
# 5172 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5173
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5183
::exit(___);}
#if 0
# 5173
{ 
# 5174
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5175
__sust_b_3d_v2i32_trap(surfObject, x, y, z, data); 
# 5176
} else { 
# 5177
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5178
__sust_b_3d_v2i32_clamp(surfObject, x, y, z, data); 
# 5179
} else { 
# 5180
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5181
__sust_b_3d_v2i32_zero(surfObject, x, y, z, data); 
# 5182
}  }  }  
# 5183
} 
#endif
# 5185 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5186
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5196
::exit(___);}
#if 0
# 5186
{ 
# 5187
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5188
__sust_b_3d_v2i64_trap(surfObject, x, y, z, make_ulonglong2(data.x, data.y)); 
# 5189
} else { 
# 5190
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5191
__sust_b_3d_v2i64_clamp(surfObject, x, y, z, make_ulonglong2(data.x, data.y)); 
# 5192
} else { 
# 5193
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5194
__sust_b_3d_v2i64_zero(surfObject, x, y, z, make_ulonglong2(data.x, data.y)); 
# 5195
}  }  }  
# 5196
} 
#endif
# 5198 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5199
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5209
::exit(___);}
#if 0
# 5199
{ 
# 5200
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5201
__sust_b_3d_v2i64_trap(surfObject, x, y, z, data); 
# 5202
} else { 
# 5203
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5204
__sust_b_3d_v2i64_clamp(surfObject, x, y, z, data); 
# 5205
} else { 
# 5206
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5207
__sust_b_3d_v2i64_zero(surfObject, x, y, z, data); 
# 5208
}  }  }  
# 5209
} 
#endif
# 5211 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5212
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5225
::exit(___);}
#if 0
# 5212
{ 
# 5213
union { float2 f; uint2 i; } cvt; 
# 5214
(cvt.f) = data; 
# 5216
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5217
__sust_b_3d_v2i32_trap(surfObject, x, y, z, cvt.i); 
# 5218
} else { 
# 5219
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5220
__sust_b_3d_v2i32_clamp(surfObject, x, y, z, cvt.i); 
# 5221
} else { 
# 5222
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5223
__sust_b_3d_v2i32_zero(surfObject, x, y, z, cvt.i); 
# 5224
}  }  }  
# 5225
} 
#endif
# 5233 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5234
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5244
::exit(___);}
#if 0
# 5234
{ 
# 5235
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5236
__sust_b_3d_v4i8_trap(surfObject, x, y, z, make_uchar4(data.x, data.y, data.z, data.w)); 
# 5237
} else { 
# 5238
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5239
__sust_b_3d_v4i8_clamp(surfObject, x, y, z, make_uchar4(data.x, data.y, data.z, data.w)); 
# 5240
} else { 
# 5241
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5242
__sust_b_3d_v4i8_zero(surfObject, x, y, z, make_uchar4(data.x, data.y, data.z, data.w)); 
# 5243
}  }  }  
# 5244
} 
#endif
# 5246 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5247
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5257
::exit(___);}
#if 0
# 5247
{ 
# 5248
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5249
__sust_b_3d_v4i8_trap(surfObject, x, y, z, data); 
# 5250
} else { 
# 5251
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5252
__sust_b_3d_v4i8_clamp(surfObject, x, y, z, data); 
# 5253
} else { 
# 5254
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5255
__sust_b_3d_v4i8_zero(surfObject, x, y, z, data); 
# 5256
}  }  }  
# 5257
} 
#endif
# 5259 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5260
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5270
::exit(___);}
#if 0
# 5260
{ 
# 5261
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5262
__sust_b_3d_v4i16_trap(surfObject, x, y, z, make_ushort4(data.x, data.y, data.z, data.w)); 
# 5263
} else { 
# 5264
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5265
__sust_b_3d_v4i16_clamp(surfObject, x, y, z, make_ushort4(data.x, data.y, data.z, data.w)); 
# 5266
} else { 
# 5267
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5268
__sust_b_3d_v4i16_zero(surfObject, x, y, z, make_ushort4(data.x, data.y, data.z, data.w)); 
# 5269
}  }  }  
# 5270
} 
#endif
# 5272 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5273
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5283
::exit(___);}
#if 0
# 5273
{ 
# 5274
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5275
__sust_b_3d_v4i16_trap(surfObject, x, y, z, data); 
# 5276
} else { 
# 5277
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5278
__sust_b_3d_v4i16_clamp(surfObject, x, y, z, data); 
# 5279
} else { 
# 5280
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5281
__sust_b_3d_v4i16_zero(surfObject, x, y, z, data); 
# 5282
}  }  }  
# 5283
} 
#endif
# 5285 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5286
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5296
::exit(___);}
#if 0
# 5286
{ 
# 5287
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5288
__sust_b_3d_v4i32_trap(surfObject, x, y, z, make_uint4(data.x, data.y, data.z, data.w)); 
# 5289
} else { 
# 5290
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5291
__sust_b_3d_v4i32_clamp(surfObject, x, y, z, make_uint4(data.x, data.y, data.z, data.w)); 
# 5292
} else { 
# 5293
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5294
__sust_b_3d_v4i32_zero(surfObject, x, y, z, make_uint4(data.x, data.y, data.z, data.w)); 
# 5295
}  }  }  
# 5296
} 
#endif
# 5298 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5299
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5309
::exit(___);}
#if 0
# 5299
{ 
# 5300
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5301
__sust_b_3d_v4i32_trap(surfObject, x, y, z, data); 
# 5302
} else { 
# 5303
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5304
__sust_b_3d_v4i32_clamp(surfObject, x, y, z, data); 
# 5305
} else { 
# 5306
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5307
__sust_b_3d_v4i32_zero(surfObject, x, y, z, data); 
# 5308
}  }  }  
# 5309
} 
#endif
# 5311 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
# 5312
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5325
::exit(___);}
#if 0
# 5312
{ 
# 5313
union { float4 f; uint4 i; } cvt; 
# 5314
(cvt.f) = data; 
# 5316
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5317
__sust_b_3d_v4i32_trap(surfObject, x, y, z, cvt.i); 
# 5318
} else { 
# 5319
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5320
__sust_b_3d_v4i32_clamp(surfObject, x, y, z, cvt.i); 
# 5321
} else { 
# 5322
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5323
__sust_b_3d_v4i32_zero(surfObject, x, y, z, cvt.i); 
# 5324
}  }  }  
# 5325
} 
#endif
# 5333 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5334
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5344
::exit(___);}
#if 0
# 5334
{ 
# 5335
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5336
__sust_b_1d_array_i8_trap(surfObject, layer, x, data); 
# 5337
} else { 
# 5338
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5339
__sust_b_1d_array_i8_clamp(surfObject, layer, x, data); 
# 5340
} else { 
# 5341
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5342
__sust_b_1d_array_i8_zero(surfObject, layer, x, data); 
# 5343
}  }  }  
# 5344
} 
#endif
# 5346 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5347
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5357
::exit(___);}
#if 0
# 5347
{ 
# 5348
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5349
__sust_b_1d_array_i8_trap(surfObject, layer, x, data); 
# 5350
} else { 
# 5351
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5352
__sust_b_1d_array_i8_clamp(surfObject, layer, x, data); 
# 5353
} else { 
# 5354
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5355
__sust_b_1d_array_i8_zero(surfObject, layer, x, data); 
# 5356
}  }  }  
# 5357
} 
#endif
# 5359 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5360
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5370
::exit(___);}
#if 0
# 5360
{ 
# 5361
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5362
__sust_b_1d_array_i8_trap(surfObject, layer, x, data.x); 
# 5363
} else { 
# 5364
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5365
__sust_b_1d_array_i8_clamp(surfObject, layer, x, data.x); 
# 5366
} else { 
# 5367
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5368
__sust_b_1d_array_i8_zero(surfObject, layer, x, data.x); 
# 5369
}  }  }  
# 5370
} 
#endif
# 5372 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5373
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5383
::exit(___);}
#if 0
# 5373
{ 
# 5374
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5375
__sust_b_1d_array_i8_trap(surfObject, layer, x, data); 
# 5376
} else { 
# 5377
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5378
__sust_b_1d_array_i8_clamp(surfObject, layer, x, data); 
# 5379
} else { 
# 5380
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5381
__sust_b_1d_array_i8_zero(surfObject, layer, x, data); 
# 5382
}  }  }  
# 5383
} 
#endif
# 5385 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5386
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5396
::exit(___);}
#if 0
# 5386
{ 
# 5387
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5388
__sust_b_1d_array_i8_trap(surfObject, layer, x, data.x); 
# 5389
} else { 
# 5390
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5391
__sust_b_1d_array_i8_clamp(surfObject, layer, x, data.x); 
# 5392
} else { 
# 5393
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5394
__sust_b_1d_array_i8_zero(surfObject, layer, x, data.x); 
# 5395
}  }  }  
# 5396
} 
#endif
# 5398 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5399
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5409
::exit(___);}
#if 0
# 5399
{ 
# 5400
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5401
__sust_b_1d_array_i16_trap(surfObject, layer, x, data); 
# 5402
} else { 
# 5403
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5404
__sust_b_1d_array_i16_clamp(surfObject, layer, x, data); 
# 5405
} else { 
# 5406
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5407
__sust_b_1d_array_i16_zero(surfObject, layer, x, data); 
# 5408
}  }  }  
# 5409
} 
#endif
# 5411 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5412
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5422
::exit(___);}
#if 0
# 5412
{ 
# 5413
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5414
__sust_b_1d_array_i16_trap(surfObject, layer, x, data.x); 
# 5415
} else { 
# 5416
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5417
__sust_b_1d_array_i16_clamp(surfObject, layer, x, data.x); 
# 5418
} else { 
# 5419
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5420
__sust_b_1d_array_i16_zero(surfObject, layer, x, data.x); 
# 5421
}  }  }  
# 5422
} 
#endif
# 5424 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5425
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5435
::exit(___);}
#if 0
# 5425
{ 
# 5426
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5427
__sust_b_1d_array_i16_trap(surfObject, layer, x, data); 
# 5428
} else { 
# 5429
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5430
__sust_b_1d_array_i16_clamp(surfObject, layer, x, data); 
# 5431
} else { 
# 5432
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5433
__sust_b_1d_array_i16_zero(surfObject, layer, x, data); 
# 5434
}  }  }  
# 5435
} 
#endif
# 5437 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5438
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5448
::exit(___);}
#if 0
# 5438
{ 
# 5439
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5440
__sust_b_1d_array_i16_trap(surfObject, layer, x, data.x); 
# 5441
} else { 
# 5442
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5443
__sust_b_1d_array_i16_clamp(surfObject, layer, x, data.x); 
# 5444
} else { 
# 5445
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5446
__sust_b_1d_array_i16_zero(surfObject, layer, x, data.x); 
# 5447
}  }  }  
# 5448
} 
#endif
# 5450 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5451
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5461
::exit(___);}
#if 0
# 5451
{ 
# 5452
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5453
__sust_b_1d_array_i32_trap(surfObject, layer, x, data); 
# 5454
} else { 
# 5455
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5456
__sust_b_1d_array_i32_clamp(surfObject, layer, x, data); 
# 5457
} else { 
# 5458
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5459
__sust_b_1d_array_i32_zero(surfObject, layer, x, data); 
# 5460
}  }  }  
# 5461
} 
#endif
# 5463 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5464
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5474
::exit(___);}
#if 0
# 5464
{ 
# 5465
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5466
__sust_b_1d_array_i32_trap(surfObject, layer, x, data.x); 
# 5467
} else { 
# 5468
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5469
__sust_b_1d_array_i32_clamp(surfObject, layer, x, data.x); 
# 5470
} else { 
# 5471
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5472
__sust_b_1d_array_i32_zero(surfObject, layer, x, data.x); 
# 5473
}  }  }  
# 5474
} 
#endif
# 5476 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5477
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5487
::exit(___);}
#if 0
# 5477
{ 
# 5478
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5479
__sust_b_1d_array_i32_trap(surfObject, layer, x, data); 
# 5480
} else { 
# 5481
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5482
__sust_b_1d_array_i32_clamp(surfObject, layer, x, data); 
# 5483
} else { 
# 5484
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5485
__sust_b_1d_array_i32_zero(surfObject, layer, x, data); 
# 5486
}  }  }  
# 5487
} 
#endif
# 5489 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5490
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5500
::exit(___);}
#if 0
# 5490
{ 
# 5491
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5492
__sust_b_1d_array_i32_trap(surfObject, layer, x, data.x); 
# 5493
} else { 
# 5494
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5495
__sust_b_1d_array_i32_clamp(surfObject, layer, x, data.x); 
# 5496
} else { 
# 5497
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5498
__sust_b_1d_array_i32_zero(surfObject, layer, x, data.x); 
# 5499
}  }  }  
# 5500
} 
#endif
# 5502 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5503
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5513
::exit(___);}
#if 0
# 5503
{ 
# 5504
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5505
__sust_b_1d_array_i64_trap(surfObject, layer, x, data); 
# 5506
} else { 
# 5507
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5508
__sust_b_1d_array_i64_clamp(surfObject, layer, x, data); 
# 5509
} else { 
# 5510
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5511
__sust_b_1d_array_i64_zero(surfObject, layer, x, data); 
# 5512
}  }  }  
# 5513
} 
#endif
# 5515 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5516
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5526
::exit(___);}
#if 0
# 5516
{ 
# 5517
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5518
__sust_b_1d_array_i64_trap(surfObject, layer, x, data.x); 
# 5519
} else { 
# 5520
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5521
__sust_b_1d_array_i64_clamp(surfObject, layer, x, data.x); 
# 5522
} else { 
# 5523
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5524
__sust_b_1d_array_i64_zero(surfObject, layer, x, data.x); 
# 5525
}  }  }  
# 5526
} 
#endif
# 5528 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5529
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5539
::exit(___);}
#if 0
# 5529
{ 
# 5530
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5531
__sust_b_1d_array_i64_trap(surfObject, layer, x, data); 
# 5532
} else { 
# 5533
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5534
__sust_b_1d_array_i64_clamp(surfObject, layer, x, data); 
# 5535
} else { 
# 5536
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5537
__sust_b_1d_array_i64_zero(surfObject, layer, x, data); 
# 5538
}  }  }  
# 5539
} 
#endif
# 5541 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5542
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5552
::exit(___);}
#if 0
# 5542
{ 
# 5543
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5544
__sust_b_1d_array_i64_trap(surfObject, layer, x, data.x); 
# 5545
} else { 
# 5546
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5547
__sust_b_1d_array_i64_clamp(surfObject, layer, x, data.x); 
# 5548
} else { 
# 5549
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5550
__sust_b_1d_array_i64_zero(surfObject, layer, x, data.x); 
# 5551
}  }  }  
# 5552
} 
#endif
# 5554 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5555
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5568
::exit(___);}
#if 0
# 5555
{ 
# 5556
union { float f; unsigned i; } cvt; 
# 5557
(cvt.f) = data; 
# 5559
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5560
__sust_b_1d_array_i32_trap(surfObject, layer, x, cvt.i); 
# 5561
} else { 
# 5562
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5563
__sust_b_1d_array_i32_clamp(surfObject, layer, x, cvt.i); 
# 5564
} else { 
# 5565
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5566
__sust_b_1d_array_i32_zero(surfObject, layer, x, cvt.i); 
# 5567
}  }  }  
# 5568
} 
#endif
# 5570 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5571
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5584
::exit(___);}
#if 0
# 5571
{ 
# 5572
union { float f; unsigned i; } cvt; 
# 5573
(cvt.f) = (data.x); 
# 5575
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5576
__sust_b_1d_array_i32_trap(surfObject, layer, x, cvt.i); 
# 5577
} else { 
# 5578
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5579
__sust_b_1d_array_i32_clamp(surfObject, layer, x, cvt.i); 
# 5580
} else { 
# 5581
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5582
__sust_b_1d_array_i32_zero(surfObject, layer, x, cvt.i); 
# 5583
}  }  }  
# 5584
} 
#endif
# 5592 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5593
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5603
::exit(___);}
#if 0
# 5593
{ 
# 5594
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5595
__sust_b_1d_array_v2i8_trap(surfObject, layer, x, make_uchar2(data.x, data.y)); 
# 5596
} else { 
# 5597
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5598
__sust_b_1d_array_v2i8_clamp(surfObject, layer, x, make_uchar2(data.x, data.y)); 
# 5599
} else { 
# 5600
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5601
__sust_b_1d_array_v2i8_zero(surfObject, layer, x, make_uchar2(data.x, data.y)); 
# 5602
}  }  }  
# 5603
} 
#endif
# 5605 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5606
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5616
::exit(___);}
#if 0
# 5606
{ 
# 5607
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5608
__sust_b_1d_array_v2i8_trap(surfObject, layer, x, data); 
# 5609
} else { 
# 5610
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5611
__sust_b_1d_array_v2i8_clamp(surfObject, layer, x, data); 
# 5612
} else { 
# 5613
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5614
__sust_b_1d_array_v2i8_zero(surfObject, layer, x, data); 
# 5615
}  }  }  
# 5616
} 
#endif
# 5618 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5619
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5629
::exit(___);}
#if 0
# 5619
{ 
# 5620
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5621
__sust_b_1d_array_v2i16_trap(surfObject, layer, x, make_ushort2(data.x, data.y)); 
# 5622
} else { 
# 5623
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5624
__sust_b_1d_array_v2i16_clamp(surfObject, layer, x, make_ushort2(data.x, data.y)); 
# 5625
} else { 
# 5626
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5627
__sust_b_1d_array_v2i16_zero(surfObject, layer, x, make_ushort2(data.x, data.y)); 
# 5628
}  }  }  
# 5629
} 
#endif
# 5631 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5632
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5642
::exit(___);}
#if 0
# 5632
{ 
# 5633
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5634
__sust_b_1d_array_v2i16_trap(surfObject, layer, x, data); 
# 5635
} else { 
# 5636
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5637
__sust_b_1d_array_v2i16_clamp(surfObject, layer, x, data); 
# 5638
} else { 
# 5639
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5640
__sust_b_1d_array_v2i16_zero(surfObject, layer, x, data); 
# 5641
}  }  }  
# 5642
} 
#endif
# 5644 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5645
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5655
::exit(___);}
#if 0
# 5645
{ 
# 5646
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5647
__sust_b_1d_array_v2i32_trap(surfObject, layer, x, make_uint2(data.x, data.y)); 
# 5648
} else { 
# 5649
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5650
__sust_b_1d_array_v2i32_clamp(surfObject, layer, x, make_uint2(data.x, data.y)); 
# 5651
} else { 
# 5652
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5653
__sust_b_1d_array_v2i32_zero(surfObject, layer, x, make_uint2(data.x, data.y)); 
# 5654
}  }  }  
# 5655
} 
#endif
# 5657 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5658
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5668
::exit(___);}
#if 0
# 5658
{ 
# 5659
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5660
__sust_b_1d_array_v2i32_trap(surfObject, layer, x, data); 
# 5661
} else { 
# 5662
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5663
__sust_b_1d_array_v2i32_clamp(surfObject, layer, x, data); 
# 5664
} else { 
# 5665
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5666
__sust_b_1d_array_v2i32_zero(surfObject, layer, x, data); 
# 5667
}  }  }  
# 5668
} 
#endif
# 5670 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5671
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5681
::exit(___);}
#if 0
# 5671
{ 
# 5672
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5673
__sust_b_1d_array_v2i64_trap(surfObject, layer, x, make_ulonglong2(data.x, data.y)); 
# 5674
} else { 
# 5675
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5676
__sust_b_1d_array_v2i64_clamp(surfObject, layer, x, make_ulonglong2(data.x, data.y)); 
# 5677
} else { 
# 5678
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5679
__sust_b_1d_array_v2i64_zero(surfObject, layer, x, make_ulonglong2(data.x, data.y)); 
# 5680
}  }  }  
# 5681
} 
#endif
# 5683 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5684
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5694
::exit(___);}
#if 0
# 5684
{ 
# 5685
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5686
__sust_b_1d_array_v2i64_trap(surfObject, layer, x, data); 
# 5687
} else { 
# 5688
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5689
__sust_b_1d_array_v2i64_clamp(surfObject, layer, x, data); 
# 5690
} else { 
# 5691
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5692
__sust_b_1d_array_v2i64_zero(surfObject, layer, x, data); 
# 5693
}  }  }  
# 5694
} 
#endif
# 5696 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5697
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5710
::exit(___);}
#if 0
# 5697
{ 
# 5698
union { float2 f; uint2 i; } cvt; 
# 5699
(cvt.f) = data; 
# 5701
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5702
__sust_b_1d_array_v2i32_trap(surfObject, layer, x, cvt.i); 
# 5703
} else { 
# 5704
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5705
__sust_b_1d_array_v2i32_clamp(surfObject, layer, x, cvt.i); 
# 5706
} else { 
# 5707
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5708
__sust_b_1d_array_v2i32_zero(surfObject, layer, x, cvt.i); 
# 5709
}  }  }  
# 5710
} 
#endif
# 5718 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5719
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5729
::exit(___);}
#if 0
# 5719
{ 
# 5720
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5721
__sust_b_1d_array_v4i8_trap(surfObject, layer, x, make_uchar4(data.x, data.y, data.z, data.w)); 
# 5722
} else { 
# 5723
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5724
__sust_b_1d_array_v4i8_clamp(surfObject, layer, x, make_uchar4(data.x, data.y, data.z, data.w)); 
# 5725
} else { 
# 5726
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5727
__sust_b_1d_array_v4i8_zero(surfObject, layer, x, make_uchar4(data.x, data.y, data.z, data.w)); 
# 5728
}  }  }  
# 5729
} 
#endif
# 5731 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5732
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5742
::exit(___);}
#if 0
# 5732
{ 
# 5733
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5734
__sust_b_1d_array_v4i8_trap(surfObject, layer, x, data); 
# 5735
} else { 
# 5736
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5737
__sust_b_1d_array_v4i8_clamp(surfObject, layer, x, data); 
# 5738
} else { 
# 5739
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5740
__sust_b_1d_array_v4i8_zero(surfObject, layer, x, data); 
# 5741
}  }  }  
# 5742
} 
#endif
# 5744 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5745
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5755
::exit(___);}
#if 0
# 5745
{ 
# 5746
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5747
__sust_b_1d_array_v4i16_trap(surfObject, layer, x, make_ushort4(data.x, data.y, data.z, data.w)); 
# 5748
} else { 
# 5749
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5750
__sust_b_1d_array_v4i16_clamp(surfObject, layer, x, make_ushort4(data.x, data.y, data.z, data.w)); 
# 5751
} else { 
# 5752
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5753
__sust_b_1d_array_v4i16_zero(surfObject, layer, x, make_ushort4(data.x, data.y, data.z, data.w)); 
# 5754
}  }  }  
# 5755
} 
#endif
# 5757 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5758
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5768
::exit(___);}
#if 0
# 5758
{ 
# 5759
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5760
__sust_b_1d_array_v4i16_trap(surfObject, layer, x, data); 
# 5761
} else { 
# 5762
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5763
__sust_b_1d_array_v4i16_clamp(surfObject, layer, x, data); 
# 5764
} else { 
# 5765
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5766
__sust_b_1d_array_v4i16_zero(surfObject, layer, x, data); 
# 5767
}  }  }  
# 5768
} 
#endif
# 5770 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5771
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5781
::exit(___);}
#if 0
# 5771
{ 
# 5772
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5773
__sust_b_1d_array_v4i32_trap(surfObject, layer, x, make_uint4(data.x, data.y, data.z, data.w)); 
# 5774
} else { 
# 5775
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5776
__sust_b_1d_array_v4i32_clamp(surfObject, layer, x, make_uint4(data.x, data.y, data.z, data.w)); 
# 5777
} else { 
# 5778
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5779
__sust_b_1d_array_v4i32_zero(surfObject, layer, x, make_uint4(data.x, data.y, data.z, data.w)); 
# 5780
}  }  }  
# 5781
} 
#endif
# 5783 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5784
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5794
::exit(___);}
#if 0
# 5784
{ 
# 5785
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5786
__sust_b_1d_array_v4i32_trap(surfObject, layer, x, data); 
# 5787
} else { 
# 5788
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5789
__sust_b_1d_array_v4i32_clamp(surfObject, layer, x, data); 
# 5790
} else { 
# 5791
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5792
__sust_b_1d_array_v4i32_zero(surfObject, layer, x, data); 
# 5793
}  }  }  
# 5794
} 
#endif
# 5796 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5797
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5810
::exit(___);}
#if 0
# 5797
{ 
# 5798
union { float4 f; uint4 i; } cvt; 
# 5799
(cvt.f) = data; 
# 5801
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5802
__sust_b_1d_array_v4i32_trap(surfObject, layer, x, cvt.i); 
# 5803
} else { 
# 5804
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5805
__sust_b_1d_array_v4i32_clamp(surfObject, layer, x, cvt.i); 
# 5806
} else { 
# 5807
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5808
__sust_b_1d_array_v4i32_zero(surfObject, layer, x, cvt.i); 
# 5809
}  }  }  
# 5810
} 
#endif
# 5818 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5819
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5829
::exit(___);}
#if 0
# 5819
{ 
# 5820
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5821
__sust_b_2d_array_i8_trap(surfObject, layer, x, y, data); 
# 5822
} else { 
# 5823
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5824
__sust_b_2d_array_i8_clamp(surfObject, layer, x, y, data); 
# 5825
} else { 
# 5826
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5827
__sust_b_2d_array_i8_zero(surfObject, layer, x, y, data); 
# 5828
}  }  }  
# 5829
} 
#endif
# 5831 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5832
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5842
::exit(___);}
#if 0
# 5832
{ 
# 5833
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5834
__sust_b_2d_array_i8_trap(surfObject, layer, x, y, data); 
# 5835
} else { 
# 5836
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5837
__sust_b_2d_array_i8_clamp(surfObject, layer, x, y, data); 
# 5838
} else { 
# 5839
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5840
__sust_b_2d_array_i8_zero(surfObject, layer, x, y, data); 
# 5841
}  }  }  
# 5842
} 
#endif
# 5844 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5845
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5855
::exit(___);}
#if 0
# 5845
{ 
# 5846
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5847
__sust_b_2d_array_i8_trap(surfObject, layer, x, y, data.x); 
# 5848
} else { 
# 5849
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5850
__sust_b_2d_array_i8_clamp(surfObject, layer, x, y, data.x); 
# 5851
} else { 
# 5852
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5853
__sust_b_2d_array_i8_zero(surfObject, layer, x, y, data.x); 
# 5854
}  }  }  
# 5855
} 
#endif
# 5857 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5858
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5868
::exit(___);}
#if 0
# 5858
{ 
# 5859
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5860
__sust_b_2d_array_i8_trap(surfObject, layer, x, y, data); 
# 5861
} else { 
# 5862
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5863
__sust_b_2d_array_i8_clamp(surfObject, layer, x, y, data); 
# 5864
} else { 
# 5865
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5866
__sust_b_2d_array_i8_zero(surfObject, layer, x, y, data); 
# 5867
}  }  }  
# 5868
} 
#endif
# 5870 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5871
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5881
::exit(___);}
#if 0
# 5871
{ 
# 5872
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5873
__sust_b_2d_array_i8_trap(surfObject, layer, x, y, data.x); 
# 5874
} else { 
# 5875
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5876
__sust_b_2d_array_i8_clamp(surfObject, layer, x, y, data.x); 
# 5877
} else { 
# 5878
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5879
__sust_b_2d_array_i8_zero(surfObject, layer, x, y, data.x); 
# 5880
}  }  }  
# 5881
} 
#endif
# 5883 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5884
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5894
::exit(___);}
#if 0
# 5884
{ 
# 5885
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5886
__sust_b_2d_array_i16_trap(surfObject, layer, x, y, data); 
# 5887
} else { 
# 5888
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5889
__sust_b_2d_array_i16_clamp(surfObject, layer, x, y, data); 
# 5890
} else { 
# 5891
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5892
__sust_b_2d_array_i16_zero(surfObject, layer, x, y, data); 
# 5893
}  }  }  
# 5894
} 
#endif
# 5896 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5897
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5907
::exit(___);}
#if 0
# 5897
{ 
# 5898
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5899
__sust_b_2d_array_i16_trap(surfObject, layer, x, y, data.x); 
# 5900
} else { 
# 5901
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5902
__sust_b_2d_array_i16_clamp(surfObject, layer, x, y, data.x); 
# 5903
} else { 
# 5904
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5905
__sust_b_2d_array_i16_zero(surfObject, layer, x, y, data.x); 
# 5906
}  }  }  
# 5907
} 
#endif
# 5909 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5910
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5920
::exit(___);}
#if 0
# 5910
{ 
# 5911
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5912
__sust_b_2d_array_i16_trap(surfObject, layer, x, y, data); 
# 5913
} else { 
# 5914
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5915
__sust_b_2d_array_i16_clamp(surfObject, layer, x, y, data); 
# 5916
} else { 
# 5917
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5918
__sust_b_2d_array_i16_zero(surfObject, layer, x, y, data); 
# 5919
}  }  }  
# 5920
} 
#endif
# 5922 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5923
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5933
::exit(___);}
#if 0
# 5923
{ 
# 5924
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5925
__sust_b_2d_array_i16_trap(surfObject, layer, x, y, data.x); 
# 5926
} else { 
# 5927
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5928
__sust_b_2d_array_i16_clamp(surfObject, layer, x, y, data.x); 
# 5929
} else { 
# 5930
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5931
__sust_b_2d_array_i16_zero(surfObject, layer, x, y, data.x); 
# 5932
}  }  }  
# 5933
} 
#endif
# 5935 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5936
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5946
::exit(___);}
#if 0
# 5936
{ 
# 5937
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5938
__sust_b_2d_array_i32_trap(surfObject, layer, x, y, data); 
# 5939
} else { 
# 5940
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5941
__sust_b_2d_array_i32_clamp(surfObject, layer, x, y, data); 
# 5942
} else { 
# 5943
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5944
__sust_b_2d_array_i32_zero(surfObject, layer, x, y, data); 
# 5945
}  }  }  
# 5946
} 
#endif
# 5948 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5949
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5959
::exit(___);}
#if 0
# 5949
{ 
# 5950
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5951
__sust_b_2d_array_i32_trap(surfObject, layer, x, y, data.x); 
# 5952
} else { 
# 5953
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5954
__sust_b_2d_array_i32_clamp(surfObject, layer, x, y, data.x); 
# 5955
} else { 
# 5956
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5957
__sust_b_2d_array_i32_zero(surfObject, layer, x, y, data.x); 
# 5958
}  }  }  
# 5959
} 
#endif
# 5961 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5962
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5972
::exit(___);}
#if 0
# 5962
{ 
# 5963
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5964
__sust_b_2d_array_i32_trap(surfObject, layer, x, y, data); 
# 5965
} else { 
# 5966
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5967
__sust_b_2d_array_i32_clamp(surfObject, layer, x, y, data); 
# 5968
} else { 
# 5969
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5970
__sust_b_2d_array_i32_zero(surfObject, layer, x, y, data); 
# 5971
}  }  }  
# 5972
} 
#endif
# 5974 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5975
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5985
::exit(___);}
#if 0
# 5975
{ 
# 5976
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5977
__sust_b_2d_array_i32_trap(surfObject, layer, x, y, data.x); 
# 5978
} else { 
# 5979
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5980
__sust_b_2d_array_i32_clamp(surfObject, layer, x, y, data.x); 
# 5981
} else { 
# 5982
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5983
__sust_b_2d_array_i32_zero(surfObject, layer, x, y, data.x); 
# 5984
}  }  }  
# 5985
} 
#endif
# 5987 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 5988
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5998
::exit(___);}
#if 0
# 5988
{ 
# 5989
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5990
__sust_b_2d_array_i64_trap(surfObject, layer, x, y, data); 
# 5991
} else { 
# 5992
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5993
__sust_b_2d_array_i64_clamp(surfObject, layer, x, y, data); 
# 5994
} else { 
# 5995
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5996
__sust_b_2d_array_i64_zero(surfObject, layer, x, y, data); 
# 5997
}  }  }  
# 5998
} 
#endif
# 6000 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6001
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6011
::exit(___);}
#if 0
# 6001
{ 
# 6002
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6003
__sust_b_2d_array_i64_trap(surfObject, layer, x, y, data.x); 
# 6004
} else { 
# 6005
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6006
__sust_b_2d_array_i64_clamp(surfObject, layer, x, y, data.x); 
# 6007
} else { 
# 6008
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6009
__sust_b_2d_array_i64_zero(surfObject, layer, x, y, data.x); 
# 6010
}  }  }  
# 6011
} 
#endif
# 6013 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6014
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6024
::exit(___);}
#if 0
# 6014
{ 
# 6015
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6016
__sust_b_2d_array_i64_trap(surfObject, layer, x, y, data); 
# 6017
} else { 
# 6018
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6019
__sust_b_2d_array_i64_clamp(surfObject, layer, x, y, data); 
# 6020
} else { 
# 6021
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6022
__sust_b_2d_array_i64_zero(surfObject, layer, x, y, data); 
# 6023
}  }  }  
# 6024
} 
#endif
# 6026 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6027
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6037
::exit(___);}
#if 0
# 6027
{ 
# 6028
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6029
__sust_b_2d_array_i64_trap(surfObject, layer, x, y, data.x); 
# 6030
} else { 
# 6031
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6032
__sust_b_2d_array_i64_clamp(surfObject, layer, x, y, data.x); 
# 6033
} else { 
# 6034
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6035
__sust_b_2d_array_i64_zero(surfObject, layer, x, y, data.x); 
# 6036
}  }  }  
# 6037
} 
#endif
# 6039 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6040
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6053
::exit(___);}
#if 0
# 6040
{ 
# 6041
union { float f; unsigned i; } cvt; 
# 6042
(cvt.f) = data; 
# 6044
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6045
__sust_b_2d_array_i32_trap(surfObject, layer, x, y, cvt.i); 
# 6046
} else { 
# 6047
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6048
__sust_b_2d_array_i32_clamp(surfObject, layer, x, y, cvt.i); 
# 6049
} else { 
# 6050
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6051
__sust_b_2d_array_i32_zero(surfObject, layer, x, y, cvt.i); 
# 6052
}  }  }  
# 6053
} 
#endif
# 6055 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6056
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6069
::exit(___);}
#if 0
# 6056
{ 
# 6057
union { float f; unsigned i; } cvt; 
# 6058
(cvt.f) = (data.x); 
# 6060
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6061
__sust_b_2d_array_i32_trap(surfObject, layer, x, y, cvt.i); 
# 6062
} else { 
# 6063
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6064
__sust_b_2d_array_i32_clamp(surfObject, layer, x, y, cvt.i); 
# 6065
} else { 
# 6066
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6067
__sust_b_2d_array_i32_zero(surfObject, layer, x, y, cvt.i); 
# 6068
}  }  }  
# 6069
} 
#endif
# 6077 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6078
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6088
::exit(___);}
#if 0
# 6078
{ 
# 6079
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6080
__sust_b_2d_array_v2i8_trap(surfObject, layer, x, y, make_uchar2(data.x, data.y)); 
# 6081
} else { 
# 6082
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6083
__sust_b_2d_array_v2i8_clamp(surfObject, layer, x, y, make_uchar2(data.x, data.y)); 
# 6084
} else { 
# 6085
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6086
__sust_b_2d_array_v2i8_zero(surfObject, layer, x, y, make_uchar2(data.x, data.y)); 
# 6087
}  }  }  
# 6088
} 
#endif
# 6090 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6091
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6101
::exit(___);}
#if 0
# 6091
{ 
# 6092
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6093
__sust_b_2d_array_v2i8_trap(surfObject, layer, x, y, data); 
# 6094
} else { 
# 6095
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6096
__sust_b_2d_array_v2i8_clamp(surfObject, layer, x, y, data); 
# 6097
} else { 
# 6098
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6099
__sust_b_2d_array_v2i8_zero(surfObject, layer, x, y, data); 
# 6100
}  }  }  
# 6101
} 
#endif
# 6103 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6104
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6114
::exit(___);}
#if 0
# 6104
{ 
# 6105
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6106
__sust_b_2d_array_v2i16_trap(surfObject, layer, x, y, make_ushort2(data.x, data.y)); 
# 6107
} else { 
# 6108
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6109
__sust_b_2d_array_v2i16_clamp(surfObject, layer, x, y, make_ushort2(data.x, data.y)); 
# 6110
} else { 
# 6111
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6112
__sust_b_2d_array_v2i16_zero(surfObject, layer, x, y, make_ushort2(data.x, data.y)); 
# 6113
}  }  }  
# 6114
} 
#endif
# 6116 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6117
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6127
::exit(___);}
#if 0
# 6117
{ 
# 6118
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6119
__sust_b_2d_array_v2i16_trap(surfObject, layer, x, y, data); 
# 6120
} else { 
# 6121
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6122
__sust_b_2d_array_v2i16_clamp(surfObject, layer, x, y, data); 
# 6123
} else { 
# 6124
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6125
__sust_b_2d_array_v2i16_zero(surfObject, layer, x, y, data); 
# 6126
}  }  }  
# 6127
} 
#endif
# 6129 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6130
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6140
::exit(___);}
#if 0
# 6130
{ 
# 6131
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6132
__sust_b_2d_array_v2i32_trap(surfObject, layer, x, y, make_uint2(data.x, data.y)); 
# 6133
} else { 
# 6134
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6135
__sust_b_2d_array_v2i32_clamp(surfObject, layer, x, y, make_uint2(data.x, data.y)); 
# 6136
} else { 
# 6137
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6138
__sust_b_2d_array_v2i32_zero(surfObject, layer, x, y, make_uint2(data.x, data.y)); 
# 6139
}  }  }  
# 6140
} 
#endif
# 6142 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6143
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6153
::exit(___);}
#if 0
# 6143
{ 
# 6144
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6145
__sust_b_2d_array_v2i32_trap(surfObject, layer, x, y, data); 
# 6146
} else { 
# 6147
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6148
__sust_b_2d_array_v2i32_clamp(surfObject, layer, x, y, data); 
# 6149
} else { 
# 6150
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6151
__sust_b_2d_array_v2i32_zero(surfObject, layer, x, y, data); 
# 6152
}  }  }  
# 6153
} 
#endif
# 6155 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6156
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6166
::exit(___);}
#if 0
# 6156
{ 
# 6157
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6158
__sust_b_2d_array_v2i64_trap(surfObject, layer, x, y, make_ulonglong2(data.x, data.y)); 
# 6159
} else { 
# 6160
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6161
__sust_b_2d_array_v2i64_clamp(surfObject, layer, x, y, make_ulonglong2(data.x, data.y)); 
# 6162
} else { 
# 6163
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6164
__sust_b_2d_array_v2i64_zero(surfObject, layer, x, y, make_ulonglong2(data.x, data.y)); 
# 6165
}  }  }  
# 6166
} 
#endif
# 6168 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6169
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6179
::exit(___);}
#if 0
# 6169
{ 
# 6170
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6171
__sust_b_2d_array_v2i64_trap(surfObject, layer, x, y, data); 
# 6172
} else { 
# 6173
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6174
__sust_b_2d_array_v2i64_clamp(surfObject, layer, x, y, data); 
# 6175
} else { 
# 6176
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6177
__sust_b_2d_array_v2i64_zero(surfObject, layer, x, y, data); 
# 6178
}  }  }  
# 6179
} 
#endif
# 6181 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6182
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6195
::exit(___);}
#if 0
# 6182
{ 
# 6183
union { float2 f; uint2 i; } cvt; 
# 6184
(cvt.f) = data; 
# 6186
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6187
__sust_b_2d_array_v2i32_trap(surfObject, layer, x, y, cvt.i); 
# 6188
} else { 
# 6189
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6190
__sust_b_2d_array_v2i32_clamp(surfObject, layer, x, y, cvt.i); 
# 6191
} else { 
# 6192
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6193
__sust_b_2d_array_v2i32_zero(surfObject, layer, x, y, cvt.i); 
# 6194
}  }  }  
# 6195
} 
#endif
# 6203 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6204
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6214
::exit(___);}
#if 0
# 6204
{ 
# 6205
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6206
__sust_b_2d_array_v4i8_trap(surfObject, layer, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
# 6207
} else { 
# 6208
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6209
__sust_b_2d_array_v4i8_clamp(surfObject, layer, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
# 6210
} else { 
# 6211
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6212
__sust_b_2d_array_v4i8_zero(surfObject, layer, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
# 6213
}  }  }  
# 6214
} 
#endif
# 6216 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6217
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6227
::exit(___);}
#if 0
# 6217
{ 
# 6218
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6219
__sust_b_2d_array_v4i8_trap(surfObject, layer, x, y, data); 
# 6220
} else { 
# 6221
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6222
__sust_b_2d_array_v4i8_clamp(surfObject, layer, x, y, data); 
# 6223
} else { 
# 6224
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6225
__sust_b_2d_array_v4i8_zero(surfObject, layer, x, y, data); 
# 6226
}  }  }  
# 6227
} 
#endif
# 6229 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6230
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6240
::exit(___);}
#if 0
# 6230
{ 
# 6231
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6232
__sust_b_2d_array_v4i16_trap(surfObject, layer, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
# 6233
} else { 
# 6234
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6235
__sust_b_2d_array_v4i16_clamp(surfObject, layer, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
# 6236
} else { 
# 6237
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6238
__sust_b_2d_array_v4i16_zero(surfObject, layer, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
# 6239
}  }  }  
# 6240
} 
#endif
# 6242 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6243
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6253
::exit(___);}
#if 0
# 6243
{ 
# 6244
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6245
__sust_b_2d_array_v4i16_trap(surfObject, layer, x, y, data); 
# 6246
} else { 
# 6247
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6248
__sust_b_2d_array_v4i16_clamp(surfObject, layer, x, y, data); 
# 6249
} else { 
# 6250
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6251
__sust_b_2d_array_v4i16_zero(surfObject, layer, x, y, data); 
# 6252
}  }  }  
# 6253
} 
#endif
# 6255 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6256
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6266
::exit(___);}
#if 0
# 6256
{ 
# 6257
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6258
__sust_b_2d_array_v4i32_trap(surfObject, layer, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
# 6259
} else { 
# 6260
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6261
__sust_b_2d_array_v4i32_clamp(surfObject, layer, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
# 6262
} else { 
# 6263
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6264
__sust_b_2d_array_v4i32_zero(surfObject, layer, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
# 6265
}  }  }  
# 6266
} 
#endif
# 6268 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6269
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6279
::exit(___);}
#if 0
# 6269
{ 
# 6270
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6271
__sust_b_2d_array_v4i32_trap(surfObject, layer, x, y, data); 
# 6272
} else { 
# 6273
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6274
__sust_b_2d_array_v4i32_clamp(surfObject, layer, x, y, data); 
# 6275
} else { 
# 6276
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6277
__sust_b_2d_array_v4i32_zero(surfObject, layer, x, y, data); 
# 6278
}  }  }  
# 6279
} 
#endif
# 6281 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
# 6282
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6295
::exit(___);}
#if 0
# 6282
{ 
# 6283
union { float4 f; uint4 i; } cvt; 
# 6284
(cvt.f) = data; 
# 6286
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6287
__sust_b_2d_array_v4i32_trap(surfObject, layer, x, y, cvt.i); 
# 6288
} else { 
# 6289
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6290
__sust_b_2d_array_v4i32_clamp(surfObject, layer, x, y, cvt.i); 
# 6291
} else { 
# 6292
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6293
__sust_b_2d_array_v4i32_zero(surfObject, layer, x, y, cvt.i); 
# 6294
}  }  }  
# 6295
} 
#endif
# 6303 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6304
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6314
::exit(___);}
#if 0
# 6304
{ 
# 6305
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6306
__sust_b_2d_array_i8_trap(surfObject, face, x, y, data); 
# 6307
} else { 
# 6308
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6309
__sust_b_2d_array_i8_clamp(surfObject, face, x, y, data); 
# 6310
} else { 
# 6311
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6312
__sust_b_2d_array_i8_zero(surfObject, face, x, y, data); 
# 6313
}  }  }  
# 6314
} 
#endif
# 6316 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6317
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6327
::exit(___);}
#if 0
# 6317
{ 
# 6318
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6319
__sust_b_2d_array_i8_trap(surfObject, face, x, y, data); 
# 6320
} else { 
# 6321
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6322
__sust_b_2d_array_i8_clamp(surfObject, face, x, y, data); 
# 6323
} else { 
# 6324
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6325
__sust_b_2d_array_i8_zero(surfObject, face, x, y, data); 
# 6326
}  }  }  
# 6327
} 
#endif
# 6329 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6330
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6340
::exit(___);}
#if 0
# 6330
{ 
# 6331
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6332
__sust_b_2d_array_i8_trap(surfObject, face, x, y, data.x); 
# 6333
} else { 
# 6334
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6335
__sust_b_2d_array_i8_clamp(surfObject, face, x, y, data.x); 
# 6336
} else { 
# 6337
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6338
__sust_b_2d_array_i8_zero(surfObject, face, x, y, data.x); 
# 6339
}  }  }  
# 6340
} 
#endif
# 6342 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6343
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6353
::exit(___);}
#if 0
# 6343
{ 
# 6344
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6345
__sust_b_2d_array_i8_trap(surfObject, face, x, y, data); 
# 6346
} else { 
# 6347
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6348
__sust_b_2d_array_i8_clamp(surfObject, face, x, y, data); 
# 6349
} else { 
# 6350
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6351
__sust_b_2d_array_i8_zero(surfObject, face, x, y, data); 
# 6352
}  }  }  
# 6353
} 
#endif
# 6355 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6356
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6366
::exit(___);}
#if 0
# 6356
{ 
# 6357
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6358
__sust_b_2d_array_i8_trap(surfObject, face, x, y, data.x); 
# 6359
} else { 
# 6360
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6361
__sust_b_2d_array_i8_clamp(surfObject, face, x, y, data.x); 
# 6362
} else { 
# 6363
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6364
__sust_b_2d_array_i8_zero(surfObject, face, x, y, data.x); 
# 6365
}  }  }  
# 6366
} 
#endif
# 6368 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6369
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6379
::exit(___);}
#if 0
# 6369
{ 
# 6370
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6371
__sust_b_2d_array_i16_trap(surfObject, face, x, y, data); 
# 6372
} else { 
# 6373
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6374
__sust_b_2d_array_i16_clamp(surfObject, face, x, y, data); 
# 6375
} else { 
# 6376
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6377
__sust_b_2d_array_i16_zero(surfObject, face, x, y, data); 
# 6378
}  }  }  
# 6379
} 
#endif
# 6381 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6382
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6392
::exit(___);}
#if 0
# 6382
{ 
# 6383
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6384
__sust_b_2d_array_i16_trap(surfObject, face, x, y, data.x); 
# 6385
} else { 
# 6386
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6387
__sust_b_2d_array_i16_clamp(surfObject, face, x, y, data.x); 
# 6388
} else { 
# 6389
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6390
__sust_b_2d_array_i16_zero(surfObject, face, x, y, data.x); 
# 6391
}  }  }  
# 6392
} 
#endif
# 6394 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6395
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6405
::exit(___);}
#if 0
# 6395
{ 
# 6396
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6397
__sust_b_2d_array_i16_trap(surfObject, face, x, y, data); 
# 6398
} else { 
# 6399
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6400
__sust_b_2d_array_i16_clamp(surfObject, face, x, y, data); 
# 6401
} else { 
# 6402
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6403
__sust_b_2d_array_i16_zero(surfObject, face, x, y, data); 
# 6404
}  }  }  
# 6405
} 
#endif
# 6407 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6408
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6418
::exit(___);}
#if 0
# 6408
{ 
# 6409
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6410
__sust_b_2d_array_i16_trap(surfObject, face, x, y, data.x); 
# 6411
} else { 
# 6412
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6413
__sust_b_2d_array_i16_clamp(surfObject, face, x, y, data.x); 
# 6414
} else { 
# 6415
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6416
__sust_b_2d_array_i16_zero(surfObject, face, x, y, data.x); 
# 6417
}  }  }  
# 6418
} 
#endif
# 6420 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6421
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6431
::exit(___);}
#if 0
# 6421
{ 
# 6422
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6423
__sust_b_2d_array_i32_trap(surfObject, face, x, y, data); 
# 6424
} else { 
# 6425
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6426
__sust_b_2d_array_i32_clamp(surfObject, face, x, y, data); 
# 6427
} else { 
# 6428
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6429
__sust_b_2d_array_i32_zero(surfObject, face, x, y, data); 
# 6430
}  }  }  
# 6431
} 
#endif
# 6433 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6434
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6444
::exit(___);}
#if 0
# 6434
{ 
# 6435
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6436
__sust_b_2d_array_i32_trap(surfObject, face, x, y, data.x); 
# 6437
} else { 
# 6438
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6439
__sust_b_2d_array_i32_clamp(surfObject, face, x, y, data.x); 
# 6440
} else { 
# 6441
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6442
__sust_b_2d_array_i32_zero(surfObject, face, x, y, data.x); 
# 6443
}  }  }  
# 6444
} 
#endif
# 6446 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6447
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6457
::exit(___);}
#if 0
# 6447
{ 
# 6448
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6449
__sust_b_2d_array_i32_trap(surfObject, face, x, y, data); 
# 6450
} else { 
# 6451
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6452
__sust_b_2d_array_i32_clamp(surfObject, face, x, y, data); 
# 6453
} else { 
# 6454
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6455
__sust_b_2d_array_i32_zero(surfObject, face, x, y, data); 
# 6456
}  }  }  
# 6457
} 
#endif
# 6459 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6460
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6470
::exit(___);}
#if 0
# 6460
{ 
# 6461
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6462
__sust_b_2d_array_i32_trap(surfObject, face, x, y, data.x); 
# 6463
} else { 
# 6464
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6465
__sust_b_2d_array_i32_clamp(surfObject, face, x, y, data.x); 
# 6466
} else { 
# 6467
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6468
__sust_b_2d_array_i32_zero(surfObject, face, x, y, data.x); 
# 6469
}  }  }  
# 6470
} 
#endif
# 6472 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6473
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6483
::exit(___);}
#if 0
# 6473
{ 
# 6474
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6475
__sust_b_2d_array_i64_trap(surfObject, face, x, y, data); 
# 6476
} else { 
# 6477
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6478
__sust_b_2d_array_i64_clamp(surfObject, face, x, y, data); 
# 6479
} else { 
# 6480
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6481
__sust_b_2d_array_i64_zero(surfObject, face, x, y, data); 
# 6482
}  }  }  
# 6483
} 
#endif
# 6485 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6486
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6496
::exit(___);}
#if 0
# 6486
{ 
# 6487
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6488
__sust_b_2d_array_i64_trap(surfObject, face, x, y, data.x); 
# 6489
} else { 
# 6490
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6491
__sust_b_2d_array_i64_clamp(surfObject, face, x, y, data.x); 
# 6492
} else { 
# 6493
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6494
__sust_b_2d_array_i64_zero(surfObject, face, x, y, data.x); 
# 6495
}  }  }  
# 6496
} 
#endif
# 6498 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6499
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6509
::exit(___);}
#if 0
# 6499
{ 
# 6500
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6501
__sust_b_2d_array_i64_trap(surfObject, face, x, y, data); 
# 6502
} else { 
# 6503
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6504
__sust_b_2d_array_i64_clamp(surfObject, face, x, y, data); 
# 6505
} else { 
# 6506
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6507
__sust_b_2d_array_i64_zero(surfObject, face, x, y, data); 
# 6508
}  }  }  
# 6509
} 
#endif
# 6511 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6512
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6522
::exit(___);}
#if 0
# 6512
{ 
# 6513
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6514
__sust_b_2d_array_i64_trap(surfObject, face, x, y, data.x); 
# 6515
} else { 
# 6516
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6517
__sust_b_2d_array_i64_clamp(surfObject, face, x, y, data.x); 
# 6518
} else { 
# 6519
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6520
__sust_b_2d_array_i64_zero(surfObject, face, x, y, data.x); 
# 6521
}  }  }  
# 6522
} 
#endif
# 6524 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6525
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6538
::exit(___);}
#if 0
# 6525
{ 
# 6526
union { float f; unsigned i; } cvt; 
# 6527
(cvt.f) = data; 
# 6529
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6530
__sust_b_2d_array_i32_trap(surfObject, face, x, y, cvt.i); 
# 6531
} else { 
# 6532
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6533
__sust_b_2d_array_i32_clamp(surfObject, face, x, y, cvt.i); 
# 6534
} else { 
# 6535
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6536
__sust_b_2d_array_i32_zero(surfObject, face, x, y, cvt.i); 
# 6537
}  }  }  
# 6538
} 
#endif
# 6540 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6541
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6554
::exit(___);}
#if 0
# 6541
{ 
# 6542
union { float f; unsigned i; } cvt; 
# 6543
(cvt.f) = (data.x); 
# 6545
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6546
__sust_b_2d_array_i32_trap(surfObject, face, x, y, cvt.i); 
# 6547
} else { 
# 6548
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6549
__sust_b_2d_array_i32_clamp(surfObject, face, x, y, cvt.i); 
# 6550
} else { 
# 6551
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6552
__sust_b_2d_array_i32_zero(surfObject, face, x, y, cvt.i); 
# 6553
}  }  }  
# 6554
} 
#endif
# 6562 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6563
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6573
::exit(___);}
#if 0
# 6563
{ 
# 6564
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6565
__sust_b_2d_array_v2i8_trap(surfObject, face, x, y, make_uchar2(data.x, data.y)); 
# 6566
} else { 
# 6567
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6568
__sust_b_2d_array_v2i8_clamp(surfObject, face, x, y, make_uchar2(data.x, data.y)); 
# 6569
} else { 
# 6570
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6571
__sust_b_2d_array_v2i8_zero(surfObject, face, x, y, make_uchar2(data.x, data.y)); 
# 6572
}  }  }  
# 6573
} 
#endif
# 6575 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6576
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6586
::exit(___);}
#if 0
# 6576
{ 
# 6577
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6578
__sust_b_2d_array_v2i8_trap(surfObject, face, x, y, data); 
# 6579
} else { 
# 6580
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6581
__sust_b_2d_array_v2i8_clamp(surfObject, face, x, y, data); 
# 6582
} else { 
# 6583
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6584
__sust_b_2d_array_v2i8_zero(surfObject, face, x, y, data); 
# 6585
}  }  }  
# 6586
} 
#endif
# 6588 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6589
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6599
::exit(___);}
#if 0
# 6589
{ 
# 6590
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6591
__sust_b_2d_array_v2i16_trap(surfObject, face, x, y, make_ushort2(data.x, data.y)); 
# 6592
} else { 
# 6593
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6594
__sust_b_2d_array_v2i16_clamp(surfObject, face, x, y, make_ushort2(data.x, data.y)); 
# 6595
} else { 
# 6596
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6597
__sust_b_2d_array_v2i16_zero(surfObject, face, x, y, make_ushort2(data.x, data.y)); 
# 6598
}  }  }  
# 6599
} 
#endif
# 6601 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6602
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6612
::exit(___);}
#if 0
# 6602
{ 
# 6603
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6604
__sust_b_2d_array_v2i16_trap(surfObject, face, x, y, data); 
# 6605
} else { 
# 6606
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6607
__sust_b_2d_array_v2i16_clamp(surfObject, face, x, y, data); 
# 6608
} else { 
# 6609
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6610
__sust_b_2d_array_v2i16_zero(surfObject, face, x, y, data); 
# 6611
}  }  }  
# 6612
} 
#endif
# 6614 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6615
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6625
::exit(___);}
#if 0
# 6615
{ 
# 6616
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6617
__sust_b_2d_array_v2i32_trap(surfObject, face, x, y, make_uint2(data.x, data.y)); 
# 6618
} else { 
# 6619
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6620
__sust_b_2d_array_v2i32_clamp(surfObject, face, x, y, make_uint2(data.x, data.y)); 
# 6621
} else { 
# 6622
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6623
__sust_b_2d_array_v2i32_zero(surfObject, face, x, y, make_uint2(data.x, data.y)); 
# 6624
}  }  }  
# 6625
} 
#endif
# 6627 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6628
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6638
::exit(___);}
#if 0
# 6628
{ 
# 6629
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6630
__sust_b_2d_array_v2i32_trap(surfObject, face, x, y, data); 
# 6631
} else { 
# 6632
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6633
__sust_b_2d_array_v2i32_clamp(surfObject, face, x, y, data); 
# 6634
} else { 
# 6635
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6636
__sust_b_2d_array_v2i32_zero(surfObject, face, x, y, data); 
# 6637
}  }  }  
# 6638
} 
#endif
# 6640 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6641
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6651
::exit(___);}
#if 0
# 6641
{ 
# 6642
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6643
__sust_b_2d_array_v2i64_trap(surfObject, face, x, y, make_ulonglong2(data.x, data.y)); 
# 6644
} else { 
# 6645
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6646
__sust_b_2d_array_v2i64_clamp(surfObject, face, x, y, make_ulonglong2(data.x, data.y)); 
# 6647
} else { 
# 6648
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6649
__sust_b_2d_array_v2i64_zero(surfObject, face, x, y, make_ulonglong2(data.x, data.y)); 
# 6650
}  }  }  
# 6651
} 
#endif
# 6653 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6654
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6664
::exit(___);}
#if 0
# 6654
{ 
# 6655
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6656
__sust_b_2d_array_v2i64_trap(surfObject, face, x, y, data); 
# 6657
} else { 
# 6658
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6659
__sust_b_2d_array_v2i64_clamp(surfObject, face, x, y, data); 
# 6660
} else { 
# 6661
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6662
__sust_b_2d_array_v2i64_zero(surfObject, face, x, y, data); 
# 6663
}  }  }  
# 6664
} 
#endif
# 6666 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6667
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6680
::exit(___);}
#if 0
# 6667
{ 
# 6668
union { float2 f; uint2 i; } cvt; 
# 6669
(cvt.f) = data; 
# 6671
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6672
__sust_b_2d_array_v2i32_trap(surfObject, face, x, y, cvt.i); 
# 6673
} else { 
# 6674
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6675
__sust_b_2d_array_v2i32_clamp(surfObject, face, x, y, cvt.i); 
# 6676
} else { 
# 6677
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6678
__sust_b_2d_array_v2i32_zero(surfObject, face, x, y, cvt.i); 
# 6679
}  }  }  
# 6680
} 
#endif
# 6688 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6689
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6699
::exit(___);}
#if 0
# 6689
{ 
# 6690
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6691
__sust_b_2d_array_v4i8_trap(surfObject, face, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
# 6692
} else { 
# 6693
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6694
__sust_b_2d_array_v4i8_clamp(surfObject, face, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
# 6695
} else { 
# 6696
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6697
__sust_b_2d_array_v4i8_zero(surfObject, face, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
# 6698
}  }  }  
# 6699
} 
#endif
# 6701 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6702
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6712
::exit(___);}
#if 0
# 6702
{ 
# 6703
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6704
__sust_b_2d_array_v4i8_trap(surfObject, face, x, y, data); 
# 6705
} else { 
# 6706
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6707
__sust_b_2d_array_v4i8_clamp(surfObject, face, x, y, data); 
# 6708
} else { 
# 6709
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6710
__sust_b_2d_array_v4i8_zero(surfObject, face, x, y, data); 
# 6711
}  }  }  
# 6712
} 
#endif
# 6714 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6715
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6725
::exit(___);}
#if 0
# 6715
{ 
# 6716
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6717
__sust_b_2d_array_v4i16_trap(surfObject, face, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
# 6718
} else { 
# 6719
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6720
__sust_b_2d_array_v4i16_clamp(surfObject, face, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
# 6721
} else { 
# 6722
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6723
__sust_b_2d_array_v4i16_zero(surfObject, face, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
# 6724
}  }  }  
# 6725
} 
#endif
# 6727 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6728
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6738
::exit(___);}
#if 0
# 6728
{ 
# 6729
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6730
__sust_b_2d_array_v4i16_trap(surfObject, face, x, y, data); 
# 6731
} else { 
# 6732
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6733
__sust_b_2d_array_v4i16_clamp(surfObject, face, x, y, data); 
# 6734
} else { 
# 6735
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6736
__sust_b_2d_array_v4i16_zero(surfObject, face, x, y, data); 
# 6737
}  }  }  
# 6738
} 
#endif
# 6740 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6741
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6751
::exit(___);}
#if 0
# 6741
{ 
# 6742
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6743
__sust_b_2d_array_v4i32_trap(surfObject, face, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
# 6744
} else { 
# 6745
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6746
__sust_b_2d_array_v4i32_clamp(surfObject, face, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
# 6747
} else { 
# 6748
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6749
__sust_b_2d_array_v4i32_zero(surfObject, face, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
# 6750
}  }  }  
# 6751
} 
#endif
# 6753 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6754
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6764
::exit(___);}
#if 0
# 6754
{ 
# 6755
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6756
__sust_b_2d_array_v4i32_trap(surfObject, face, x, y, data); 
# 6757
} else { 
# 6758
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6759
__sust_b_2d_array_v4i32_clamp(surfObject, face, x, y, data); 
# 6760
} else { 
# 6761
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6762
__sust_b_2d_array_v4i32_zero(surfObject, face, x, y, data); 
# 6763
}  }  }  
# 6764
} 
#endif
# 6766 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
# 6767
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6780
::exit(___);}
#if 0
# 6767
{ 
# 6768
union { float4 f; uint4 i; } cvt; 
# 6769
(cvt.f) = data; 
# 6771
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6772
__sust_b_2d_array_v4i32_trap(surfObject, face, x, y, cvt.i); 
# 6773
} else { 
# 6774
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6775
__sust_b_2d_array_v4i32_clamp(surfObject, face, x, y, cvt.i); 
# 6776
} else { 
# 6777
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6778
__sust_b_2d_array_v4i32_zero(surfObject, face, x, y, cvt.i); 
# 6779
}  }  }  
# 6780
} 
#endif
# 6788 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6789
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6799
::exit(___);}
#if 0
# 6789
{ 
# 6790
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6791
__sust_b_2d_array_i8_trap(surfObject, layerface, x, y, data); 
# 6792
} else { 
# 6793
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6794
__sust_b_2d_array_i8_clamp(surfObject, layerface, x, y, data); 
# 6795
} else { 
# 6796
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6797
__sust_b_2d_array_i8_zero(surfObject, layerface, x, y, data); 
# 6798
}  }  }  
# 6799
} 
#endif
# 6801 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6802
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6812
::exit(___);}
#if 0
# 6802
{ 
# 6803
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6804
__sust_b_2d_array_i8_trap(surfObject, layerface, x, y, data); 
# 6805
} else { 
# 6806
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6807
__sust_b_2d_array_i8_clamp(surfObject, layerface, x, y, data); 
# 6808
} else { 
# 6809
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6810
__sust_b_2d_array_i8_zero(surfObject, layerface, x, y, data); 
# 6811
}  }  }  
# 6812
} 
#endif
# 6814 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6815
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6825
::exit(___);}
#if 0
# 6815
{ 
# 6816
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6817
__sust_b_2d_array_i8_trap(surfObject, layerface, x, y, data.x); 
# 6818
} else { 
# 6819
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6820
__sust_b_2d_array_i8_clamp(surfObject, layerface, x, y, data.x); 
# 6821
} else { 
# 6822
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6823
__sust_b_2d_array_i8_zero(surfObject, layerface, x, y, data.x); 
# 6824
}  }  }  
# 6825
} 
#endif
# 6827 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6828
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6838
::exit(___);}
#if 0
# 6828
{ 
# 6829
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6830
__sust_b_2d_array_i8_trap(surfObject, layerface, x, y, data); 
# 6831
} else { 
# 6832
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6833
__sust_b_2d_array_i8_clamp(surfObject, layerface, x, y, data); 
# 6834
} else { 
# 6835
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6836
__sust_b_2d_array_i8_zero(surfObject, layerface, x, y, data); 
# 6837
}  }  }  
# 6838
} 
#endif
# 6840 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6841
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6851
::exit(___);}
#if 0
# 6841
{ 
# 6842
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6843
__sust_b_2d_array_i8_trap(surfObject, layerface, x, y, data.x); 
# 6844
} else { 
# 6845
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6846
__sust_b_2d_array_i8_clamp(surfObject, layerface, x, y, data.x); 
# 6847
} else { 
# 6848
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6849
__sust_b_2d_array_i8_zero(surfObject, layerface, x, y, data.x); 
# 6850
}  }  }  
# 6851
} 
#endif
# 6853 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6854
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6864
::exit(___);}
#if 0
# 6854
{ 
# 6855
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6856
__sust_b_2d_array_i16_trap(surfObject, layerface, x, y, data); 
# 6857
} else { 
# 6858
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6859
__sust_b_2d_array_i16_clamp(surfObject, layerface, x, y, data); 
# 6860
} else { 
# 6861
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6862
__sust_b_2d_array_i16_zero(surfObject, layerface, x, y, data); 
# 6863
}  }  }  
# 6864
} 
#endif
# 6866 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6867
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6877
::exit(___);}
#if 0
# 6867
{ 
# 6868
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6869
__sust_b_2d_array_i16_trap(surfObject, layerface, x, y, data.x); 
# 6870
} else { 
# 6871
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6872
__sust_b_2d_array_i16_clamp(surfObject, layerface, x, y, data.x); 
# 6873
} else { 
# 6874
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6875
__sust_b_2d_array_i16_zero(surfObject, layerface, x, y, data.x); 
# 6876
}  }  }  
# 6877
} 
#endif
# 6879 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6880
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6890
::exit(___);}
#if 0
# 6880
{ 
# 6881
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6882
__sust_b_2d_array_i16_trap(surfObject, layerface, x, y, data); 
# 6883
} else { 
# 6884
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6885
__sust_b_2d_array_i16_clamp(surfObject, layerface, x, y, data); 
# 6886
} else { 
# 6887
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6888
__sust_b_2d_array_i16_zero(surfObject, layerface, x, y, data); 
# 6889
}  }  }  
# 6890
} 
#endif
# 6892 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6893
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6903
::exit(___);}
#if 0
# 6893
{ 
# 6894
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6895
__sust_b_2d_array_i16_trap(surfObject, layerface, x, y, data.x); 
# 6896
} else { 
# 6897
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6898
__sust_b_2d_array_i16_clamp(surfObject, layerface, x, y, data.x); 
# 6899
} else { 
# 6900
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6901
__sust_b_2d_array_i16_zero(surfObject, layerface, x, y, data.x); 
# 6902
}  }  }  
# 6903
} 
#endif
# 6905 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6906
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6916
::exit(___);}
#if 0
# 6906
{ 
# 6907
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6908
__sust_b_2d_array_i32_trap(surfObject, layerface, x, y, data); 
# 6909
} else { 
# 6910
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6911
__sust_b_2d_array_i32_clamp(surfObject, layerface, x, y, data); 
# 6912
} else { 
# 6913
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6914
__sust_b_2d_array_i32_zero(surfObject, layerface, x, y, data); 
# 6915
}  }  }  
# 6916
} 
#endif
# 6918 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6919
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6929
::exit(___);}
#if 0
# 6919
{ 
# 6920
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6921
__sust_b_2d_array_i32_trap(surfObject, layerface, x, y, data.x); 
# 6922
} else { 
# 6923
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6924
__sust_b_2d_array_i32_clamp(surfObject, layerface, x, y, data.x); 
# 6925
} else { 
# 6926
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6927
__sust_b_2d_array_i32_zero(surfObject, layerface, x, y, data.x); 
# 6928
}  }  }  
# 6929
} 
#endif
# 6931 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6932
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6942
::exit(___);}
#if 0
# 6932
{ 
# 6933
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6934
__sust_b_2d_array_i32_trap(surfObject, layerface, x, y, data); 
# 6935
} else { 
# 6936
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6937
__sust_b_2d_array_i32_clamp(surfObject, layerface, x, y, data); 
# 6938
} else { 
# 6939
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6940
__sust_b_2d_array_i32_zero(surfObject, layerface, x, y, data); 
# 6941
}  }  }  
# 6942
} 
#endif
# 6944 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6945
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6955
::exit(___);}
#if 0
# 6945
{ 
# 6946
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6947
__sust_b_2d_array_i32_trap(surfObject, layerface, x, y, data.x); 
# 6948
} else { 
# 6949
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6950
__sust_b_2d_array_i32_clamp(surfObject, layerface, x, y, data.x); 
# 6951
} else { 
# 6952
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6953
__sust_b_2d_array_i32_zero(surfObject, layerface, x, y, data.x); 
# 6954
}  }  }  
# 6955
} 
#endif
# 6957 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6958
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6968
::exit(___);}
#if 0
# 6958
{ 
# 6959
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6960
__sust_b_2d_array_i64_trap(surfObject, layerface, x, y, data); 
# 6961
} else { 
# 6962
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6963
__sust_b_2d_array_i64_clamp(surfObject, layerface, x, y, data); 
# 6964
} else { 
# 6965
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6966
__sust_b_2d_array_i64_zero(surfObject, layerface, x, y, data); 
# 6967
}  }  }  
# 6968
} 
#endif
# 6970 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6971
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6981
::exit(___);}
#if 0
# 6971
{ 
# 6972
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6973
__sust_b_2d_array_i64_trap(surfObject, layerface, x, y, data.x); 
# 6974
} else { 
# 6975
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6976
__sust_b_2d_array_i64_clamp(surfObject, layerface, x, y, data.x); 
# 6977
} else { 
# 6978
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6979
__sust_b_2d_array_i64_zero(surfObject, layerface, x, y, data.x); 
# 6980
}  }  }  
# 6981
} 
#endif
# 6983 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6984
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 6994
::exit(___);}
#if 0
# 6984
{ 
# 6985
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6986
__sust_b_2d_array_i64_trap(surfObject, layerface, x, y, data); 
# 6987
} else { 
# 6988
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6989
__sust_b_2d_array_i64_clamp(surfObject, layerface, x, y, data); 
# 6990
} else { 
# 6991
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6992
__sust_b_2d_array_i64_zero(surfObject, layerface, x, y, data); 
# 6993
}  }  }  
# 6994
} 
#endif
# 6996 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 6997
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7007
::exit(___);}
#if 0
# 6997
{ 
# 6998
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6999
__sust_b_2d_array_i64_trap(surfObject, layerface, x, y, data.x); 
# 7000
} else { 
# 7001
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7002
__sust_b_2d_array_i64_clamp(surfObject, layerface, x, y, data.x); 
# 7003
} else { 
# 7004
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7005
__sust_b_2d_array_i64_zero(surfObject, layerface, x, y, data.x); 
# 7006
}  }  }  
# 7007
} 
#endif
# 7009 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7010
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7023
::exit(___);}
#if 0
# 7010
{ 
# 7011
union { float f; unsigned i; } cvt; 
# 7012
(cvt.f) = data; 
# 7014
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7015
__sust_b_2d_array_i32_trap(surfObject, layerface, x, y, cvt.i); 
# 7016
} else { 
# 7017
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7018
__sust_b_2d_array_i32_clamp(surfObject, layerface, x, y, cvt.i); 
# 7019
} else { 
# 7020
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7021
__sust_b_2d_array_i32_zero(surfObject, layerface, x, y, cvt.i); 
# 7022
}  }  }  
# 7023
} 
#endif
# 7025 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7026
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7039
::exit(___);}
#if 0
# 7026
{ 
# 7027
union { float f; unsigned i; } cvt; 
# 7028
(cvt.f) = (data.x); 
# 7030
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7031
__sust_b_2d_array_i32_trap(surfObject, layerface, x, y, cvt.i); 
# 7032
} else { 
# 7033
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7034
__sust_b_2d_array_i32_clamp(surfObject, layerface, x, y, cvt.i); 
# 7035
} else { 
# 7036
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7037
__sust_b_2d_array_i32_zero(surfObject, layerface, x, y, cvt.i); 
# 7038
}  }  }  
# 7039
} 
#endif
# 7047 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7048
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7058
::exit(___);}
#if 0
# 7048
{ 
# 7049
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7050
__sust_b_2d_array_v2i8_trap(surfObject, layerface, x, y, make_uchar2(data.x, data.y)); 
# 7051
} else { 
# 7052
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7053
__sust_b_2d_array_v2i8_clamp(surfObject, layerface, x, y, make_uchar2(data.x, data.y)); 
# 7054
} else { 
# 7055
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7056
__sust_b_2d_array_v2i8_zero(surfObject, layerface, x, y, make_uchar2(data.x, data.y)); 
# 7057
}  }  }  
# 7058
} 
#endif
# 7060 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7061
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7071
::exit(___);}
#if 0
# 7061
{ 
# 7062
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7063
__sust_b_2d_array_v2i8_trap(surfObject, layerface, x, y, data); 
# 7064
} else { 
# 7065
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7066
__sust_b_2d_array_v2i8_clamp(surfObject, layerface, x, y, data); 
# 7067
} else { 
# 7068
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7069
__sust_b_2d_array_v2i8_zero(surfObject, layerface, x, y, data); 
# 7070
}  }  }  
# 7071
} 
#endif
# 7073 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7074
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7084
::exit(___);}
#if 0
# 7074
{ 
# 7075
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7076
__sust_b_2d_array_v2i16_trap(surfObject, layerface, x, y, make_ushort2(data.x, data.y)); 
# 7077
} else { 
# 7078
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7079
__sust_b_2d_array_v2i16_clamp(surfObject, layerface, x, y, make_ushort2(data.x, data.y)); 
# 7080
} else { 
# 7081
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7082
__sust_b_2d_array_v2i16_zero(surfObject, layerface, x, y, make_ushort2(data.x, data.y)); 
# 7083
}  }  }  
# 7084
} 
#endif
# 7086 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7087
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7097
::exit(___);}
#if 0
# 7087
{ 
# 7088
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7089
__sust_b_2d_array_v2i16_trap(surfObject, layerface, x, y, data); 
# 7090
} else { 
# 7091
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7092
__sust_b_2d_array_v2i16_clamp(surfObject, layerface, x, y, data); 
# 7093
} else { 
# 7094
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7095
__sust_b_2d_array_v2i16_zero(surfObject, layerface, x, y, data); 
# 7096
}  }  }  
# 7097
} 
#endif
# 7099 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7100
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7110
::exit(___);}
#if 0
# 7100
{ 
# 7101
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7102
__sust_b_2d_array_v2i32_trap(surfObject, layerface, x, y, make_uint2(data.x, data.y)); 
# 7103
} else { 
# 7104
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7105
__sust_b_2d_array_v2i32_clamp(surfObject, layerface, x, y, make_uint2(data.x, data.y)); 
# 7106
} else { 
# 7107
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7108
__sust_b_2d_array_v2i32_zero(surfObject, layerface, x, y, make_uint2(data.x, data.y)); 
# 7109
}  }  }  
# 7110
} 
#endif
# 7112 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7113
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7123
::exit(___);}
#if 0
# 7113
{ 
# 7114
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7115
__sust_b_2d_array_v2i32_trap(surfObject, layerface, x, y, data); 
# 7116
} else { 
# 7117
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7118
__sust_b_2d_array_v2i32_clamp(surfObject, layerface, x, y, data); 
# 7119
} else { 
# 7120
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7121
__sust_b_2d_array_v2i32_zero(surfObject, layerface, x, y, data); 
# 7122
}  }  }  
# 7123
} 
#endif
# 7125 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7126
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7136
::exit(___);}
#if 0
# 7126
{ 
# 7127
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7128
__sust_b_2d_array_v2i64_trap(surfObject, layerface, x, y, make_ulonglong2(data.x, data.y)); 
# 7129
} else { 
# 7130
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7131
__sust_b_2d_array_v2i64_clamp(surfObject, layerface, x, y, make_ulonglong2(data.x, data.y)); 
# 7132
} else { 
# 7133
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7134
__sust_b_2d_array_v2i64_zero(surfObject, layerface, x, y, make_ulonglong2(data.x, data.y)); 
# 7135
}  }  }  
# 7136
} 
#endif
# 7138 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7139
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7149
::exit(___);}
#if 0
# 7139
{ 
# 7140
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7141
__sust_b_2d_array_v2i64_trap(surfObject, layerface, x, y, data); 
# 7142
} else { 
# 7143
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7144
__sust_b_2d_array_v2i64_clamp(surfObject, layerface, x, y, data); 
# 7145
} else { 
# 7146
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7147
__sust_b_2d_array_v2i64_zero(surfObject, layerface, x, y, data); 
# 7148
}  }  }  
# 7149
} 
#endif
# 7151 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7152
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7165
::exit(___);}
#if 0
# 7152
{ 
# 7153
union { float2 f; uint2 i; } cvt; 
# 7154
(cvt.f) = data; 
# 7156
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7157
__sust_b_2d_array_v2i32_trap(surfObject, layerface, x, y, cvt.i); 
# 7158
} else { 
# 7159
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7160
__sust_b_2d_array_v2i32_clamp(surfObject, layerface, x, y, cvt.i); 
# 7161
} else { 
# 7162
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7163
__sust_b_2d_array_v2i32_zero(surfObject, layerface, x, y, cvt.i); 
# 7164
}  }  }  
# 7165
} 
#endif
# 7173 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7174
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7184
::exit(___);}
#if 0
# 7174
{ 
# 7175
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7176
__sust_b_2d_array_v4i8_trap(surfObject, layerface, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
# 7177
} else { 
# 7178
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7179
__sust_b_2d_array_v4i8_clamp(surfObject, layerface, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
# 7180
} else { 
# 7181
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7182
__sust_b_2d_array_v4i8_zero(surfObject, layerface, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
# 7183
}  }  }  
# 7184
} 
#endif
# 7186 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7187
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7197
::exit(___);}
#if 0
# 7187
{ 
# 7188
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7189
__sust_b_2d_array_v4i8_trap(surfObject, layerface, x, y, data); 
# 7190
} else { 
# 7191
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7192
__sust_b_2d_array_v4i8_clamp(surfObject, layerface, x, y, data); 
# 7193
} else { 
# 7194
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7195
__sust_b_2d_array_v4i8_zero(surfObject, layerface, x, y, data); 
# 7196
}  }  }  
# 7197
} 
#endif
# 7199 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7200
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7210
::exit(___);}
#if 0
# 7200
{ 
# 7201
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7202
__sust_b_2d_array_v4i16_trap(surfObject, layerface, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
# 7203
} else { 
# 7204
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7205
__sust_b_2d_array_v4i16_clamp(surfObject, layerface, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
# 7206
} else { 
# 7207
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7208
__sust_b_2d_array_v4i16_zero(surfObject, layerface, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
# 7209
}  }  }  
# 7210
} 
#endif
# 7212 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7213
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7223
::exit(___);}
#if 0
# 7213
{ 
# 7214
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7215
__sust_b_2d_array_v4i16_trap(surfObject, layerface, x, y, data); 
# 7216
} else { 
# 7217
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7218
__sust_b_2d_array_v4i16_clamp(surfObject, layerface, x, y, data); 
# 7219
} else { 
# 7220
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7221
__sust_b_2d_array_v4i16_zero(surfObject, layerface, x, y, data); 
# 7222
}  }  }  
# 7223
} 
#endif
# 7225 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7226
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7236
::exit(___);}
#if 0
# 7226
{ 
# 7227
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7228
__sust_b_2d_array_v4i32_trap(surfObject, layerface, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
# 7229
} else { 
# 7230
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7231
__sust_b_2d_array_v4i32_clamp(surfObject, layerface, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
# 7232
} else { 
# 7233
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7234
__sust_b_2d_array_v4i32_zero(surfObject, layerface, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
# 7235
}  }  }  
# 7236
} 
#endif
# 7238 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7239
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7249
::exit(___);}
#if 0
# 7239
{ 
# 7240
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7241
__sust_b_2d_array_v4i32_trap(surfObject, layerface, x, y, data); 
# 7242
} else { 
# 7243
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7244
__sust_b_2d_array_v4i32_clamp(surfObject, layerface, x, y, data); 
# 7245
} else { 
# 7246
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7247
__sust_b_2d_array_v4i32_zero(surfObject, layerface, x, y, data); 
# 7248
}  }  }  
# 7249
} 
#endif
# 7251 "/usr/include/surface_indirect_functions.hpp" 3
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
# 7252
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 7265
::exit(___);}
#if 0
# 7252
{ 
# 7253
union { float4 f; uint4 i; } cvt; 
# 7254
(cvt.f) = data; 
# 7256
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7257
__sust_b_2d_array_v4i32_trap(surfObject, layerface, x, y, cvt.i); 
# 7258
} else { 
# 7259
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7260
__sust_b_2d_array_v4i32_clamp(surfObject, layerface, x, y, cvt.i); 
# 7261
} else { 
# 7262
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7263
__sust_b_2d_array_v4i32_zero(surfObject, layerface, x, y, cvt.i); 
# 7264
}  }  }  
# 7265
} 
#endif
# 71 "/usr/include/device_launch_parameters.h" 3
extern "C" { extern const uint3 __device_builtin_variable_threadIdx; } 
# 72
extern "C" { extern const uint3 __device_builtin_variable_blockIdx; } 
# 73
extern "C" { extern const dim3 __device_builtin_variable_blockDim; } 
# 74
extern "C" { extern const dim3 __device_builtin_variable_gridDim; } 
# 75
extern "C" { extern const int __device_builtin_variable_warpSize; } 
# 172 "/usr/include/cuda_runtime.h" 3
template< class T> static inline cudaError_t 
# 173
cudaLaunchKernel(const T *
# 174
func, dim3 
# 175
gridDim, dim3 
# 176
blockDim, void **
# 177
args, size_t 
# 178
sharedMem = 0, cudaStream_t 
# 179
stream = 0) 
# 181
{ 
# 182
return ::cudaLaunchKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream); 
# 183
} 
# 210 "/usr/include/cuda_runtime.h" 3
template< class T> static inline cudaError_t 
# 211
cudaSetupArgument(T 
# 212
arg, size_t 
# 213
offset) 
# 215
{ 
# 216
return ::cudaSetupArgument((const void *)(&arg), sizeof(T), offset); 
# 217
} 
# 249 "/usr/include/cuda_runtime.h" 3
static inline cudaError_t cudaEventCreate(cudaEvent_t *
# 250
event, unsigned 
# 251
flags) 
# 253
{ 
# 254
return ::cudaEventCreateWithFlags(event, flags); 
# 255
} 
# 312 "/usr/include/cuda_runtime.h" 3
static inline cudaError_t cudaMallocHost(void **
# 313
ptr, size_t 
# 314
size, unsigned 
# 315
flags) 
# 317
{ 
# 318
return ::cudaHostAlloc(ptr, size, flags); 
# 319
} 
# 321
template< class T> static inline cudaError_t 
# 322
cudaHostAlloc(T **
# 323
ptr, size_t 
# 324
size, unsigned 
# 325
flags) 
# 327
{ 
# 328
return ::cudaHostAlloc((void **)((void *)ptr), size, flags); 
# 329
} 
# 331
template< class T> static inline cudaError_t 
# 332
cudaHostGetDevicePointer(T **
# 333
pDevice, void *
# 334
pHost, unsigned 
# 335
flags) 
# 337
{ 
# 338
return ::cudaHostGetDevicePointer((void **)((void *)pDevice), pHost, flags); 
# 339
} 
# 410 "/usr/include/cuda_runtime.h" 3
template< class T> static inline cudaError_t 
# 411
cudaMallocManaged(T **
# 412
devPtr, size_t 
# 413
size, unsigned 
# 414
flags = 1) 
# 416
{ 
# 417
return ::cudaMallocManaged((void **)((void *)devPtr), size, flags); 
# 418
} 
# 486 "/usr/include/cuda_runtime.h" 3
template< class T> static inline cudaError_t 
# 487
cudaStreamAttachMemAsync(cudaStream_t 
# 488
stream, T *
# 489
devPtr, size_t 
# 490
length = 0, unsigned 
# 491
flags = 4) 
# 493
{ 
# 494
return ::cudaStreamAttachMemAsync(stream, (void *)devPtr, length, flags); 
# 495
} 
# 497
template< class T> inline cudaError_t 
# 498
cudaMalloc(T **
# 499
devPtr, size_t 
# 500
size) 
# 502
{ 
# 503
return ::cudaMalloc((void **)((void *)devPtr), size); 
# 504
} 
# 506
template< class T> static inline cudaError_t 
# 507
cudaMallocHost(T **
# 508
ptr, size_t 
# 509
size, unsigned 
# 510
flags = 0) 
# 512
{ 
# 513
return cudaMallocHost((void **)((void *)ptr), size, flags); 
# 514
} 
# 516
template< class T> static inline cudaError_t 
# 517
cudaMallocPitch(T **
# 518
devPtr, size_t *
# 519
pitch, size_t 
# 520
width, size_t 
# 521
height) 
# 523
{ 
# 524
return ::cudaMallocPitch((void **)((void *)devPtr), pitch, width, height); 
# 525
} 
# 562 "/usr/include/cuda_runtime.h" 3
template< class T> static inline cudaError_t 
# 563
cudaMemcpyToSymbol(const T &
# 564
symbol, const void *
# 565
src, size_t 
# 566
count, size_t 
# 567
offset = 0, cudaMemcpyKind 
# 568
kind = cudaMemcpyHostToDevice) 
# 570
{ 
# 571
return ::cudaMemcpyToSymbol((const void *)(&symbol), src, count, offset, kind); 
# 572
} 
# 614 "/usr/include/cuda_runtime.h" 3
template< class T> static inline cudaError_t 
# 615
cudaMemcpyToSymbolAsync(const T &
# 616
symbol, const void *
# 617
src, size_t 
# 618
count, size_t 
# 619
offset = 0, cudaMemcpyKind 
# 620
kind = cudaMemcpyHostToDevice, cudaStream_t 
# 621
stream = 0) 
# 623
{ 
# 624
return ::cudaMemcpyToSymbolAsync((const void *)(&symbol), src, count, offset, kind, stream); 
# 625
} 
# 660 "/usr/include/cuda_runtime.h" 3
template< class T> static inline cudaError_t 
# 661
cudaMemcpyFromSymbol(void *
# 662
dst, const T &
# 663
symbol, size_t 
# 664
count, size_t 
# 665
offset = 0, cudaMemcpyKind 
# 666
kind = cudaMemcpyDeviceToHost) 
# 668
{ 
# 669
return ::cudaMemcpyFromSymbol(dst, (const void *)(&symbol), count, offset, kind); 
# 670
} 
# 712 "/usr/include/cuda_runtime.h" 3
template< class T> static inline cudaError_t 
# 713
cudaMemcpyFromSymbolAsync(void *
# 714
dst, const T &
# 715
symbol, size_t 
# 716
count, size_t 
# 717
offset = 0, cudaMemcpyKind 
# 718
kind = cudaMemcpyDeviceToHost, cudaStream_t 
# 719
stream = 0) 
# 721
{ 
# 722
return ::cudaMemcpyFromSymbolAsync(dst, (const void *)(&symbol), count, offset, kind, stream); 
# 723
} 
# 745 "/usr/include/cuda_runtime.h" 3
template< class T> static inline cudaError_t 
# 746
cudaGetSymbolAddress(void **
# 747
devPtr, const T &
# 748
symbol) 
# 750
{ 
# 751
return ::cudaGetSymbolAddress(devPtr, (const void *)(&symbol)); 
# 752
} 
# 774 "/usr/include/cuda_runtime.h" 3
template< class T> static inline cudaError_t 
# 775
cudaGetSymbolSize(size_t *
# 776
size, const T &
# 777
symbol) 
# 779
{ 
# 780
return ::cudaGetSymbolSize(size, (const void *)(&symbol)); 
# 781
} 
# 817 "/usr/include/cuda_runtime.h" 3
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 818
cudaBindTexture(size_t *
# 819
offset, const texture< T, dim, readMode>  &
# 820
tex, const void *
# 821
devPtr, const cudaChannelFormatDesc &
# 822
desc, size_t 
# 823
size = ((2147483647) * 2U) + 1U) 
# 825
{ 
# 826
return ::cudaBindTexture(offset, &tex, devPtr, &desc, size); 
# 827
} 
# 862 "/usr/include/cuda_runtime.h" 3
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 863
cudaBindTexture(size_t *
# 864
offset, const texture< T, dim, readMode>  &
# 865
tex, const void *
# 866
devPtr, size_t 
# 867
size = ((2147483647) * 2U) + 1U) 
# 869
{ 
# 870
return cudaBindTexture(offset, tex, devPtr, (tex.channelDesc), size); 
# 871
} 
# 918 "/usr/include/cuda_runtime.h" 3
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 919
cudaBindTexture2D(size_t *
# 920
offset, const texture< T, dim, readMode>  &
# 921
tex, const void *
# 922
devPtr, const cudaChannelFormatDesc &
# 923
desc, size_t 
# 924
width, size_t 
# 925
height, size_t 
# 926
pitch) 
# 928
{ 
# 929
return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch); 
# 930
} 
# 976 "/usr/include/cuda_runtime.h" 3
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 977
cudaBindTexture2D(size_t *
# 978
offset, const texture< T, dim, readMode>  &
# 979
tex, const void *
# 980
devPtr, size_t 
# 981
width, size_t 
# 982
height, size_t 
# 983
pitch) 
# 985
{ 
# 986
return ::cudaBindTexture2D(offset, &tex, devPtr, &(tex.channelDesc), width, height, pitch); 
# 987
} 
# 1018 "/usr/include/cuda_runtime.h" 3
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1019
cudaBindTextureToArray(const texture< T, dim, readMode>  &
# 1020
tex, cudaArray_const_t 
# 1021
array, const cudaChannelFormatDesc &
# 1022
desc) 
# 1024
{ 
# 1025
return ::cudaBindTextureToArray(&tex, array, &desc); 
# 1026
} 
# 1056 "/usr/include/cuda_runtime.h" 3
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1057
cudaBindTextureToArray(const texture< T, dim, readMode>  &
# 1058
tex, cudaArray_const_t 
# 1059
array) 
# 1061
{ 
# 1062
cudaChannelFormatDesc desc; 
# 1063
cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
# 1065
return (err == (cudaSuccess)) ? cudaBindTextureToArray(tex, array, desc) : err; 
# 1066
} 
# 1097 "/usr/include/cuda_runtime.h" 3
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1098
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
# 1099
tex, cudaMipmappedArray_const_t 
# 1100
mipmappedArray, const cudaChannelFormatDesc &
# 1101
desc) 
# 1103
{ 
# 1104
return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc); 
# 1105
} 
# 1135 "/usr/include/cuda_runtime.h" 3
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1136
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
# 1137
tex, cudaMipmappedArray_const_t 
# 1138
mipmappedArray) 
# 1140
{ 
# 1141
cudaChannelFormatDesc desc; 
# 1142
cudaArray_t levelArray; 
# 1143
cudaError_t err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0); 
# 1145
if (err != (cudaSuccess)) { 
# 1146
return err; 
# 1147
}  
# 1148
err = ::cudaGetChannelDesc(&desc, levelArray); 
# 1150
return (err == (cudaSuccess)) ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err; 
# 1151
} 
# 1174 "/usr/include/cuda_runtime.h" 3
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1175
cudaUnbindTexture(const texture< T, dim, readMode>  &
# 1176
tex) 
# 1178
{ 
# 1179
return ::cudaUnbindTexture(&tex); 
# 1180
} 
# 1208 "/usr/include/cuda_runtime.h" 3
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1209
cudaGetTextureAlignmentOffset(size_t *
# 1210
offset, const texture< T, dim, readMode>  &
# 1211
tex) 
# 1213
{ 
# 1214
return ::cudaGetTextureAlignmentOffset(offset, &tex); 
# 1215
} 
# 1260 "/usr/include/cuda_runtime.h" 3
template< class T> static inline cudaError_t 
# 1261
cudaFuncSetCacheConfig(T *
# 1262
func, cudaFuncCache 
# 1263
cacheConfig) 
# 1265
{ 
# 1266
return ::cudaFuncSetCacheConfig((const void *)func, cacheConfig); 
# 1267
} 
# 1269
template< class T> static inline cudaError_t 
# 1270
cudaFuncSetSharedMemConfig(T *
# 1271
func, cudaSharedMemConfig 
# 1272
config) 
# 1274
{ 
# 1275
return ::cudaFuncSetSharedMemConfig((const void *)func, config); 
# 1276
} 
# 1305 "/usr/include/cuda_runtime.h" 3
template< class T> inline cudaError_t 
# 1306
cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *
# 1307
numBlocks, T 
# 1308
func, int 
# 1309
blockSize, size_t 
# 1310
dynamicSMemSize) 
# 1311
{ 
# 1312
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, 0); 
# 1313
} 
# 1356 "/usr/include/cuda_runtime.h" 3
template< class T> inline cudaError_t 
# 1357
cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *
# 1358
numBlocks, T 
# 1359
func, int 
# 1360
blockSize, size_t 
# 1361
dynamicSMemSize, unsigned 
# 1362
flags) 
# 1363
{ 
# 1364
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, flags); 
# 1365
} 
# 1370
class __cudaOccupancyB2DHelper { 
# 1371
size_t n; 
# 1373
public: __cudaOccupancyB2DHelper(size_t n_) : n(n_) { } 
# 1374
size_t operator()(int) 
# 1375
{ 
# 1376
return n; 
# 1377
} 
# 1378
}; 
# 1380
template< class UnaryFunction, class T> static inline cudaError_t 
# 1381
cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(int *
# 1382
minGridSize, int *
# 1383
blockSize, T 
# 1384
func, UnaryFunction 
# 1385
blockSizeToDynamicSMemSize, int 
# 1386
blockSizeLimit = 0, unsigned 
# 1387
flags = 0) 
# 1388
{ 
# 1389
cudaError_t status; 
# 1392
int device; 
# 1393
cudaFuncAttributes attr; 
# 1396
int maxThreadsPerMultiProcessor; 
# 1397
int warpSize; 
# 1398
int devMaxThreadsPerBlock; 
# 1399
int multiProcessorCount; 
# 1400
int funcMaxThreadsPerBlock; 
# 1401
int occupancyLimit; 
# 1402
int granularity; 
# 1405
int maxBlockSize = 0; 
# 1406
int numBlocks = 0; 
# 1407
int maxOccupancy = 0; 
# 1410
int blockSizeToTryAligned; 
# 1411
int blockSizeToTry; 
# 1412
int blockSizeLimitAligned; 
# 1413
int occupancyInBlocks; 
# 1414
int occupancyInThreads; 
# 1415
int dynamicSMemSize; 
# 1421
if (((!minGridSize) || (!blockSize)) || (!func)) { 
# 1422
return cudaErrorInvalidValue; 
# 1423
}  
# 1429
status = ::cudaGetDevice(&device); 
# 1430
if (status != (cudaSuccess)) { 
# 1431
return status; 
# 1432
}  
# 1434
status = cudaDeviceGetAttribute(&maxThreadsPerMultiProcessor, cudaDevAttrMaxThreadsPerMultiProcessor, device); 
# 1438
if (status != (cudaSuccess)) { 
# 1439
return status; 
# 1440
}  
# 1442
status = cudaDeviceGetAttribute(&warpSize, cudaDevAttrWarpSize, device); 
# 1446
if (status != (cudaSuccess)) { 
# 1447
return status; 
# 1448
}  
# 1450
status = cudaDeviceGetAttribute(&devMaxThreadsPerBlock, cudaDevAttrMaxThreadsPerBlock, device); 
# 1454
if (status != (cudaSuccess)) { 
# 1455
return status; 
# 1456
}  
# 1458
status = cudaDeviceGetAttribute(&multiProcessorCount, cudaDevAttrMultiProcessorCount, device); 
# 1462
if (status != (cudaSuccess)) { 
# 1463
return status; 
# 1464
}  
# 1466
status = cudaFuncGetAttributes(&attr, func); 
# 1467
if (status != (cudaSuccess)) { 
# 1468
return status; 
# 1469
}  
# 1471
funcMaxThreadsPerBlock = (attr.maxThreadsPerBlock); 
# 1477
occupancyLimit = maxThreadsPerMultiProcessor; 
# 1478
granularity = warpSize; 
# 1480
if (blockSizeLimit == 0) { 
# 1481
blockSizeLimit = devMaxThreadsPerBlock; 
# 1482
}  
# 1484
if (devMaxThreadsPerBlock < blockSizeLimit) { 
# 1485
blockSizeLimit = devMaxThreadsPerBlock; 
# 1486
}  
# 1488
if (funcMaxThreadsPerBlock < blockSizeLimit) { 
# 1489
blockSizeLimit = funcMaxThreadsPerBlock; 
# 1490
}  
# 1492
blockSizeLimitAligned = (((blockSizeLimit + (granularity - 1)) / granularity) * granularity); 
# 1494
for (blockSizeToTryAligned = blockSizeLimitAligned; blockSizeToTryAligned > 0; blockSizeToTryAligned -= granularity) { 
# 1498
if (blockSizeLimit < blockSizeToTryAligned) { 
# 1499
blockSizeToTry = blockSizeLimit; 
# 1500
} else { 
# 1501
blockSizeToTry = blockSizeToTryAligned; 
# 1502
}  
# 1504
dynamicSMemSize = blockSizeToDynamicSMemSize(blockSizeToTry); 
# 1506
status = cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&occupancyInBlocks, func, blockSizeToTry, dynamicSMemSize, flags); 
# 1513
if (status != (cudaSuccess)) { 
# 1514
return status; 
# 1515
}  
# 1517
occupancyInThreads = (blockSizeToTry * occupancyInBlocks); 
# 1519
if (occupancyInThreads > maxOccupancy) { 
# 1520
maxBlockSize = blockSizeToTry; 
# 1521
numBlocks = occupancyInBlocks; 
# 1522
maxOccupancy = occupancyInThreads; 
# 1523
}  
# 1527
if (occupancyLimit == maxOccupancy) { 
# 1528
break; 
# 1529
}  
# 1530
}  
# 1538
(*minGridSize) = (numBlocks * multiProcessorCount); 
# 1539
(*blockSize) = maxBlockSize; 
# 1541
return status; 
# 1542
} 
# 1575 "/usr/include/cuda_runtime.h" 3
template< class UnaryFunction, class T> static inline cudaError_t 
# 1576
cudaOccupancyMaxPotentialBlockSizeVariableSMem(int *
# 1577
minGridSize, int *
# 1578
blockSize, T 
# 1579
func, UnaryFunction 
# 1580
blockSizeToDynamicSMemSize, int 
# 1581
blockSizeLimit = 0) 
# 1582
{ 
# 1583
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, blockSizeToDynamicSMemSize, blockSizeLimit, 0); 
# 1584
} 
# 1620 "/usr/include/cuda_runtime.h" 3
template< class T> static inline cudaError_t 
# 1621
cudaOccupancyMaxPotentialBlockSize(int *
# 1622
minGridSize, int *
# 1623
blockSize, T 
# 1624
func, size_t 
# 1625
dynamicSMemSize = 0, int 
# 1626
blockSizeLimit = 0) 
# 1627
{ 
# 1628
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, 0); 
# 1629
} 
# 1679 "/usr/include/cuda_runtime.h" 3
template< class T> static inline cudaError_t 
# 1680
cudaOccupancyMaxPotentialBlockSizeWithFlags(int *
# 1681
minGridSize, int *
# 1682
blockSize, T 
# 1683
func, size_t 
# 1684
dynamicSMemSize = 0, int 
# 1685
blockSizeLimit = 0, unsigned 
# 1686
flags = 0) 
# 1687
{ 
# 1688
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, flags); 
# 1689
} 
# 1772 "/usr/include/cuda_runtime.h" 3
template< class T> static inline cudaError_t 
# 1773
cudaLaunch(T *
# 1774
func) 
# 1776
{ 
# 1777
return ::cudaLaunch((const void *)func); 
# 1778
} 
# 1809 "/usr/include/cuda_runtime.h" 3
template< class T> inline cudaError_t 
# 1810
cudaFuncGetAttributes(cudaFuncAttributes *
# 1811
attr, T *
# 1812
entry) 
# 1814
{ 
# 1815
return ::cudaFuncGetAttributes(attr, (const void *)entry); 
# 1816
} 
# 1838 "/usr/include/cuda_runtime.h" 3
template< class T, int dim> static inline cudaError_t 
# 1839
cudaBindSurfaceToArray(const surface< T, dim>  &
# 1840
surf, cudaArray_const_t 
# 1841
array, const cudaChannelFormatDesc &
# 1842
desc) 
# 1844
{ 
# 1845
return ::cudaBindSurfaceToArray(&surf, array, &desc); 
# 1846
} 
# 1867 "/usr/include/cuda_runtime.h" 3
template< class T, int dim> static inline cudaError_t 
# 1868
cudaBindSurfaceToArray(const surface< T, dim>  &
# 1869
surf, cudaArray_const_t 
# 1870
array) 
# 1872
{ 
# 1873
cudaChannelFormatDesc desc; 
# 1874
cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
# 1876
return (err == (cudaSuccess)) ? cudaBindSurfaceToArray(surf, array, desc) : err; 
# 1877
} 
# 1888 "/usr/include/cuda_runtime.h" 3
#pragma GCC diagnostic pop
# 43 "CMakeCUDACompilerId.cu"
const char *info_compiler = ("INFO:compiler[NVIDIA]"); 
# 235 "CMakeCUDACompilerId.cu"
const char info_version[] = {'I', 'N', 'F', 'O', ':', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'r', '_', 'v', 'e', 'r', 's', 'i', 'o', 'n', '[', (48 + ((7 / 10000000) % 10)), (48 + ((7 / 1000000) % 10)), (48 + ((7 / 100000) % 10)), (48 + ((7 / 10000) % 10)), (48 + ((7 / 1000) % 10)), (48 + ((7 / 100) % 10)), (48 + ((7 / 10) % 10)), (48 + (7 % 10)), '.', (48 + ((5 / 10000000) % 10)), (48 + ((5 / 1000000) % 10)), (48 + ((5 / 100000) % 10)), (48 + ((5 / 10000) % 10)), (48 + ((5 / 1000) % 10)), (48 + ((5 / 100) % 10)), (48 + ((5 / 10) % 10)), (48 + (5 % 10)), '.', (48 + ((17 / 10000000) % 10)), (48 + ((17 / 1000000) % 10)), (48 + ((17 / 100000) % 10)), (48 + ((17 / 10000) % 10)), (48 + ((17 / 1000) % 10)), (48 + ((17 / 100) % 10)), (48 + ((17 / 10) % 10)), (48 + (17 % 10)), ']', '\000'}; 
# 282 "CMakeCUDACompilerId.cu"
const char *info_platform = ("INFO:platform[Linux]"); 
# 283
const char *info_arch = ("INFO:arch[]"); 
# 288
const char *info_language_dialect_default = ("INFO:dialect_default[98]"); 
# 304 "CMakeCUDACompilerId.cu"
int main(int argc, char *argv[]) 
# 305
{ 
# 306
int require = 0; 
# 307
require += (info_compiler[argc]); 
# 308
require += (info_platform[argc]); 
# 310
require += ((info_version)[argc]); 
# 318
require += (info_language_dialect_default[argc]); 
# 319
(void)argv; 
# 320
return require; 
# 321
} 

# 1 "CMakeCUDACompilerId.cudafe1.stub.c"
#define _NV_ANON_NAMESPACE _GLOBAL__N__27_CMakeCUDACompilerId_cpp1_ii_bd57c623
# 1 "CMakeCUDACompilerId.cudafe1.stub.c"
#include "CMakeCUDACompilerId.cudafe1.stub.c"
# 1 "CMakeCUDACompilerId.cudafe1.stub.c"
#undef _NV_ANON_NAMESPACE
